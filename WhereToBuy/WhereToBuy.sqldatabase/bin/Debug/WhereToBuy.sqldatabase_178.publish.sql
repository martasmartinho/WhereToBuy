/*
Deployment script for WhereToBuy

This code was generated by a tool.
Changes to this file may cause incorrect behavior and will be lost if
the code is regenerated.
*/

GO
SET ANSI_NULLS, ANSI_PADDING, ANSI_WARNINGS, ARITHABORT, CONCAT_NULL_YIELDS_NULL, QUOTED_IDENTIFIER ON;

SET NUMERIC_ROUNDABORT OFF;


GO
:setvar DatabaseName "WhereToBuy"
:setvar DefaultFilePrefix "WhereToBuy"
:setvar DefaultDataPath "C:\Program Files\Microsoft SQL Server\MSSQL11.MSSQLSERVER\MSSQL\DATA\"
:setvar DefaultLogPath "C:\Program Files\Microsoft SQL Server\MSSQL11.MSSQLSERVER\MSSQL\DATA\"

GO
:on error exit
GO
/*
Detect SQLCMD mode and disable script execution if SQLCMD mode is not supported.
To re-enable the script after enabling SQLCMD mode, execute the following:
SET NOEXEC OFF; 
*/
:setvar __IsSqlCmdEnabled "True"
GO
IF N'$(__IsSqlCmdEnabled)' NOT LIKE N'True'
    BEGIN
        PRINT N'SQLCMD mode must be enabled to successfully execute this script.';
        SET NOEXEC ON;
    END


GO
USE [master];


GO

IF (DB_ID(N'$(DatabaseName)') IS NOT NULL) 
BEGIN
    ALTER DATABASE [$(DatabaseName)]
    SET SINGLE_USER WITH ROLLBACK IMMEDIATE;
    DROP DATABASE [$(DatabaseName)];
END

GO
PRINT N'Creating $(DatabaseName)...'
GO
CREATE DATABASE [$(DatabaseName)]
    ON 
    PRIMARY(NAME = [$(DatabaseName)], FILENAME = N'$(DefaultDataPath)$(DefaultFilePrefix)_Primary.mdf')
    LOG ON (NAME = [$(DatabaseName)_log], FILENAME = N'$(DefaultLogPath)$(DefaultFilePrefix)_Primary.ldf') COLLATE Latin1_General_CI_AS
GO
IF EXISTS (SELECT 1
           FROM   [master].[dbo].[sysdatabases]
           WHERE  [name] = N'$(DatabaseName)')
    BEGIN
        ALTER DATABASE [$(DatabaseName)]
            SET ANSI_NULLS ON,
                ANSI_PADDING ON,
                ANSI_WARNINGS ON,
                ARITHABORT ON,
                CONCAT_NULL_YIELDS_NULL ON,
                NUMERIC_ROUNDABORT OFF,
                QUOTED_IDENTIFIER ON,
                ANSI_NULL_DEFAULT ON,
                CURSOR_DEFAULT LOCAL,
                RECOVERY FULL,
                CURSOR_CLOSE_ON_COMMIT OFF,
                AUTO_CREATE_STATISTICS ON,
                AUTO_SHRINK ON,
                AUTO_UPDATE_STATISTICS ON,
                RECURSIVE_TRIGGERS OFF 
            WITH ROLLBACK IMMEDIATE;
        ALTER DATABASE [$(DatabaseName)]
            SET AUTO_CLOSE OFF 
            WITH ROLLBACK IMMEDIATE;
    END


GO
IF EXISTS (SELECT 1
           FROM   [master].[dbo].[sysdatabases]
           WHERE  [name] = N'$(DatabaseName)')
    BEGIN
        ALTER DATABASE [$(DatabaseName)]
            SET ALLOW_SNAPSHOT_ISOLATION OFF;
    END


GO
IF EXISTS (SELECT 1
           FROM   [master].[dbo].[sysdatabases]
           WHERE  [name] = N'$(DatabaseName)')
    BEGIN
        ALTER DATABASE [$(DatabaseName)]
            SET READ_COMMITTED_SNAPSHOT OFF;
    END


GO
IF EXISTS (SELECT 1
           FROM   [master].[dbo].[sysdatabases]
           WHERE  [name] = N'$(DatabaseName)')
    BEGIN
        ALTER DATABASE [$(DatabaseName)]
            SET AUTO_UPDATE_STATISTICS_ASYNC OFF,
                PAGE_VERIFY NONE,
                DATE_CORRELATION_OPTIMIZATION OFF,
                DISABLE_BROKER,
                PARAMETERIZATION SIMPLE,
                SUPPLEMENTAL_LOGGING OFF 
            WITH ROLLBACK IMMEDIATE;
    END


GO
IF IS_SRVROLEMEMBER(N'sysadmin') = 1
    BEGIN
        IF EXISTS (SELECT 1
                   FROM   [master].[dbo].[sysdatabases]
                   WHERE  [name] = N'$(DatabaseName)')
            BEGIN
                EXECUTE sp_executesql N'ALTER DATABASE [$(DatabaseName)]
    SET TRUSTWORTHY OFF,
        DB_CHAINING OFF 
    WITH ROLLBACK IMMEDIATE';
            END
    END
ELSE
    BEGIN
        PRINT N'The database settings cannot be modified. You must be a SysAdmin to apply these settings.';
    END


GO
IF IS_SRVROLEMEMBER(N'sysadmin') = 1
    BEGIN
        IF EXISTS (SELECT 1
                   FROM   [master].[dbo].[sysdatabases]
                   WHERE  [name] = N'$(DatabaseName)')
            BEGIN
                EXECUTE sp_executesql N'ALTER DATABASE [$(DatabaseName)]
    SET HONOR_BROKER_PRIORITY OFF 
    WITH ROLLBACK IMMEDIATE';
            END
    END
ELSE
    BEGIN
        PRINT N'The database settings cannot be modified. You must be a SysAdmin to apply these settings.';
    END


GO
ALTER DATABASE [$(DatabaseName)]
    SET TARGET_RECOVERY_TIME = 0 SECONDS 
    WITH ROLLBACK IMMEDIATE;


GO
IF EXISTS (SELECT 1
           FROM   [master].[dbo].[sysdatabases]
           WHERE  [name] = N'$(DatabaseName)')
    BEGIN
        ALTER DATABASE [$(DatabaseName)]
            SET FILESTREAM(NON_TRANSACTED_ACCESS = OFF),
                CONTAINMENT = NONE 
            WITH ROLLBACK IMMEDIATE;
    END


GO
USE [$(DatabaseName)];


GO
IF fulltextserviceproperty(N'IsFulltextInstalled') = 1
    EXECUTE sp_fulltext_database 'enable';


GO
/*
 Pre-Deployment Script Template							
--------------------------------------------------------------------------------------
 This file contains SQL statements that will be executed before the build script.	
 Use SQLCMD syntax to include a file in the pre-deployment script.			
 Example:      :r .\myfile.sql								
 Use SQLCMD syntax to reference a variable in the pre-deployment script.		
 Example:      :setvar TableName MyTable							
               SELECT * FROM [$(TableName)]					
--------------------------------------------------------------------------------------
*/

-- cria a base de dados se não exstir ainda
IF NOT EXISTS(SELECT [Name] FROM [SYS].[DATABASES] WHERE [Name] = 'WhereToBuy')
BEGIN
	CREATE DATABASE WhereToBuy COLLATE LATIN1_GENERAL_CI_AS	-- ATENÇÃO QUE TEM TAMBÉM QUE SE ALTERAR A COLLATION NAS PROPRIEDADES DESTE PROJETO
END						
GO

GO
PRINT N'Creating [dbo].[AvisosTipo]...';


GO
CREATE TABLE [dbo].[AvisosTipo] (
    [Codigo]    NVARCHAR (5)   NOT NULL,
    [Descricao] NVARCHAR (128) NOT NULL,
    [Gravidade] SMALLINT       NOT NULL,
    [Notas]     NVARCHAR (256) NULL,
    [Icon]      NVARCHAR (20)  NULL,
    [Inativo]   BIT            NOT NULL,
    [Criacao]   SMALLDATETIME  NOT NULL,
    [Versao]    DATETIME       NOT NULL,
    CONSTRAINT [PK_AvisosTipo] PRIMARY KEY CLUSTERED ([Codigo] ASC)
);


GO
PRINT N'Creating [dbo].[Categorias]...';


GO
CREATE TABLE [dbo].[Categorias] (
    [Codigo]            NVARCHAR (20) NOT NULL,
    [Descricao]         NVARCHAR (50) NOT NULL,
    [PesoMedioUnidade]  FLOAT (53)    NOT NULL,
    [PrecoAmplitudeMax] TINYINT       NOT NULL,
    [Inativo]           BIT           NOT NULL,
    [Criacao]           SMALLDATETIME NOT NULL,
    [Versao]            DATETIME      NOT NULL,
    CONSTRAINT [PK_Categorias] PRIMARY KEY CLUSTERED ([Codigo] ASC)
);


GO
PRINT N'Creating [dbo].[CategoriasMatching]...';


GO
CREATE TABLE [dbo].[CategoriasMatching] (
    [FornecedorCodigo] NVARCHAR (5)   NOT NULL,
    [Codigo]           NVARCHAR (128) NOT NULL,
    [Descricao]        NVARCHAR (128) NOT NULL,
    [MapTo]            NVARCHAR (20)  NULL,
    [Inativo]          BIT            NOT NULL,
    [Criacao]          SMALLDATETIME  NOT NULL,
    [Versao]           DATETIME       NOT NULL,
    CONSTRAINT [PK_CategoriasMatching] PRIMARY KEY CLUSTERED ([FornecedorCodigo] ASC, [Codigo] ASC)
);


GO
PRINT N'Creating [dbo].[Complementos]...';


GO
CREATE TABLE [dbo].[Complementos] (
    [Codigo]           NVARCHAR (5)   NOT NULL,
    [Descricao]        NVARCHAR (50)  NOT NULL,
    [TermoAcrescentar] NVARCHAR (50)  NULL,
    [TermosRemover]    NVARCHAR (100) NULL,
    [Inativo]          BIT            NOT NULL,
    [Criacao]          SMALLDATETIME  NOT NULL,
    [Versao]           DATETIME       NOT NULL,
    CONSTRAINT [PK_Complementos] PRIMARY KEY CLUSTERED ([Codigo] ASC)
);


GO
PRINT N'Creating [dbo].[ComplementosMatching]...';


GO
CREATE TABLE [dbo].[ComplementosMatching] (
    [FornecedorCodigo] NVARCHAR (5)   NOT NULL,
    [Codigo]           NVARCHAR (128) NOT NULL,
    [Descricao]        NVARCHAR (128) NOT NULL,
    [MapTo]            NVARCHAR (5)   NULL,
    [Inativo]          BIT            NOT NULL,
    [Criacao]          SMALLDATETIME  NOT NULL,
    [Versao]           DATETIME       NOT NULL,
    CONSTRAINT [PK_ComplementosMatching] PRIMARY KEY CLUSTERED ([FornecedorCodigo] ASC, [Codigo] ASC)
);


GO
PRINT N'Creating [dbo].[Cotacoes]...';


GO
CREATE TABLE [dbo].[Cotacoes] (
    [FornecedorCodigo]                  NVARCHAR (5)    NOT NULL,
    [Data]                              DATETIME        NOT NULL,
    [_ProdutoCodigo]                    NVARCHAR (256)  NOT NULL,
    [_ComplementoCodigo]                NVARCHAR (128)  NOT NULL,
    [_ComplementoDescricao]             NVARCHAR (128)  NOT NULL,
    [_Partnumber]                       NVARCHAR (25)   NOT NULL,
    [_MarcaCodigo]                      NVARCHAR (128)  NOT NULL,
    [_MarcaDescricao]                   NVARCHAR (128)  NOT NULL,
    [_CategoriaCodigo]                  NVARCHAR (128)  NOT NULL,
    [_CategoriaDescricao]               NVARCHAR (128)  NOT NULL,
    [_StockCodigo]                      NVARCHAR (128)  NOT NULL,
    [_StockDescricao]                   NVARCHAR (128)  NOT NULL,
    [_ImpostoCodigo]                    NVARCHAR (128)  NOT NULL,
    [_ImpostoDescricao]                 NVARCHAR (128)  NOT NULL,
    [_EstadoCodigo]                     NVARCHAR (128)  NOT NULL,
    [_EstadoDescricao]                  NVARCHAR (128)  NOT NULL,
    [_Descricao]                        NVARCHAR (256)  NOT NULL,
    [_Link]                             NVARCHAR (1024) NOT NULL,
    [_Caracteristicas]                  NVARCHAR (2048) NOT NULL,
    [_Imagem]                           NVARCHAR (1024) NOT NULL,
    [_Preco]                            DECIMAL (14, 4) NOT NULL,
    [_OutrosCustos]                     DECIMAL (14, 4) NOT NULL,
    [_OutrosCustosDescricao]            NVARCHAR (128)  NOT NULL,
    [ComplementoCodigo]                 NVARCHAR (5)    NULL,
    [Partnumber]                        NVARCHAR (25)   NULL,
    [MarcaCodigo]                       NVARCHAR (5)    NULL,
    [CategoriaCodigo]                   NVARCHAR (20)   NULL,
    [StockCodigo]                       NVARCHAR (5)    NULL,
    [StockCodigoSubstituto]             NVARCHAR (5)    NULL,
    [StockCodigoSubstitutoJustificacao] NVARCHAR (256)  NULL,
    [ImpostoCodigo]                     NVARCHAR (5)    NULL,
    [EstadoCodigo]                      NVARCHAR (5)    NULL,
    [Descricao]                         NVARCHAR (256)  NULL,
    [Link]                              NVARCHAR (1024) NULL,
    [Caracteristicas]                   NVARCHAR (2048) NULL,
    [Imagem]                            NVARCHAR (1024) NULL,
    [PrecoCusto]                        DECIMAL (14, 4) NULL,
    [PrecoCustoFormula]                 NVARCHAR (256)  NULL,
    [Validade]                          SMALLDATETIME   NULL,
    [ValidadeFormula]                   NVARCHAR (256)  NULL,
    [ProdutoCodigo]                     NVARCHAR (40)   NULL,
    [Completo]                          BIT             NOT NULL,
    [Integrado]                         BIT             NOT NULL,
    [Inativo]                           BIT             NOT NULL,
    [Versao]                            DATETIME        NOT NULL,
    CONSTRAINT [PK_Cotacoes] PRIMARY KEY CLUSTERED ([FornecedorCodigo] ASC, [Data] ASC, [_ProdutoCodigo] ASC, [_ComplementoCodigo] ASC)
);


GO
PRINT N'Creating [dbo].[CotacoesAvisos]...';


GO
CREATE TABLE [dbo].[CotacoesAvisos] (
    [Id]                 UNIQUEIDENTIFIER NOT NULL,
    [Data]               SMALLDATETIME    NOT NULL,
    [_ProdutoCodigo]     NVARCHAR (256)   NOT NULL,
    [_ComplementoCodigo] NVARCHAR (128)   NOT NULL,
    [FornecedorCodigo]   NVARCHAR (5)     NOT NULL,
    [AvisoTipoCodigo]    NVARCHAR (5)     NOT NULL,
    [Descricao]          NVARCHAR (2048)  NOT NULL,
    [Criacao]            SMALLDATETIME    NOT NULL,
    CONSTRAINT [PK_CotacoesAvisos] PRIMARY KEY CLUSTERED ([Id] ASC),
    CONSTRAINT [UC_CotacoesAvisos] UNIQUE NONCLUSTERED ([FornecedorCodigo] ASC, [Data] ASC, [_ProdutoCodigo] ASC, [_ComplementoCodigo] ASC, [AvisoTipoCodigo] ASC)
);


GO
PRINT N'Creating [dbo].[CotacoesRegras]...';


GO
CREATE TABLE [dbo].[CotacoesRegras] (
    [FornecedorCodigo]      NVARCHAR (5)   NOT NULL,
    [MarcaCodigo]           NVARCHAR (5)   NOT NULL,
    [CategoriaCodigo]       NVARCHAR (20)  NOT NULL,
    [StockCodigo]           NVARCHAR (5)   NOT NULL,
    [HorasValidade]         SMALLINT       NOT NULL,
    [StockCodigoSubstituto] NVARCHAR (5)   NULL,
    [DataReset]             SMALLDATETIME  NOT NULL,
    [Notas]                 NVARCHAR (256) NULL,
    CONSTRAINT [PK_CotacoesRegras] PRIMARY KEY CLUSTERED ([FornecedorCodigo] ASC, [MarcaCodigo] ASC, [CategoriaCodigo] ASC, [StockCodigo] ASC)
);


GO
PRINT N'Creating [dbo].[Estados]...';


GO
CREATE TABLE [dbo].[Estados] (
    [Codigo]    NVARCHAR (5)  NOT NULL,
    [Descricao] NVARCHAR (50) NOT NULL,
    [Inativo]   BIT           NOT NULL,
    [Criacao]   SMALLDATETIME NOT NULL,
    [Versao]    DATETIME      NOT NULL,
    CONSTRAINT [PK_Estados] PRIMARY KEY CLUSTERED ([Codigo] ASC)
);


GO
PRINT N'Creating [dbo].[EstadosMatching]...';


GO
CREATE TABLE [dbo].[EstadosMatching] (
    [FornecedorCodigo] NVARCHAR (5)   NOT NULL,
    [Codigo]           NVARCHAR (128) NOT NULL,
    [Descricao]        NVARCHAR (128) NOT NULL,
    [MapTo]            NVARCHAR (5)   NULL,
    [Inativo]          BIT            NOT NULL,
    [Criacao]          SMALLDATETIME  NOT NULL,
    [Versao]           DATETIME       NOT NULL,
    CONSTRAINT [PK_EstadosMatching] PRIMARY KEY CLUSTERED ([FornecedorCodigo] ASC, [Codigo] ASC)
);


GO
PRINT N'Creating [dbo].[Fornecedores]...';


GO
CREATE TABLE [dbo].[Fornecedores] (
    [Codigo]                               NVARCHAR (5)   NOT NULL,
    [Nome]                                 NVARCHAR (50)  NOT NULL,
    [Morada]                               NVARCHAR (200) NOT NULL,
    [CodigoPostal]                         NVARCHAR (15)  NOT NULL,
    [LocalidadePostal]                     NVARCHAR (50)  NOT NULL,
    [Contribuinte]                         NVARCHAR (20)  NOT NULL,
    [Vendedor]                             NVARCHAR (50)  NULL,
    [Telefone]                             NVARCHAR (20)  NULL,
    [Telemovel]                            NVARCHAR (15)  NOT NULL,
    [SMS]                                  NVARCHAR (15)  NOT NULL,
    [Email]                                NVARCHAR (100) NOT NULL,
    [AcessoOnlineAtivo]                    BIT            NOT NULL,
    [Username]                             NVARCHAR (20)  NOT NULL,
    [Password]                             NVARCHAR (20)  NOT NULL,
    [HorasValidadeSugestao]                SMALLINT       NOT NULL,
    [ProdutosMatchingAutomatico]           BIT            NOT NULL,
    [ProdutosCriacaoAutomatica]            BIT            NOT NULL,
    [DisponibilizaInfoProdutoDetalhe]      BIT            NOT NULL,
    [DescricaoPontuacaoInicial]            SMALLINT       NOT NULL,
    [CaracteristicasPontuacaoInicial]      SMALLINT       NOT NULL,
    [LinkPontuacaoInicial]                 SMALLINT       NOT NULL,
    [ImagemPontuacaoInicial]               SMALLINT       NOT NULL,
    [DescricaoSugereInativo]               BIT            NOT NULL,
    [CaracteristicasSugereInativo]         BIT            NOT NULL,
    [LinkSugereInativo]                    BIT            NOT NULL,
    [ImagemSugereInativo]                  BIT            NOT NULL,
    [AtualizacaoAutomaticaInativaSugestao] BIT            NOT NULL,
    [ProdutosConfiancaPreco]               FLOAT (53)     NOT NULL,
    [ProdutosConfiancaDisponibilidade]     FLOAT (53)     NOT NULL,
    [Inativo]                              BIT            NOT NULL,
    [Criacao]                              SMALLDATETIME  NOT NULL,
    [Versao]                               DATETIME       NOT NULL,
    CONSTRAINT [PK_Fornecedores] PRIMARY KEY CLUSTERED ([Codigo] ASC)
);


GO
PRINT N'Creating [dbo].[Impostos]...';


GO
CREATE TABLE [dbo].[Impostos] (
    [Codigo]           NVARCHAR (5)  NOT NULL,
    [Descricao]        NVARCHAR (50) NOT NULL,
    [DesignacaoFiscal] NVARCHAR (50) NOT NULL,
    [Taxa]             FLOAT (53)    NOT NULL,
    [Inativo]          BIT           NOT NULL,
    [Criacao]          SMALLDATETIME NOT NULL,
    [Versao]           DATETIME      NOT NULL,
    CONSTRAINT [PK_Impostos] PRIMARY KEY CLUSTERED ([Codigo] ASC)
);


GO
PRINT N'Creating [dbo].[ImpostosMatching]...';


GO
CREATE TABLE [dbo].[ImpostosMatching] (
    [FornecedorCodigo] NVARCHAR (5)   NOT NULL,
    [Codigo]           NVARCHAR (128) NOT NULL,
    [Descricao]        NVARCHAR (128) NOT NULL,
    [MapTo]            NVARCHAR (5)   NULL,
    [Inativo]          BIT            NOT NULL,
    [Criacao]          SMALLDATETIME  NOT NULL,
    [Versao]           DATETIME       NOT NULL,
    CONSTRAINT [PK_ImpostosMatching] PRIMARY KEY CLUSTERED ([FornecedorCodigo] ASC, [Codigo] ASC)
);


GO
PRINT N'Creating [dbo].[Marcas]...';


GO
CREATE TABLE [dbo].[Marcas] (
    [Codigo]    NVARCHAR (5)  NOT NULL,
    [Descricao] NVARCHAR (50) NOT NULL,
    [Inativo]   BIT           NOT NULL,
    [Criacao]   SMALLDATETIME NOT NULL,
    [Versao]    DATETIME      NOT NULL,
    CONSTRAINT [PK_Marcas] PRIMARY KEY CLUSTERED ([Codigo] ASC)
);


GO
PRINT N'Creating [dbo].[MarcasMatching]...';


GO
CREATE TABLE [dbo].[MarcasMatching] (
    [FornecedorCodigo] NVARCHAR (5)   NOT NULL,
    [Codigo]           NVARCHAR (128) NOT NULL,
    [Descricao]        NVARCHAR (128) NOT NULL,
    [MapTo]            NVARCHAR (5)   NULL,
    [Inativo]          BIT            NOT NULL,
    [Criacao]          SMALLDATETIME  NOT NULL,
    [Versao]           DATETIME       NOT NULL,
    CONSTRAINT [PK_MarcasMatching] PRIMARY KEY CLUSTERED ([FornecedorCodigo] ASC, [Codigo] ASC)
);


GO
PRINT N'Creating [dbo].[Produtos]...';


GO
CREATE TABLE [dbo].[Produtos] (
    [Codigo]             NVARCHAR (40)   NOT NULL,
    [Descricao]          NVARCHAR (256)  NOT NULL,
    [Partnumber]         NVARCHAR (25)   NOT NULL,
    [CategoriaCodigo]    NVARCHAR (20)   NOT NULL,
    [MarcaCodigo]        NVARCHAR (5)    NOT NULL,
    [ImpostoCodigo]      NVARCHAR (5)    NOT NULL,
    [FornecedorCodigo]   NVARCHAR (5)    NOT NULL,
    [PrecoCusto]         DECIMAL (14, 4) NULL,
    [PrecoCusto_Data]    SMALLDATETIME   NULL,
    [PrecoCusto_U1]      DECIMAL (14, 4) NULL,
    [PrecoCusto_U1Data]  SMALLDATETIME   NULL,
    [PrecoCusto_U2]      DECIMAL (14, 4) NULL,
    [PrecoCusto_U2Data]  SMALLDATETIME   NULL,
    [PrecoCusto_U3]      DECIMAL (14, 4) NULL,
    [PrecoCusto_U3Data]  SMALLDATETIME   NULL,
    [StockCodigo]        NVARCHAR (5)    NULL,
    [StockCodigo_Data]   SMALLDATETIME   NULL,
    [StockCodigo_U1]     NVARCHAR (5)    NULL,
    [StockCodigo_U1Data] SMALLDATETIME   NULL,
    [StockCodigo_U2]     NVARCHAR (5)    NULL,
    [StockCodigo_U2Data] SMALLDATETIME   NULL,
    [StockCodigo_U3]     NVARCHAR (5)    NULL,
    [StockCodigo_U3Data] SMALLDATETIME   NULL,
    [Descontinuado]      BIT             NOT NULL,
    [Inativo]            BIT             NOT NULL,
    [Criacao]            SMALLDATETIME   NOT NULL,
    [Versao]             DATETIME        NOT NULL,
    CONSTRAINT [PK_Produtos] PRIMARY KEY CLUSTERED ([Codigo] ASC)
);


GO
PRINT N'Creating [dbo].[ProdutosDetalhe]...';


GO
CREATE TABLE [dbo].[ProdutosDetalhe] (
    [ProdutoCodigo]                NVARCHAR (40)   NOT NULL,
    [FornecedorCodigo]             NVARCHAR (5)    NOT NULL,
    [Descricao]                    NVARCHAR (256)  NOT NULL,
    [DescricaoPontuacao]           SMALLINT        NOT NULL,
    [DescricaoInativa]             BIT             NOT NULL,
    [Caracteristicas]              NVARCHAR (2048) NOT NULL,
    [CaracteristicasPontuacao]     SMALLINT        NOT NULL,
    [CaracteristicasInativas]      BIT             NOT NULL,
    [Link]                         NVARCHAR (1024) NOT NULL,
    [LinkPontuacao]                SMALLINT        NOT NULL,
    [LinkInativo]                  BIT             NOT NULL,
    [Imagem]                       NVARCHAR (1024) NOT NULL,
    [ImagemPontuacao]              SMALLINT        NOT NULL,
    [ImagemInativa]                BIT             NOT NULL,
    [AtualizacaoAutomaticaInativa] BIT             NOT NULL,
    [AtualizacaoManualNecessaria]  BIT             NOT NULL,
    [IndicePreocupacaoConteudo]    TINYINT         NOT NULL,
    [Criacao]                      SMALLDATETIME   NOT NULL,
    [Versao]                       DATETIME        NOT NULL,
    CONSTRAINT [PK_ProdutosDetalhe] PRIMARY KEY CLUSTERED ([ProdutoCodigo] ASC, [FornecedorCodigo] ASC)
);


GO
PRINT N'Creating [dbo].[ProdutosMatching]...';


GO
CREATE TABLE [dbo].[ProdutosMatching] (
    [FornecedorCodigo]                  NVARCHAR (5)   NOT NULL,
    [ComplementoCodigo]                 NVARCHAR (128) NOT NULL,
    [Codigo]                            NVARCHAR (256) NOT NULL,
    [Descricao]                         NVARCHAR (256) NOT NULL,
    [MapTo]                             NVARCHAR (40)  NULL,
    [HorasValidadeCotacao]              SMALLINT       NULL,
    [StockCodigoSubstituto]             NVARCHAR (5)   NULL,
    [DispensaPrevencaoPrecosDesfazados] BIT            NULL,
    [DataReset]                         SMALLDATETIME  NULL,
    [Notas]                             NVARCHAR (256) NULL,
    [Inativo]                           BIT            NOT NULL,
    [Criacao]                           SMALLDATETIME  NOT NULL,
    [Versao]                            DATETIME       NOT NULL,
    CONSTRAINT [PK_ProdutosMatching] PRIMARY KEY CLUSTERED ([FornecedorCodigo] ASC, [ComplementoCodigo] ASC, [Codigo] ASC)
);


GO
PRINT N'Creating [dbo].[Stocks]...';


GO
CREATE TABLE [dbo].[Stocks] (
    [Codigo]               NVARCHAR (5)   NOT NULL,
    [Descricao]            NVARCHAR (50)  NOT NULL,
    [DisponibilidadeNivel] SMALLINT       NOT NULL,
    [Notas]                NVARCHAR (256) NULL,
    [Inativo]              BIT            NOT NULL,
    [Criacao]              SMALLDATETIME  NOT NULL,
    [Versao]               DATETIME       NOT NULL,
    CONSTRAINT [PK_Stocks] PRIMARY KEY CLUSTERED ([Codigo] ASC)
);


GO
PRINT N'Creating [dbo].[StocksMatching]...';


GO
CREATE TABLE [dbo].[StocksMatching] (
    [FornecedorCodigo] NVARCHAR (5)   NOT NULL,
    [Codigo]           NVARCHAR (128) NOT NULL,
    [Descricao]        NVARCHAR (128) NOT NULL,
    [MapTo]            NVARCHAR (5)   NULL,
    [Inativo]          BIT            NOT NULL,
    [Criacao]          SMALLDATETIME  NOT NULL,
    [Versao]           DATETIME       NOT NULL,
    CONSTRAINT [PK_StocksMatching] PRIMARY KEY CLUSTERED ([FornecedorCodigo] ASC, [Codigo] ASC)
);


GO
PRINT N'Creating FK_CategoriasMatching_Fornecedor...';


GO
ALTER TABLE [dbo].[CategoriasMatching]
    ADD CONSTRAINT [FK_CategoriasMatching_Fornecedor] FOREIGN KEY ([FornecedorCodigo]) REFERENCES [dbo].[Fornecedores] ([Codigo]);


GO
PRINT N'Creating FK_CategoriasMatching_MapTo...';


GO
ALTER TABLE [dbo].[CategoriasMatching]
    ADD CONSTRAINT [FK_CategoriasMatching_MapTo] FOREIGN KEY ([MapTo]) REFERENCES [dbo].[Categorias] ([Codigo]);


GO
PRINT N'Creating FK_ComplementosMatching_Fornecedor...';


GO
ALTER TABLE [dbo].[ComplementosMatching]
    ADD CONSTRAINT [FK_ComplementosMatching_Fornecedor] FOREIGN KEY ([FornecedorCodigo]) REFERENCES [dbo].[Fornecedores] ([Codigo]);


GO
PRINT N'Creating FK_ComplementosMatching_MapTo...';


GO
ALTER TABLE [dbo].[ComplementosMatching]
    ADD CONSTRAINT [FK_ComplementosMatching_MapTo] FOREIGN KEY ([MapTo]) REFERENCES [dbo].[Complementos] ([Codigo]);


GO
PRINT N'Creating FK_Cotacoes_Fornecedor...';


GO
ALTER TABLE [dbo].[Cotacoes]
    ADD CONSTRAINT [FK_Cotacoes_Fornecedor] FOREIGN KEY ([FornecedorCodigo]) REFERENCES [dbo].[Fornecedores] ([Codigo]);


GO
PRINT N'Creating FK_Cotacoes_Complemento...';


GO
ALTER TABLE [dbo].[Cotacoes]
    ADD CONSTRAINT [FK_Cotacoes_Complemento] FOREIGN KEY ([ComplementoCodigo]) REFERENCES [dbo].[Complementos] ([Codigo]);


GO
PRINT N'Creating FK_Cotacoes_Marca...';


GO
ALTER TABLE [dbo].[Cotacoes]
    ADD CONSTRAINT [FK_Cotacoes_Marca] FOREIGN KEY ([MarcaCodigo]) REFERENCES [dbo].[Marcas] ([Codigo]);


GO
PRINT N'Creating FK_Cotacoes_Categoria...';


GO
ALTER TABLE [dbo].[Cotacoes]
    ADD CONSTRAINT [FK_Cotacoes_Categoria] FOREIGN KEY ([CategoriaCodigo]) REFERENCES [dbo].[Categorias] ([Codigo]);


GO
PRINT N'Creating FK_Cotacoes_Stock...';


GO
ALTER TABLE [dbo].[Cotacoes]
    ADD CONSTRAINT [FK_Cotacoes_Stock] FOREIGN KEY ([StockCodigo]) REFERENCES [dbo].[Stocks] ([Codigo]);


GO
PRINT N'Creating FK_Cotacoes_StockSubstituto...';


GO
ALTER TABLE [dbo].[Cotacoes]
    ADD CONSTRAINT [FK_Cotacoes_StockSubstituto] FOREIGN KEY ([StockCodigoSubstituto]) REFERENCES [dbo].[Stocks] ([Codigo]);


GO
PRINT N'Creating FK_Cotacoes_Imposto...';


GO
ALTER TABLE [dbo].[Cotacoes]
    ADD CONSTRAINT [FK_Cotacoes_Imposto] FOREIGN KEY ([ImpostoCodigo]) REFERENCES [dbo].[Impostos] ([Codigo]);


GO
PRINT N'Creating FK_Cotacoes_Estado...';


GO
ALTER TABLE [dbo].[Cotacoes]
    ADD CONSTRAINT [FK_Cotacoes_Estado] FOREIGN KEY ([EstadoCodigo]) REFERENCES [dbo].[Estados] ([Codigo]);


GO
PRINT N'Creating FK_Cotacoes_Produto...';


GO
ALTER TABLE [dbo].[Cotacoes]
    ADD CONSTRAINT [FK_Cotacoes_Produto] FOREIGN KEY ([ProdutoCodigo]) REFERENCES [dbo].[Produtos] ([Codigo]);


GO
PRINT N'Creating FK_CotacoesAvisos_Fornecedor...';


GO
ALTER TABLE [dbo].[CotacoesAvisos]
    ADD CONSTRAINT [FK_CotacoesAvisos_Fornecedor] FOREIGN KEY ([FornecedorCodigo]) REFERENCES [dbo].[Fornecedores] ([Codigo]);


GO
PRINT N'Creating FK_CotacoesAvisos_AvisoTipo...';


GO
ALTER TABLE [dbo].[CotacoesAvisos]
    ADD CONSTRAINT [FK_CotacoesAvisos_AvisoTipo] FOREIGN KEY ([AvisoTipoCodigo]) REFERENCES [dbo].[AvisosTipo] ([Codigo]);


GO
PRINT N'Creating FK_CotacoesRegras_Fornecedor...';


GO
ALTER TABLE [dbo].[CotacoesRegras]
    ADD CONSTRAINT [FK_CotacoesRegras_Fornecedor] FOREIGN KEY ([FornecedorCodigo]) REFERENCES [dbo].[Fornecedores] ([Codigo]);


GO
PRINT N'Creating FK_CotacoesRegras_Marca...';


GO
ALTER TABLE [dbo].[CotacoesRegras]
    ADD CONSTRAINT [FK_CotacoesRegras_Marca] FOREIGN KEY ([MarcaCodigo]) REFERENCES [dbo].[Marcas] ([Codigo]);


GO
PRINT N'Creating FK_CotacoesRegras_Categoria...';


GO
ALTER TABLE [dbo].[CotacoesRegras]
    ADD CONSTRAINT [FK_CotacoesRegras_Categoria] FOREIGN KEY ([CategoriaCodigo]) REFERENCES [dbo].[Categorias] ([Codigo]);


GO
PRINT N'Creating FK_CotacoesRegras_Stock...';


GO
ALTER TABLE [dbo].[CotacoesRegras]
    ADD CONSTRAINT [FK_CotacoesRegras_Stock] FOREIGN KEY ([StockCodigo]) REFERENCES [dbo].[Stocks] ([Codigo]);


GO
PRINT N'Creating FK_CotacoesRegras_StockSubstituto...';


GO
ALTER TABLE [dbo].[CotacoesRegras]
    ADD CONSTRAINT [FK_CotacoesRegras_StockSubstituto] FOREIGN KEY ([StockCodigoSubstituto]) REFERENCES [dbo].[Stocks] ([Codigo]);


GO
PRINT N'Creating FK_EstadosMatching_Fornecedor...';


GO
ALTER TABLE [dbo].[EstadosMatching]
    ADD CONSTRAINT [FK_EstadosMatching_Fornecedor] FOREIGN KEY ([FornecedorCodigo]) REFERENCES [dbo].[Fornecedores] ([Codigo]);


GO
PRINT N'Creating FK_EstadosMatching_MapTo...';


GO
ALTER TABLE [dbo].[EstadosMatching]
    ADD CONSTRAINT [FK_EstadosMatching_MapTo] FOREIGN KEY ([MapTo]) REFERENCES [dbo].[Estados] ([Codigo]);


GO
PRINT N'Creating FK_ImpostosMatching_Fornecedor...';


GO
ALTER TABLE [dbo].[ImpostosMatching]
    ADD CONSTRAINT [FK_ImpostosMatching_Fornecedor] FOREIGN KEY ([FornecedorCodigo]) REFERENCES [dbo].[Fornecedores] ([Codigo]);


GO
PRINT N'Creating FK_ImpostosMatching_MapTo...';


GO
ALTER TABLE [dbo].[ImpostosMatching]
    ADD CONSTRAINT [FK_ImpostosMatching_MapTo] FOREIGN KEY ([MapTo]) REFERENCES [dbo].[Impostos] ([Codigo]);


GO
PRINT N'Creating FK_MarcasMatching_Fornecedor...';


GO
ALTER TABLE [dbo].[MarcasMatching]
    ADD CONSTRAINT [FK_MarcasMatching_Fornecedor] FOREIGN KEY ([FornecedorCodigo]) REFERENCES [dbo].[Fornecedores] ([Codigo]);


GO
PRINT N'Creating FK_MarcasMatching_MapTo...';


GO
ALTER TABLE [dbo].[MarcasMatching]
    ADD CONSTRAINT [FK_MarcasMatching_MapTo] FOREIGN KEY ([MapTo]) REFERENCES [dbo].[Marcas] ([Codigo]);


GO
PRINT N'Creating FK_Produtos_Categoria...';


GO
ALTER TABLE [dbo].[Produtos]
    ADD CONSTRAINT [FK_Produtos_Categoria] FOREIGN KEY ([CategoriaCodigo]) REFERENCES [dbo].[Categorias] ([Codigo]);


GO
PRINT N'Creating FK_Produtos_Marca...';


GO
ALTER TABLE [dbo].[Produtos]
    ADD CONSTRAINT [FK_Produtos_Marca] FOREIGN KEY ([MarcaCodigo]) REFERENCES [dbo].[Marcas] ([Codigo]);


GO
PRINT N'Creating FK_Produtos_Imposto...';


GO
ALTER TABLE [dbo].[Produtos]
    ADD CONSTRAINT [FK_Produtos_Imposto] FOREIGN KEY ([ImpostoCodigo]) REFERENCES [dbo].[Impostos] ([Codigo]);


GO
PRINT N'Creating FK_Produtos_Fornecedor...';


GO
ALTER TABLE [dbo].[Produtos]
    ADD CONSTRAINT [FK_Produtos_Fornecedor] FOREIGN KEY ([FornecedorCodigo]) REFERENCES [dbo].[Fornecedores] ([Codigo]);


GO
PRINT N'Creating FK_Produtos_Stock...';


GO
ALTER TABLE [dbo].[Produtos]
    ADD CONSTRAINT [FK_Produtos_Stock] FOREIGN KEY ([StockCodigo]) REFERENCES [dbo].[Stocks] ([Codigo]);


GO
PRINT N'Creating FK_Produtos_Stock_U1...';


GO
ALTER TABLE [dbo].[Produtos]
    ADD CONSTRAINT [FK_Produtos_Stock_U1] FOREIGN KEY ([StockCodigo_U1]) REFERENCES [dbo].[Stocks] ([Codigo]);


GO
PRINT N'Creating FK_Produtos_Stock_U2...';


GO
ALTER TABLE [dbo].[Produtos]
    ADD CONSTRAINT [FK_Produtos_Stock_U2] FOREIGN KEY ([StockCodigo_U2]) REFERENCES [dbo].[Stocks] ([Codigo]);


GO
PRINT N'Creating FK_Produtos_Stock_U3...';


GO
ALTER TABLE [dbo].[Produtos]
    ADD CONSTRAINT [FK_Produtos_Stock_U3] FOREIGN KEY ([StockCodigo_U3]) REFERENCES [dbo].[Stocks] ([Codigo]);


GO
PRINT N'Creating FK_ProdutosDetalhe_Produto...';


GO
ALTER TABLE [dbo].[ProdutosDetalhe]
    ADD CONSTRAINT [FK_ProdutosDetalhe_Produto] FOREIGN KEY ([ProdutoCodigo]) REFERENCES [dbo].[Produtos] ([Codigo]);


GO
PRINT N'Creating FK_ProdutosDetalhe_Fornecedor...';


GO
ALTER TABLE [dbo].[ProdutosDetalhe]
    ADD CONSTRAINT [FK_ProdutosDetalhe_Fornecedor] FOREIGN KEY ([FornecedorCodigo]) REFERENCES [dbo].[Fornecedores] ([Codigo]);


GO
PRINT N'Creating FK_ProdutosMatching_Fornecedor...';


GO
ALTER TABLE [dbo].[ProdutosMatching]
    ADD CONSTRAINT [FK_ProdutosMatching_Fornecedor] FOREIGN KEY ([FornecedorCodigo]) REFERENCES [dbo].[Fornecedores] ([Codigo]);


GO
PRINT N'Creating FK_ProdutosMatching_MapTo...';


GO
ALTER TABLE [dbo].[ProdutosMatching]
    ADD CONSTRAINT [FK_ProdutosMatching_MapTo] FOREIGN KEY ([MapTo]) REFERENCES [dbo].[Produtos] ([Codigo]);


GO
PRINT N'Creating FK_ProdutosMatching_StockSubstituto...';


GO
ALTER TABLE [dbo].[ProdutosMatching]
    ADD CONSTRAINT [FK_ProdutosMatching_StockSubstituto] FOREIGN KEY ([StockCodigoSubstituto]) REFERENCES [dbo].[Stocks] ([Codigo]);


GO
PRINT N'Creating FK_StocksMatching_Fornecedor...';


GO
ALTER TABLE [dbo].[StocksMatching]
    ADD CONSTRAINT [FK_StocksMatching_Fornecedor] FOREIGN KEY ([FornecedorCodigo]) REFERENCES [dbo].[Fornecedores] ([Codigo]);


GO
PRINT N'Creating FK_StocksMatching_MapTo...';


GO
ALTER TABLE [dbo].[StocksMatching]
    ADD CONSTRAINT [FK_StocksMatching_MapTo] FOREIGN KEY ([MapTo]) REFERENCES [dbo].[Stocks] ([Codigo]);


GO
PRINT N'Creating [dbo].[GetTextoLimpoFunction]...';


GO
/*
	O objetivo desta função é limpar uma string com caracteres lixo e espaço em excesso, por exemplo.
*/

CREATE FUNCTION [dbo].GetTextoLimpoFunction
(
	@texto nvarchar(256)
)
RETURNS nvarchar(256)
AS
BEGIN

	-- retirar caracteres vazio inicias e fianis
	SET @texto = LTRIM(RTRIM(@texto));

	-- retirar espaços em excesso (apenas 1 é admissivel)
	SET @texto = REPLACE(@texto, '      ', ' ');
	SET @texto = REPLACE(@texto, '     ', ' ');
	SET @texto = REPLACE(@texto, '    ', ' ');
	SET @texto = REPLACE(@texto, '   ', ' ');
	SET @texto = REPLACE(@texto, '  ', ' ');

	-- retirar acentuação (neste momento temos a garantia que estão todos em maiusculas)
	SET @texto = REPLACE(@texto, 'À', 'A');
	SET @texto = REPLACE(@texto, 'Á', 'A');
	SET @texto = REPLACE(@texto, 'Ã', 'A');
	SET @texto = REPLACE(@texto, 'Â', 'A');
	SET @texto = REPLACE(@texto, 'Ä', 'A');
	SET @texto = REPLACE(@texto, 'È', 'E');
	SET @texto = REPLACE(@texto, 'É', 'E');
	SET @texto = REPLACE(@texto, 'Ê', 'E');
	SET @texto = REPLACE(@texto, 'Ë', 'E');
	SET @texto = REPLACE(@texto, 'Ì', 'I');
	SET @texto = REPLACE(@texto, 'Í', 'I');
	SET @texto = REPLACE(@texto, 'Î', 'I');
	SET @texto = REPLACE(@texto, 'Ï', 'I');
	SET @texto = REPLACE(@texto, 'Ò', 'O');
	SET @texto = REPLACE(@texto, 'Ó', 'O');
	SET @texto = REPLACE(@texto, 'Õ', 'O');
	SET @texto = REPLACE(@texto, 'Ô', 'O');
	SET @texto = REPLACE(@texto, 'Ö', 'O');
	SET @texto = REPLACE(@texto, 'Ù', 'U');
	SET @texto = REPLACE(@texto, 'Ú', 'U');
	SET @texto = REPLACE(@texto, 'Û', 'U');
	SET @texto = REPLACE(@texto, 'Ü', 'U');
	SET @texto = REPLACE(@texto, 'Ç', 'C');


	SET @texto = REPLACE(@texto, 'à', 'a');
	SET @texto = REPLACE(@texto, 'á', 'a');
	SET @texto = REPLACE(@texto, 'ã', 'a');
	SET @texto = REPLACE(@texto, 'â', 'a');
	SET @texto = REPLACE(@texto, 'ä', 'a');
	SET @texto = REPLACE(@texto, 'è', 'e');
	SET @texto = REPLACE(@texto, 'é', 'e');
	SET @texto = REPLACE(@texto, 'ê', 'e');
	SET @texto = REPLACE(@texto, 'ë', 'e');
	SET @texto = REPLACE(@texto, 'ì', 'i');
	SET @texto = REPLACE(@texto, 'í', 'i');
	SET @texto = REPLACE(@texto, 'î', 'i');
	SET @texto = REPLACE(@texto, 'ï', 'i');
	SET @texto = REPLACE(@texto, 'ò', 'o');
	SET @texto = REPLACE(@texto, 'ó', 'o');
	SET @texto = REPLACE(@texto, 'õ', 'o');
	SET @texto = REPLACE(@texto, 'ô', 'o');
	SET @texto = REPLACE(@texto, 'ö', 'o');
	SET @texto = REPLACE(@texto, 'ù', 'u');
	SET @texto = REPLACE(@texto, 'ú', 'u');
	SET @texto = REPLACE(@texto, 'û', 'u');
	SET @texto = REPLACE(@texto, 'ü', 'u');
	SET @texto = REPLACE(@texto, 'ç', 'c');

	-- corrigir caracteres anomalos
	SET @texto = REPLACE(@texto, '´', '');
	SET @texto = REPLACE(@texto, '`', '');
	SET @texto = REPLACE(@texto, '"', '');
	SET @texto = REPLACE(@texto, '~', '');
	SET @texto = REPLACE(@texto, '^', '');
	SET @texto = REPLACE(@texto, '''', '');
	SET @texto = REPLACE(@texto, '¨', '');
	SET @texto = REPLACE(@texto, '\', '/');
	SET @texto = REPLACE(@texto, ',', '.');
	SET @texto = REPLACE(@texto, 'º', '');
	SET @texto = REPLACE(@texto, 'ª', '');

	-- devolver texto limpo
	RETURN @texto;
END
GO
PRINT N'Creating [dbo].[GetTextoOnlyAllowedCharsFunction]...';


GO
/*
	This function receives two arguments. The first one it's the text to be stripped off and the second
	is the pattern of allowed chars.

	All chars not allowed by pattern are excluded from the text and, the result string, is sended
	back to calling point.

	Example of use:
	SELECT [dbo].GetTextoOnlyAllowedCharsFunction('Th.-is is the t-es+t num$ber 93!','[A-Za-z0-9 ]');
*/

CREATE FUNCTION [dbo].GetTextoOnlyAllowedCharsFunction
(
	@texto nvarchar(256),
	@allowedPattern nvarchar(256)
)
RETURNS nvarchar(256)
AS
BEGIN

	-- variaveis
	DECLARE @i AS INTEGER = 1, @n AS INTEGER = LEN(@texto), @result nvarchar(256) = '';

	-- percorrer cada caracter e concatenar apenas os caracteres permitidos
	WHILE @i <= @n
	BEGIN
		
		-- avalia o caracter atual (em processamento)
		IF SUBSTRING(@texto, @i, 1) LIKE @allowedPattern
		BEGIN
			-- se o caracter é válido na expressão regular, adiciona-o à expressão resultante
			SET @result += SUBSTRING(@texto, @i, 1);
		END

		-- incrementar contador
		SET @i += 1;

	END

	-- devolver texto stripped
	RETURN @result;
END
GO
PRINT N'Creating [dbo].[GetCodigoExternoNormalizadoFunction]...';


GO
/*
	This function exist to normalize external coding system.
	The function receives an external code na normalize it to obey allways to the same internal rules of external codification.
	All external codes are normalized with this function when they are inserted on Quotations table.
	We want to prevent little externa changes on code strategy and so minimize not fake not matched situations. As an example, imagine some code that
	leaves lowercase and becomes uppercase.. or the code is improved removing an extra space...
*/



CREATE FUNCTION [dbo].[GetCodigoExternoNormalizadoFunction]
(
	@codigo nvarchar(256)
)
RETURNS nvarchar(256)
AS
BEGIN

	-- subsitui caracteres separadores por espaço (à frente será substituido por underscore)
	SET @codigo = REPLACE(@codigo, '-', ' ');
	SET @codigo = REPLACE(@codigo, '+', ' ');
	SET @codigo = REPLACE(@codigo, '*', ' ');
	SET @codigo = REPLACE(@codigo, '.', ' ');
	SET @codigo = REPLACE(@codigo, ',', ' ');
	SET @codigo = REPLACE(@codigo, ':', ' ');
	SET @codigo = REPLACE(@codigo, ';', ' ');
	SET @codigo = REPLACE(@codigo, '#', ' ');
	SET @codigo = REPLACE(@codigo, '?', ' ');
	SET @codigo = REPLACE(@codigo, '!', ' ');

	-- limpeza de caracteres anómalos
	SET @codigo = dbo.GetTextoLimpoFunction(@codigo);

	-- os códigos externos vão sempre ser transformados em minusculas
	SET @codigo = LOWER(@codigo);

	-- os espaços serão sempre underscores (existe a garantia que os espaços a mais foram removidos na função GetTextoLimpoFunction()
	SET @codigo = REPLACE(@codigo, ' ', '_');

	-- devolver o codigo normalizado e limpo
	RETURN @codigo;
END
GO
PRINT N'Creating [dbo].[GetCotacaoPartnumberFunction]...';


GO
/*
	This function, also used on step 1 of wheretobuy processing, it's used to clean received Partnumber of incorrect spaces 
	(imagine that instead of one space inside the partnumber, external user put two or more spaces wrongly), and prevents too
	from wrong accented chars... etc.

	We want to best normalize the Partnumber to make it more cross comun between several suppliers.

	We decid too that all Partnumbers will be in uppercase.
*/



CREATE FUNCTION [dbo].[GetCotacaoPartnumberFunction]
(
	@_Partnumber nvarchar(25)
)
RETURNS nvarchar(25)
AS
BEGIN

	-- limpar caracteres e espaços anómalos
	SET @_Partnumber = dbo.GetTextoLimpoFunction(@_Partnumber);

	-- os partnumbers serão sempre especificados em maiusculas
	SET @_Partnumber = UPPER(@_Partnumber);

	-- devolver o partnumber limpo e normalizado
	RETURN @_Partnumber;
END
GO
PRINT N'Creating [dbo].[GetCotacaoPartnumberSimplificadoFunction]...';


GO
/*
	This function receives the original Partnumber sended by the supplier and minimize it to only keep the essencials chars (alpha-numeric chars).

	The goal of this processing task, is to improve the chances of matching the partnumber between diferent suppliers (external systems)

	Be aware that, the received Partnumber have already been object of cleaning on Quotations Insert process. However, while in the cleaning
	process only undesirable chars were cleaned, now, with this function, the already cleaned partnumber is reduced to the minimum of representative chars
	to improve chances of matching between several external systems...
*/


CREATE FUNCTION [dbo].[GetCotacaoPartnumberSimplificadoFunction]
(
	@Partnumber nvarchar(25)
)
RETURNS nvarchar(25)
AS
BEGIN

	-- variables
	DECLARE @minimizedPartnumber nvarchar(25);

	-- minimize received Partnumber to the minimum of representative chars
	SET @minimizedPartnumber = [dbo].GetTextoOnlyAllowedCharsFunction(@Partnumber, '[A-Za-z0-9]');

	-- send back the minimized Partnumber version
	RETURN @minimizedPartnumber;
END
GO
PRINT N'Creating [dbo].[GetProdutoCodigoFunction]...';


GO
/*
	This function calculates the Product Code for each Quotation.
	It receives the Brand Code, Addon Code and Partnumber and, after minimize the Partnumber, 
	generates a Product Code concatenating the Brand Code with the Partnumber and with Addon Code as shown below
		
		Product Code = Brand Code + Minimized Partnumber + '[' + Addon Code + ']'

	With this function, we can have access to the Product Code, even before the Product record has been created.

	This function reuses the GetCotacaoPartnumberSimplificado function too minimize the Partnumber, thereby improving
	the chances of matching product codes between different suppliers..
	
	This function receives the Addon Code. Addons are the way to differenciate the same product when a supplier offers
	with some specific add like delivery or extra warranty.
*/


CREATE FUNCTION [dbo].[GetProdutoCodigoFunction]
(
	@Partnumber nvarchar(25),
	@MarcaCodigo nvarchar(5),
	@ComplementoCodigo nvarchar(5)
)
RETURNS nvarchar(40)
AS
BEGIN

	-- variables
	DECLARE @complemento nvarchar(7) = ''; -- ComplementoCodigo + Parenteses = 5 + 2 = 7
	DECLARE @partnumberSimplificado nvarchar(25);

	-- simplify partnumber to be used as part of product code
	SET @partnumberSimplificado = [dbo].[GetCotacaoPartnumberSimplificadoFunction](@Partnumber)

	-- define addon part to be concatenated
	IF UPPER(@ComplementoCodigo) <> 'N/A' AND LEN(RTRIM(@ComplementoCodigo)) > 0
	BEGIN
		SET @complemento = '[' + RTRIM(UPPER(@ComplementoCodigo)) + ']';
	END

	-- return the product code to be used
	RETURN RTRIM(@MarcaCodigo) + @partnumberSimplificado + @complemento;
END
GO
PRINT N'Creating [dbo].[CotacoesAtivasView]...';


GO
/*
	NOTA:
	Esta view materializada, representa todas as cotações inativas = 'false'
		> Incompletas
		> Completas
		> Integradas

	- A view é materializada atendendo ao facto de poder representar um enorme volume de informação
*/


CREATE VIEW [dbo].[CotacoesAtivasView] WITH SchemaBinding -- todos os campos têm que ser especificados pelo facto de ser uma view materializada
	AS 
	SELECT [FornecedorCodigo], [Data], [_ProdutoCodigo], [_ComplementoCodigo], [_ComplementoDescricao],
	       [_Partnumber], [_MarcaCodigo], [_MarcaDescricao], [_CategoriaCodigo], [_CategoriaDescricao], [_StockCodigo], [_StockDescricao],
		   [_ImpostoCodigo], [_ImpostoDescricao], [_EstadoCodigo], [_EstadoDescricao], [_Descricao], [_Link], [_Caracteristicas], [_Imagem], [_Preco], [_OutrosCustos], [_OutrosCustosDescricao],
		   [ComplementoCodigo], [Partnumber], [MarcaCodigo], [CategoriaCodigo], 
		   [StockCodigo], [StockCodigoSubstituto], [StockCodigoSubstitutoJustificacao], 
		   CASE WHEN [StockCodigoSubstituto] IS NULL THEN [StockCodigo] ELSE [StockCodigoSubstituto] END AS [StockCodigoEfetivo],
		   [ImpostoCodigo], [EstadoCodigo], [Descricao], [Link], [Caracteristicas], [Imagem], [PrecoCusto], [PrecoCustoFormula],
		   [Validade], [ValidadeFormula], [ProdutoCodigo], 
		   [Completo], [Integrado],
		   [Inativo], [Versao]
	
	FROM [dbo].[Cotacoes]
	WHERE [Inativo] = CAST('false' as bit);


-- O indice que torna esta view materializada chama-se IDX_CotacoesAtivas.
GO
PRINT N'Creating [dbo].[CotacoesAtivasView].[CotacoesAtivasViewIndex]...';


GO
CREATE UNIQUE CLUSTERED INDEX [CotacoesAtivasViewIndex]
    ON [dbo].[CotacoesAtivasView]([FornecedorCodigo] ASC, [Data] ASC, [_ProdutoCodigo] ASC, [_ComplementoCodigo] ASC);


GO
PRINT N'Creating [dbo].[CotacoesAtuaisView]...';


GO
/*
	Esta View facilita a vista sobre as cotações já integradas (ativas). O conjunto de CotacoesAtuais representa o conjunto de cotações
	atualmente válidas de cada fornecedor para cada produto.
	(Uma cotação atual está completa e integrada e significad que pode ser usada como base para o algoritmo de eleição da melhor cotação)
*/

CREATE VIEW [dbo].[CotacoesAtuaisView]
	AS 
	SELECT *
	FROM [dbo].[CotacoesAtivasView]
	WHERE [Integrado] = CAST('true' as bit)
GO
PRINT N'Creating [dbo].[CotacoesIncompletasView]...';


GO
/*
	Esta View facilita a vista sobre as cotações incompletas e, lógicamente, não integradas (já que uma cotação só pode ser integrada depois de estar completa)
	(Uma cotação incompleta é aquela que falta informação, por exemplo, mapeamentos...)
	(Uma cotação incompleta é uma cotação que ainda falta sofrer processamento para poder ser integrada!)
*/

CREATE VIEW [dbo].[CotacoesIncompletasView]
	AS 
	SELECT *
	FROM [dbo].[CotacoesAtivasView]
	WHERE [Completo] = CAST('false' as bit)
GO
PRINT N'Creating [dbo].[CotacoesNaoIntegradasView]...';


GO
/*
	Esta View facilita a vista sobre as cotações completas mas ainda não integradas 
	(candidatas a integrar ou seja candidatas a CotacoesAtuais)
*/

CREATE VIEW [dbo].[CotacoesNaoIntegradasView]
	AS 
	SELECT *
	FROM [dbo].[CotacoesAtivasView]
	WHERE [Completo] = CAST('true' as bit)
		  AND [Integrado] = CAST('false' as bit)
GO
PRINT N'Creating [dbo].[CotacoesIncompletasMapeamentoProdutoView]...';


GO
/*
	This view represents all Incomplete Quotations that the only map missing it is Produtocodigo.

	This view add Referencia field to CotacoesIncompletasView. 
	This new field represents the Product Code correspondent to Quotations row.
*/

CREATE VIEW [dbo].[CotacoesIncompletasMapeamentoProdutoView]
	AS 
	SELECT *, [dbo].[GetProdutoCodigoFunction](Partnumber, MarcaCodigo, ComplementoCodigo) AS [Referencia]
	FROM [dbo].[CotacoesIncompletasView]
	WHERE MarcaCodigo IS NOT NULL
		  AND CategoriaCodigo IS NOT NULL
		  AND StockCodigo IS NOT NULL
		  AND ImpostoCodigo IS NOT NULL
		  AND ComplementoCodigo IS NOT NULL
		  AND EstadoCodigo IS NOT NULL
		  AND ProdutoCodigo IS NULL
GO
PRINT N'Creating [dbo].[CotacoesMatrizPreenchimentoMapToView]...';


GO
/*
	Shows in a single only row per correspondence FornecedorCodigo, ComplementoCodigo, _ProdutoCodigo,
	quotations that does exist in Product table (Product already exists).

	We want to Map all Product Matching rules that correspondent ProdutoCodigo already exists on Product table.
*/


CREATE VIEW [dbo].[CotacoesMatrizPreenchimentoMapToView]
	AS 

	SELECT *
	FROM
		(
				-- Get all quotations coming from suppliers autorized to automatic match rules of Product Matchings.
				-- Add a last field with a numerator that resets every time that change the sequence FornecedorCodigo / ComplementoCodigo / _ProdutoCodigo
				-- The numerator works as a counter of rows with the same FornecedorCodigo / ComplementoCodigo / _ProdutoCodigo
				SELECT c.*, ROW_NUMBER() OVER (
												PARTITION BY c.FornecedorCodigo, c.ComplementoCodigo, c._ProdutoCodigo 
												ORDER BY c.FornecedorCodigo, c.ComplementoCodigo, c._ProdutoCodigo 
											  ) AS [Classificacao]
				FROM [dbo].[CotacoesIncompletasMapeamentoProdutoView] c
					 INNER JOIN [dbo].[Fornecedores] f
						ON c.FornecedorCodigo = f.Codigo
				WHERE f.ProdutosMatchingAutomatico = CAST('true' as bit)
		) cm1

	-- filter only the first occurrence of FornecedorCodigo / ComplementoCodigo / _ProdutoCodigo
	WHERE cm1.Classificacao = 1
		  -- and make sure that only get quotations of already created products
		  AND cm1.Referencia IN
			  (
				   SELECT Codigo FROM [dbo].[Produtos]
			  )
GO
PRINT N'Creating [dbo].[PartnumbersAmbiguosView]...';


GO
/*
	This view compares the deducted Product Codes from Incomplete Quotations and Product Codes already created. Then, when
	they have a match and the entites (quotation vs product) have different brands, it assumes a Partnumber conflit..

	The view shows ambiguous partnumbers, in other words, all partnumbers that on quotations side belongs to a brand 1 and in product table
	belongs to brand 2...

	If that prevention was a fake negative, user must create the product manually and map it manually too.
*/


CREATE VIEW [dbo].[PartnumbersAmbiguosView]
	AS 
	
	SELECT DISTINCT c.Partnumber

	-- link Products to Quotations via Simplified Partnumber on both sides
	FROM [dbo].[Produtos] p
		 INNER JOIN [dbo].[CotacoesIncompletasMapeamentoProdutoView] c
				ON [dbo].[GetCotacaoPartnumberSimplificadoFunction](p.Partnumber) = [dbo].GetCotacaoPartnumberSimplificadoFunction(c.Partnumber)

	-- filter only not existing products and the ones that brand does not fit on the two sides (quotations - products)
	WHERE c.Referencia NOT IN
		(
			SELECT Codigo FROM [dbo].[Produtos]
		)
		AND p.MarcaCodigo <> c.MarcaCodigo
GO
PRINT N'Creating [dbo].[ProdutosCodigosInexistentesView]...';


GO
/*
	This view represents all Product Codes (ProdutoCodigo) that does not exist and must be created.
*/

CREATE VIEW [dbo].[ProdutosCodigosInexistentesView]
	AS 
	
	-- set of Product Codes (ProdutoCodigo) deducted from Incomplete Quotations (missing only ProdutoCodigo mapping)
	SELECT DISTINCT Referencia
	FROM [dbo].[CotacoesIncompletasMapeamentoProdutoView]

	EXCEPT

	-- set of all existing (already) created Product Codes (ProdutoCodigo)
	SELECT Codigo
	FROM Produtos
GO
PRINT N'Creating [dbo].[CotacoesMatrizCriacaoProdutosView]...';


GO
/*
	With this view we want to create a mechanism to simplify product creating (rows creation on Product table)

	This view is a set of quotations, ensuring only 1 row by Referencia.

	Only Quotations belonging to suppliers that are configured to automatic product creation are considered on this set.

*/


CREATE VIEW [dbo].[CotacoesMatrizCriacaoProdutosView]
	AS 

	SELECT *
	FROM
		(
			-- Get all quotations coming from suppliers autorized for automatic product creation, adding a last field with
			-- a numerator that resets every time that Referencia change. (It works like a counter of rows that have the same Referencia)
			SELECT c.*, ROW_NUMBER() OVER (PARTITION BY c.Referencia ORDER BY Referencia ASC) AS Classificacao
			FROM [dbo].[CotacoesIncompletasMapeamentoProdutoView] c
				 INNER JOIN [dbo].Fornecedores f
					   ON c.FornecedorCodigo = f.Codigo
			WHERE f.ProdutosCriacaoAutomatica = CAST('true' as bit)

		) cm1

	-- filter only the first row of each Referencia present in incomplete quotations view
	WHERE cm1.Classificacao = 1
		  -- and make sure that, that Referencia belongs to the group of not existing products 
		  -- (meaning that this Referencia is not a Product already created)
		  AND cm1.Referencia IN 
					(
						SELECT Referencia FROM [dbo].[ProdutosCodigosInexistentesView]
					)
		  -- make sure too, that the Partnumber does not belong to the ambiguous partnumbers set
		  AND cm1.Partnumber NOT IN
					(
						SELECT Partnumber FROM [dbo].[PartnumbersAmbiguosView]
					)
GO
PRINT N'Creating [dbo].[CotacaoInsertSP]...';


GO
/*
	Esta Stored Procedure é tanto usada nas inserções unitárias (por exemplo a partir de um formulário na web), como
	nas inserções em lote...

	No caso das inserções em lote, antes da importação própriamente dita, as CotacoesIncompletas do fornecedor em questão 
	têm que ser removidas. Assim, o argumento @PrevineDuplicacoes deve ser passado com o valor 'false' já que esta prevenção
	foi efetuada com antecedência.

	No caso das inserções unitárias, o parametro @PrevineDuplicacoes deve ser passado com o valor 'true' para que a remoção
	de qualquer cotação incompleta, seja feita pela própria SP.

	!!! IMPORTANTE !!!
	> Existem campo que têm que ser obrigatóriamente indicados e outros que, se forem null (ou seja não indicados) serão sugeridos
	  automáticamente com (vazio).
	
	> Os campos Validade e ValidadeFormula são recebidos porque os prazos de validade de uma cotação podem ser
	  também comunicados pelo fornecedor. Se forem recebidos como NULL, então é o WhereToBuy que vai atribuir a validade.
*/

CREATE PROCEDURE [dbo].[CotacaoInsertSP]
	@PrevineDuplicacoes bit,
	@FornecedorCodigo nvarchar(20),
	@Data datetime,
	@_ProdutoCodigo nvarchar(256),
	@_ComplementoCodigo nvarchar(128),
	@_ComplementoDescricao nvarchar(128),
	@_Partnumber nvarchar(25),
	@_MarcaCodigo nvarchar(128),
	@_MarcaDescricao nvarchar(128),
	@_CategoriaCodigo nvarchar(128),
	@_CategoriaDescricao nvarchar(128),
	@_StockCodigo nvarchar(128),
	@_StockDescricao nvarchar(128),
	@_ImpostoCodigo nvarchar(128),
	@_ImpostoDescricao nvarchar(128),
	@_EstadoCodigo nvarchar(128),
	@_EstadoDescricao nvarchar(128),
	@_Descricao nvarchar(256),
	@_Link nvarchar(1024),
	@_Caracteristicas nvarchar(2048),
	@_Imagem nvarchar(1024),
	@_Preco decimal(14,4),
	@_OutrosCustos decimal(14,4),
	@_OutrosCustosDescricao nvarchar(128),
	@Validade smalldatetime,
	@ValidadeFormula nvarchar(256),
	@Info nvarchar(256) OUTPUT
AS

	-- variaveis
	DECLARE @Partnumber nvarchar(25);


	/*
		Como esta SP é executada automaticamente para cada linha com o SSIS, pretende-se preencher duas colunas adicionais no resulset
		com o objetivo de, linha a linha, ser possivel perceber o problema encontrado.
	
		Para atingir este objetivo existem dois parametros a ter em conta:
			> @Info é um parametro de saída e deve conter a mensagem a colocar na linha / coluna em processamento no SSIS
			> @RETURN_VALUE que é o interno enviado à frente do RETURN e que corresponde ao numero de registos inseridos.

		Assim, se a SP não for executada pelo SSIS mas sim por uma outra aplicação, caso o RETURN_VALUE seja 0 (zero), o programador 
		deve considerar a mensagem de erro que existirá no parametro de saída @info.
	*/



	-- @PrevineDuplicacoes
	IF @PrevineDuplicacoes IS NULL
	BEGIN
		SET @Info = '[CotacaoInsertSP-01] (StoredProcedure)' + 'o valor do parametro @PrevineDuplicacoes não pode ser nulo!';
		RETURN 0
	END




	-- @FornecedorCodigo
	IF @FornecedorCodigo IS NULL
	BEGIN
		SET @Info = '[CotacaoInsertSP-02] (StoredProcedure)' + 'o valor do parametro @FornecedorCodigo não pode ser nulo!';
		RETURN 0
	END

	IF LEN(RTRIM(@FornecedorCodigo)) < 1
	BEGIN
		SET @Info ='[CotacaoInsertSP-03] (StoredProcedure)' + 'o valor do parametro @FornecedorCodigo tem um tamanho inválido!';
		RETURN 0
	END



	-- @Data
	IF @Data IS NULL
	BEGIN
		SET @Info = '[CotacaoInsertSP-04] (StoredProcedure)' + 'o valor do parametro @Data não pode ser nulo!';
		RETURN 0
	END



	-- @_ProdutoCodigo
	/*
		SERÁ AVALIADO APENAS NO FINAL DOS OUTROS PARAMETROS, PORQUE PRECISAMOS DO VALOR DA MARCA E PARTNUMBER PARA CONSTRUIR UM 
		CÓDIGO DE FORNECEDOR CASO ESTE NÃO ENVIE UM.
	*/



	-- @_ComplementoCodigo
	IF @_ComplementoCodigo IS NULL
	BEGIN
		SET @_ComplementoCodigo = '(vazio)';
	END

	IF LEN(RTRIM(@_ComplementoCodigo)) < 1
	BEGIN
		SET @_ComplementoCodigo = '(vazio)';
	END



	-- @_ComplementoDescricao
	IF @_ComplementoDescricao IS NULL
	BEGIN
		SET @_ComplementoDescricao = @_ComplementoCodigo;
	END

	IF LEN(RTRIM(@_ComplementoDescricao)) < 1
	BEGIN
		SET @_ComplementoDescricao = @_ComplementoCodigo;
	END



	-- @_Partnumber
	IF @_Partnumber IS NULL
	BEGIN
		SET @Info = '[CotacaoInsertSP-11] (StoredProcedure)' + 'o valor do parametro @_Partnumber não pode ser nulo!';
		RETURN 0
	END

	IF LEN(RTRIM(@_Partnumber)) < 1
	BEGIN
		SET @Info = '[CotacaoInsertSP-12] (StoredProcedure)' + 'o valor do parametro @_Partnumber tem um tamanho inválido!';
		RETURN 0
	END



	-- @_MarcaCodigo
	IF @_MarcaCodigo IS NULL
	BEGIN
		SET @Info ='[CotacaoInsertSP-13] (StoredProcedure)' + 'o valor do parametro @_MarcaCodigo não pode ser nulo!';
		RETURN 0
	END

	IF LEN(RTRIM(@_MarcaCodigo)) < 1
	BEGIN
		SET @Info = '[CotacaoInsertSP-14] (StoredProcedure)' + 'o valor do parametro @_MarcaCodigo tem um tamanho inválido!';
		RETURN 0
	END



	-- @_MarcaDescricao
	IF @_MarcaDescricao IS NULL
	BEGIN
		SET @_MarcaDescricao = @_MarcaCodigo;
	END

	IF LEN(RTRIM(@_MarcaDescricao)) < 1
	BEGIN
		SET @_MarcaDescricao = @_MarcaCodigo;
	END



	-- @_CategoriaCodigo
	IF @_CategoriaCodigo IS NULL
	BEGIN
		SET @Info = '[CotacaoInsertSP-17] (StoredProcedure)' + 'o valor do parametro @_CategoriaCodigo não pode ser nulo!';
		RETURN 0
	END

	IF LEN(RTRIM(@_CategoriaCodigo)) < 1
	BEGIN
		SET @Info = '[CotacaoInsertSP-18] (StoredProcedure)' + 'o valor do parametro @_CategoriaCodigo tem um tamanho inválido!';
		RETURN 0
	END




	-- @_CategoriaDescricao
	IF @_CategoriaDescricao IS NULL
	BEGIN
		SET @_CategoriaDescricao = @_CategoriaCodigo;
	END

	IF LEN(RTRIM(@_CategoriaDescricao)) < 1
	BEGIN
		SET @_CategoriaDescricao = @_CategoriaCodigo;
	END




	-- @_StockCodigo
	IF @_StockCodigo IS NULL
	BEGIN
		SET @_StockCodigo = '(vazio)';
	END

	IF LEN(RTRIM(@_StockCodigo)) < 1
	BEGIN
		SET @_StockCodigo = '(vazio)';
	END



	
	-- @_StockDescricao
	IF @_StockDescricao IS NULL
	BEGIN
		SET @_StockDescricao = @_StockCodigo;
	END

	IF LEN(RTRIM(@_StockDescricao)) < 1
	BEGIN
		SET @_StockDescricao = @_StockCodigo;
	END




	-- @_ImpostoCodigo
	IF @_ImpostoCodigo IS NULL
	BEGIN
		SET @_ImpostoCodigo = '(vazio)';
	END

	IF LEN(RTRIM(@_ImpostoCodigo)) < 1
	BEGIN
		SET @_ImpostoCodigo = '(vazio)';
	END



	
	-- @_ImpostoDescricao
	IF @_ImpostoDescricao IS NULL
	BEGIN
		SET @_ImpostoDescricao = @_ImpostoCodigo;
	END

	IF LEN(RTRIM(@_ImpostoDescricao)) < 1
	BEGIN
		SET @_ImpostoDescricao = @_ImpostoCodigo;
	END




	-- @_EstadoCodigo
	IF @_EstadoCodigo IS NULL
	BEGIN
		SET @_EstadoCodigo = '(vazio)';
	END

	IF LEN(RTRIM(@_EstadoCodigo)) < 1
	BEGIN
		SET @_EstadoCodigo = '(vazio)';
	END



	
	-- @_EstadoDescricao
	IF @_EstadoDescricao IS NULL
	BEGIN
		SET @_EstadoDescricao = @_EstadoCodigo;
	END

	IF LEN(RTRIM(@_EstadoDescricao)) < 1
	BEGIN
		SET @_EstadoDescricao = @_EstadoCodigo;
	END




	-- @_Descricao
	IF @_Descricao IS NULL
	BEGIN
		SET @Info = '[CotacaoInsertSP-29] (StoredProcedure)' + 'o valor do parametro @_Descricao não pode ser nulo!';
		RETURN 0
	END

	IF LEN(RTRIM(@_Descricao)) < 1
	BEGIN
		SET @Info = '[CotacaoInsertSP-30] (StoredProcedure)' + 'o valor do parametro @_Descricao tem um tamanho inválido!';
		RETURN 0
	END




	-- @_Link
	IF @_Link IS NULL
	BEGIN
		SET @_Link = '(vazio)';
	END

	IF LEN(RTRIM(@_Link)) < 1
	BEGIN
		SET @_Link = '(vazio)';
	END




	-- @_Caracteristicas
	IF @_Caracteristicas IS NULL
	BEGIN
		SET @_Caracteristicas = '(vazio)';
	END

	IF LEN(RTRIM(@_Caracteristicas)) < 1
	BEGIN
		SET @_Caracteristicas = '(vazio)';
	END




	-- @_Imagem
	IF @_Imagem IS NULL
	BEGIN
		SET @_Imagem = '(vazio)';
	END

	IF LEN(RTRIM(@_Imagem)) < 1
	BEGIN
		SET @_Imagem = '(vazio)';
	END





	-- @_Preco
	IF @_Preco IS NULL
	BEGIN
		SET @Info = '[CotacaoInsertSP-37] (StoredProcedure)' + 'o valor do parametro @_Preco não pode ser nulo!';
		RETURN 0
	END





	-- @_OutrosCustos
	IF @_OutrosCustos IS NULL
	BEGIN
		SET @_OutrosCustos = 0.0;
	END





	-- @_OutrosCustosDescricao
	IF @_OutrosCustosDescricao IS NULL
	BEGIN
		SET @_OutrosCustosDescricao = '(vazio)';
	END

	IF LEN(RTRIM(@_OutrosCustosDescricao)) < 1
	BEGIN
		SET @_OutrosCustosDescricao = '(vazio)';
	END



	-- PREPARAR @Partnumber (INTERNO)
	SET @Partnumber = dbo.GetCotacaoPartnumberFunction(@_Partnumber);



	-- impor regras para códigos externos (sistemas operacionais externos)
	SET @_ComplementoCodigo = dbo.GetCodigoExternoNormalizadoFunction(@_ComplementoCodigo);
	SET @_MarcaCodigo = dbo.GetCodigoExternoNormalizadoFunction(@_MarcaCodigo);
	SET @_CategoriaCodigo = dbo.GetCodigoExternoNormalizadoFunction(@_CategoriaCodigo);
	SET @_StockCodigo = dbo.GetCodigoExternoNormalizadoFunction(@_StockCodigo);
	SET @_ImpostoCodigo = dbo.GetCodigoExternoNormalizadoFunction(@_ImpostoCodigo);
	SET @_EstadoCodigo = dbo.GetCodigoExternoNormalizadoFunction(@_EstadoCodigo);



	-- @_ProdutoCodigo
	IF @_ProdutoCodigo IS NULL
	BEGIN
		SET @_ProdutoCodigo = '(' + @_MarcaCodigo + ')' + @Partnumber; -- uso o @Partnumber interno porque está limpo de caracteres anómalos
	END

	IF LEN(RTRIM(@_ProdutoCodigo)) < 1
	BEGIN
		SET @_ProdutoCodigo = '(' + @_MarcaCodigo + ')' + @Partnumber; -- uso o @Partnumber interno porque está limpo de caracteres anómalos
	END




	-- PREVINE DUPLICAÇÕES (remove a CotacaoNaoIntegrada que possa existir para este FornecedorCodigo / _ProdutoCodigo
	IF @PrevineDuplicacoes = CAST('true' as bit)
	BEGIN
		DELETE FROM [dbo].CotacoesNaoIntegradasView
			   WHERE [FornecedorCodigo] = @FornecedorCodigo
					 AND [_ProdutoCodigo] = @_ProdutoCodigo
	END




	-- INSERIR
	SET NOCOUNT ON; -- não há necessidade de contar os registos (é sempre 1)


	BEGIN TRY
	
		INSERT INTO [dbo].[Cotacoes]
			   (
				   [FornecedorCodigo], [Data], [_ProdutoCodigo], [_ComplementoCodigo], [_ComplementoDescricao],
				   [_Partnumber], [_MarcaCodigo], [_MarcaDescricao], [_CategoriaCodigo], [_CategoriaDescricao], [_StockCodigo], [_StockDescricao],
				   [_ImpostoCodigo], [_ImpostoDescricao], [_EstadoCodigo], [_EstadoDescricao], [_Descricao], [_Link], [_Caracteristicas], [_Imagem], [_Preco], [_OutrosCustos], [_OutrosCustosDescricao],
				   [ComplementoCodigo], [Partnumber], [MarcaCodigo], [CategoriaCodigo], 
				   [StockCodigo], [StockCodigoSubstituto], [StockCodigoSubstitutoJustificacao], 
				   [ImpostoCodigo], [EstadoCodigo], [Descricao], [Link], [Caracteristicas], [PrecoCusto], [PrecoCustoFormula],
				   [Validade], [ValidadeFormula], [ProdutoCodigo], 
				   [Completo], [Integrado],
				   [Inativo], [Versao]
				)
				VALUES
				(
				   @FornecedorCodigo, @Data, @_ProdutoCodigo, @_ComplementoCodigo, @_ComplementoDescricao,
				   @_Partnumber, @_MarcaCodigo, @_MarcaDescricao, @_CategoriaCodigo, @_CategoriaDescricao, @_StockCodigo, @_StockDescricao,
				   @_ImpostoCodigo, @_ImpostoDescricao, @_EstadoCodigo, @_EstadoDescricao, @_Descricao, @_Link, @_Caracteristicas, @_Imagem, @_Preco, @_OutrosCustos, @_OutrosCustosDescricao,
				   null, @Partnumber, null, null, 
				   null, null, null, 
				   null, null, null, null, null, null,
				   null, null, null, null, 
				   CAST('false' as bit), CAST('false' as bit),
				   CAST('false' as bit), GETDATE()
				);


		-- preencher output com informação - sucesso
		SET @Info = 'Cotação inserida com sucesso.';

		-- devolver informação que foi inserido um registo
		RETURN 1;

	END TRY
	BEGIN CATCH

		-- preencher output com informação - sucesso
		SET @Info = '[CotacaoInsertSP-50] ' +CAST(ERROR_NUMBER() as nvarchar) + ' - ' +ERROR_MESSAGE();

		-- devolver informação que foi inserido um registo
		RETURN 1;

	END CATCH

RETURN;
GO
PRINT N'Creating [dbo].[DeleteIncompleteExistingQuotations]...';


GO
/*
	This SP deletes all incomplete quotations from database
*/


CREATE PROCEDURE [dbo].[DeleteIncompleteExistingQuotations]
	@FornecedorCodigo nvarchar(20),
	@Info nvarchar(256) OUTPUT
AS
	
	-- delete incomplete quotations
	BEGIN TRY

		-- remove all incomplete quotations from the supplier received on @FornecedorCodigo
		DELETE FROM [dbo].[CotacoesIncompletasView] WHERE FornecedorCodigo = @FornecedorCodigo;

		-- fill output @info with sucess message
		-- SET @Info = '[DeleteIncompleteExistingQuotations-01] Remoção das cotações incompletas do fornecedor, realizada com sucesso';
		SET @Info = '[DeleteIncompleteExistingQuotations-01] Foram removidas ' + CAST(@@ROWCOUNT as nvarchar) + ' cotações incompletas do fornecedor ' + @FornecedorCodigo + ' com sucesso'

		-- send true to output
		RETURN 1;

	END TRY

	BEGIN CATCH
		-- fill output @info with occurred error message
		SET @Info = '[DeleteIncompleteExistingQuotations-02] ' + CAST(ERROR_NUMBER() as nvarchar) + ' - ' + ERROR_MESSAGE();

		-- send false to output
		RETURN 0;

	END CATCH

RETURN;
GO
PRINT N'Creating [dbo].[Step2a1_CleanAllExistingWarnings]...';


GO
/*
	This SP cleans all rows from CotacoesAvisos Table
*/


CREATE PROCEDURE [dbo].[Step2a1_CleanAllExistingWarnings]
	@Info nvarchar(256) OUTPUT
AS
	
	-- CLEAN TABLE
	BEGIN TRY

		-- clean CotacoesAvisos
		TRUNCATE Table [dbo].[CotacoesAvisos]

		-- fill output @info with sucess message
		SET @Info = '[Step2a1_CleanAllExistingWarnings-01] Limpeza com sucesso da tabela CotacoesAvisos';

		-- send true to output
		RETURN 1;

	END TRY

	BEGIN CATCH
		-- fill output @info with occurred error message
		SET @Info = '[Step2a1_CleanAllExistingWarnings-02] ' + CAST(ERROR_NUMBER() as nvarchar) + ' - ' +ERROR_MESSAGE();

		-- send false to output
		RETURN 0;

	END CATCH

RETURN;
GO
PRINT N'Creating [dbo].[Step2a2_DeleteExpiredQuotations]...';


GO
/*
	This SP remove from database all expired and inactive quotations
*/


CREATE PROCEDURE [dbo].[Step2a2_DeleteExpiredQuotations]
	@Info nvarchar(256) OUTPUT
AS
	
	-- clean old quotations
	BEGIN TRY

		-- remove all expired and inactive Cotacoes
		DELETE FROM [dbo].[Cotacoes] WHERE Inativo = CAST('true' as bit) AND Validade < DATEADD(MONTH, -3, GETDATE())

		-- fill output @info with sucess message
		SET @Info = '[Step2a2_DeleteExpiredQuotations-01] Limpeza com sucesso das cotacoes inativas fora de validade (+3 meses)';

		-- send true to output
		RETURN 1;

	END TRY

	BEGIN CATCH
		-- fill output @info with occurred error message
		SET @Info = '[Step2a2_DeleteExpiredQuotations-02] ' + CAST(ERROR_NUMBER() as nvarchar) + ' - ' + ERROR_MESSAGE();

		-- send false to output
		RETURN 0;

	END CATCH

RETURN;
GO
PRINT N'Creating [dbo].[Step2a3_SetInactiveExpiredQuotations]...';


GO
/*
	This SP set as inactive all expired quotations on Cotacoes table
*/


CREATE PROCEDURE [dbo].[Step2a3_SetInactiveExpiredQuotations]
	@Info nvarchar(256) OUTPUT
AS
	
	-- change expired quotations inactive field value
	BEGIN TRY

		-- set inactive all expired quotations
		UPDATE c
		SET c.Inativo = CAST('true' as bit),
		    c.Versao = GETDATE()
		FROM [dbo].[CotacoesAtuaisView] c
		WHERE Validade < GETDATE();


		-- fill output @info with sucess message
		SET @Info = '[Step2a3_SetInactiveExpiredQuotations-01] Inativação de quotações expiradas realizada com sucesso';

		-- send true to output
		RETURN 1;

	END TRY

	BEGIN CATCH
		-- fill output @info with occurred error message
		SET @Info = '[Step2a3_SetInactiveExpiredQuotations-02] ' + CAST(ERROR_NUMBER() as nvarchar) + ' - ' + ERROR_MESSAGE();

		-- send false to output
		RETURN 0;

	END CATCH

RETURN;
GO
PRINT N'Creating [dbo].[Step2b1a_Mappings_Addons_FeedNewRules]...';


GO
/*
	This SP feeds Addons Matching table with new rules, considering the new incoming quotations
*/


CREATE PROCEDURE [dbo].[Step2b1a_Mappings_Addons_FeedNewRules]
	@Info nvarchar(256) OUTPUT
AS
	
	-- new rules feeding
	BEGIN TRY

		/*
			Feed (...)Matching table with new incomplete rules, to simplify mapping work to the user.
		*/
		INSERT [dbo].[ComplementosMatching] (FornecedorCodigo, Codigo, Descricao, MapTo, Inativo, Criacao, Versao)
	
		SELECT um.FornecedorCodigo, 
			   um.Codigo,
			   (
					-- get 1st existing description in CotacoesIncompletasView for this entity
					SELECT TOP 1 CASE WHEN ci._ComplementoDescricao IS NULL THEN '(vazio)'
									  ELSE ci._ComplementoDescricao
								 END
					FROM [dbo].[CotacoesIncompletasView] ci
					WHERE ci.FornecedorCodigo = um.FornecedorCodigo
						  AND ci._ComplementoCodigo = um.Codigo
				    ORDER BY ci._ComplementoDescricao DESC  -- prevents the existence of some _ComplementoDescricao = NULL
		      ) AS [Descricao],
			  NULL, -- MapTo will be filled later by user
			  CAST('false' as bit),
			  GETDATE(),
			  GETDATE()
		FROM
			  (
					-- un-existing but needed matching rules
					SELECT DISTINCT ci.FornecedorCodigo, ci._ComplementoCodigo AS Codigo
					FROM [dbo].[CotacoesIncompletasView] ci
					EXCEPT
					SELECT cm.FornecedorCodigo, cm.Codigo
					FROM [dbo].[ComplementosMatching] cm
			  ) um

		



		-- fill output @info with sucess message
		SET @Info = '[Step2b1a_Mappings_Addons_FeedNewRules-01] Number of created matching rules: ' + CAST(@@ROWCOUNT as nvarchar);

		-- send true to output
		RETURN 1;

	END TRY

	BEGIN CATCH
		-- fill output @info with occurred error message
		SET @Info = '[Step2b1a_Mappings_Addons_FeedNewRules-02] ' + CAST(ERROR_NUMBER() as nvarchar) + ' - ' + ERROR_MESSAGE();

		-- send false to output
		RETURN 0;

	END CATCH

RETURN;
GO
PRINT N'Creating [dbo].[Step2b1a_Mappings_Brands_FeedNewRules]...';


GO
/*
	This SP feeds MarcasMatching table with new rules, considering the new incoming quotations
*/


CREATE PROCEDURE [dbo].[Step2b1a_Mappings_Brands_FeedNewRules]
	@Info nvarchar(256) OUTPUT
AS
	
	-- new rules feeding
	BEGIN TRY

		/*
			Feed (...)Matching table with new incomplete rules, to simplify mapping work to the user.
		*/

		INSERT [dbo].[MarcasMatching] (FornecedorCodigo, Codigo, Descricao, MapTo, Inativo, Criacao, Versao)
	
		SELECT um.FornecedorCodigo, 
			   um.Codigo,
			   (
					-- get 1st existing description in CotacoesIncompletasView for this entity
					SELECT TOP 1 CASE WHEN ci._MarcaDescricao IS NULL THEN '(vazio)'
									  ELSE ci._MarcaDescricao
								 END
					FROM [dbo].[CotacoesIncompletasView] ci
					WHERE ci.FornecedorCodigo = um.FornecedorCodigo
						  AND ci._MarcaCodigo = um.Codigo
				    ORDER BY ci._MarcaDescricao DESC  -- prevents the existence of some _MarcaDescricao = NULL
		      ) AS [Descricao],
			  NULL, -- MapTo will be filled later by user
			  CAST('false' as bit),
			  GETDATE(),
			  GETDATE()
		FROM
			  (
					-- un-existing but needed matching rules
					SELECT DISTINCT ci.FornecedorCodigo, ci._MarcaCodigo AS Codigo
					FROM [dbo].[CotacoesIncompletasView] ci
					EXCEPT
					SELECT mm.FornecedorCodigo, mm.Codigo
					FROM [dbo].[MarcasMatching] mm
			  ) um
		



		-- fill output @info with sucess message
		SET @Info = '[Step2b1a_Mappings_Brands_FeedNewRules-01] Number of created matching rules: ' + CAST(@@ROWCOUNT as nvarchar);

		-- send true to output
		RETURN 1;

	END TRY

	BEGIN CATCH
		-- fill output @info with occurred error message
		SET @Info = '[Step2b1a_Mappings_Brands_FeedNewRules-02] ' + CAST(ERROR_NUMBER() as nvarchar) + ' - ' + ERROR_MESSAGE();

		-- send false to output
		RETURN 0;

	END CATCH

RETURN;
GO
PRINT N'Creating [dbo].[Step2b1a_Mappings_Categories_FeedNewRules]...';


GO
/*
	This SP feeds CategoriesMatching table with new rules, considering the new incoming quotations
*/


CREATE PROCEDURE [dbo].[Step2b1a_Mappings_Categories_FeedNewRules]
	@Info nvarchar(256) OUTPUT
AS
	
	-- new rules feeding
	BEGIN TRY

		/*
			Feed (...)Matching table with new incomplete rules, to simplify mapping work to the user.
		*/

		INSERT [dbo].[CategoriasMatching] (FornecedorCodigo, Codigo, Descricao, MapTo, Inativo, Criacao, Versao)
	
		SELECT um.FornecedorCodigo, 
			   um.Codigo,
			   (
					-- get 1st existing description in CotacoesIncompletasView for this entity
					SELECT TOP 1 CASE WHEN ci._CategoriaDescricao IS NULL THEN '(vazio)'
									  ELSE ci._CategoriaDescricao
								 END
					FROM [dbo].[CotacoesIncompletasView] ci
					WHERE ci.FornecedorCodigo = um.FornecedorCodigo
						  AND ci._CategoriaCodigo = um.Codigo
				    ORDER BY ci._CategoriaDescricao DESC  -- prevents the existence of some _CategoriaDescricao = NULL
		      ) AS [Descricao],
			  NULL, -- MapTo will be filled later by user
			  CAST('false' as bit),
			  GETDATE(),
			  GETDATE()
		FROM
			  (
					-- un-existing but needed matching rules
					SELECT DISTINCT ci.FornecedorCodigo, ci._CategoriaCodigo AS Codigo
					FROM [dbo].[CotacoesIncompletasView] ci
					EXCEPT
					SELECT tm.FornecedorCodigo, tm.Codigo
					FROM [dbo].[CategoriasMatching] tm
			  ) um
		



		-- fill output @info with sucess message
		SET @Info = '[Step2b1a_Mappings_Categories_FeedNewRules-01] Number of created matching rules: ' + CAST(@@ROWCOUNT as nvarchar);

		-- send true to output
		RETURN 1;

	END TRY

	BEGIN CATCH
		-- fill output @info with occurred error message
		SET @Info = '[Step2b1a_Mappings_Categories_FeedNewRules-02] ' + CAST(ERROR_NUMBER() as nvarchar) + ' - ' + ERROR_MESSAGE();

		-- send false to output
		RETURN 0;

	END CATCH

RETURN;
GO
PRINT N'Creating [dbo].[Step2b1a_Mappings_Statuses_FeedNewRules]...';


GO
/*
	This SP feeds Statuses Matching table with new rules, considering the new incoming quotations
*/


CREATE PROCEDURE [dbo].[Step2b1a_Mappings_Statuses_FeedNewRules]
	@Info nvarchar(256) OUTPUT
AS
	
	-- new rules feeding
	BEGIN TRY

		/*
			Feed (...)Matching table with new incomplete rules, to simplify mapping work to the user.
		*/
		INSERT [dbo].[EstadosMatching] (FornecedorCodigo, Codigo, Descricao, MapTo, Inativo, Criacao, Versao)
	
		SELECT um.FornecedorCodigo, 
			   um.Codigo,
			   (
					-- get 1st existing description in CotacoesIncompletasView for this entity
					SELECT TOP 1 CASE WHEN ci._EstadoDescricao IS NULL THEN '(vazio)'
									  ELSE ci._EstadoDescricao
								 END
					FROM [dbo].[CotacoesIncompletasView] ci
					WHERE ci.FornecedorCodigo = um.FornecedorCodigo
						  AND ci._EstadoCodigo = um.Codigo
				    ORDER BY ci._EstadoDescricao DESC  -- prevents the existence of some _EstadoDescricao = NULL
		      ) AS [Descricao],
			  NULL, -- MapTo will be filled later by user
			  CAST('false' as bit),
			  GETDATE(),
			  GETDATE()
		FROM
			  (
					-- un-existing but needed matching rules
					SELECT DISTINCT ci.FornecedorCodigo, ci._EstadoCodigo AS Codigo
					FROM [dbo].[CotacoesIncompletasView] ci
					EXCEPT
					SELECT dm.FornecedorCodigo, dm.Codigo
					FROM [dbo].[EstadosMatching] dm
			  ) um

		



		-- fill output @info with sucess message
		SET @Info = '[Step2b1a_Mappings_Statuses_FeedNewRules-01] Number of created matching rules: ' + CAST(@@ROWCOUNT as nvarchar);

		-- send true to output
		RETURN 1;

	END TRY

	BEGIN CATCH
		-- fill output @info with occurred error message
		SET @Info = '[Step2b1a_Mappings_Statuses_FeedNewRules-02] ' + CAST(ERROR_NUMBER() as nvarchar) + ' - ' + ERROR_MESSAGE();

		-- send false to output
		RETURN 0;

	END CATCH

RETURN;
GO
PRINT N'Creating [dbo].[Step2b1a_Mappings_Stocks_FeedNewRules]...';


GO
/*
	This SP feeds StocksMatching table with new rules, considering the new incoming quotations
*/


CREATE PROCEDURE [dbo].[Step2b1a_Mappings_Stocks_FeedNewRules]
	@Info nvarchar(256) OUTPUT
AS
	
	-- new rules feeding
	BEGIN TRY

		/*
			Feed (...)Matching table with new incomplete rules, to simplify mapping work to the user.
		*/

		INSERT [dbo].[StocksMatching] (FornecedorCodigo, Codigo, Descricao, MapTo, Inativo, Criacao, Versao)
	
		SELECT um.FornecedorCodigo, 
			   um.Codigo,
			   (
					-- get 1st existing description in CotacoesIncompletasView for this entity
					SELECT TOP 1 CASE WHEN ci._StockDescricao IS NULL THEN '(vazio)'
									  ELSE ci._StockDescricao
								 END
					FROM [dbo].[CotacoesIncompletasView] ci
					WHERE ci.FornecedorCodigo = um.FornecedorCodigo
						  AND ci._StockCodigo = um.Codigo
				    ORDER BY ci._StockDescricao DESC  -- prevents the existence of some _StockDescricao = NULL
		      ) AS [Descricao],
			  NULL, -- MapTo will be filled later by user
			  CAST('false' as bit),
			  GETDATE(),
			  GETDATE()
		FROM
			  (
					-- un-existing but needed matching rules
					SELECT DISTINCT ci.FornecedorCodigo, ci._StockCodigo AS Codigo
					FROM [dbo].[CotacoesIncompletasView] ci
					EXCEPT
					SELECT sm.FornecedorCodigo, sm.Codigo
					FROM [dbo].[StocksMatching] sm
			  ) um
		



		-- fill output @info with sucess message
		SET @Info = '[Step2b1a_Mappings_Stocks_FeedNewRules-01] Number of created matching rules: ' + CAST(@@ROWCOUNT as nvarchar);

		-- send true to output
		RETURN 1;

	END TRY

	BEGIN CATCH
		-- fill output @info with occurred error message
		SET @Info = '[Step2b1a_Mappings_Stocks_FeedNewRules-02] ' + CAST(ERROR_NUMBER() as nvarchar) + ' - ' + ERROR_MESSAGE();

		-- send false to output
		RETURN 0;

	END CATCH

RETURN;
GO
PRINT N'Creating [dbo].[Step2b1a_Mappings_Taxes_FeedNewRules]...';


GO
/*
	This SP feeds Taxes Matching table with new rules, considering the new incoming quotations
*/


CREATE PROCEDURE [dbo].[Step2b1a_Mappings_Taxes_FeedNewRules]
	@Info nvarchar(256) OUTPUT
AS
	
	-- new rules feeding
	BEGIN TRY

		/*
			Feed (...)Matching table with new incomplete rules, to simplify mapping work to the user.
		*/

		INSERT [dbo].[ImpostosMatching] (FornecedorCodigo, Codigo, Descricao, MapTo, Inativo, Criacao, Versao)
	
		SELECT um.FornecedorCodigo, 
			   um.Codigo,
			   (
					-- get 1st existing description in CotacoesIncompletasView for this entity
					SELECT TOP 1 CASE WHEN ci._ImpostoDescricao IS NULL THEN '(vazio)'
									  ELSE ci._ImpostoDescricao
								 END
					FROM [dbo].[CotacoesIncompletasView] ci
					WHERE ci.FornecedorCodigo = um.FornecedorCodigo
						  AND ci._ImpostoCodigo = um.Codigo
				    ORDER BY ci._ImpostoDescricao DESC  -- prevents the existence of some _ImpostoDescricao = NULL
		      ) AS [Descricao],
			  NULL, -- MapTo will be filled later by user
			  CAST('false' as bit),
			  GETDATE(),
			  GETDATE()
		FROM
			  (
					-- un-existing but needed matching rules
					SELECT DISTINCT ci.FornecedorCodigo, ci._ImpostoCodigo AS Codigo
					FROM [dbo].[CotacoesIncompletasView] ci
					EXCEPT
					SELECT im.FornecedorCodigo, im.Codigo
					FROM [dbo].[ImpostosMatching] im
			  ) um
		



		-- fill output @info with sucess message
		SET @Info = '[Step2b1a_Mappings_Taxes_FeedNewRules-01] Number of created matching rules: ' + CAST(@@ROWCOUNT as nvarchar);

		-- send true to output
		RETURN 1;

	END TRY

	BEGIN CATCH
		-- fill output @info with occurred error message
		SET @Info = '[Step2b1a_Mappings_Taxes_FeedNewRules-02] ' + CAST(ERROR_NUMBER() as nvarchar) + ' - ' + ERROR_MESSAGE();

		-- send false to output
		RETURN 0;

	END CATCH

RETURN;
GO
PRINT N'Creating [dbo].[Step2b1b_Mappings_Addons_Map]...';


GO
/*
	This SP, perform Addons Mapping of incomplete Quotations.
*/


CREATE PROCEDURE [dbo].[Step2b1b_Mappings_Addons_Map]
	@Info nvarchar(256) OUTPUT
AS
	
	-- begin matching
	BEGIN TRY

		/*
			Map entities considering (...)Matching rules.
		*/
		UPDATE [dbo].[CotacoesIncompletasView]
		SET ComplementoCodigo = cm.MapTo,
			Versao = GETDATE()

		/*  Using (...)IncompletasView I am assuring that I'm only working with Cotacoes where Inactivo='false' and Completo='false'
			(although, with this mapping lack, never the quotation whould be completed - so this control is redundant)
		*/
		FROM [dbo].[CotacoesIncompletasView] ci
			INNER JOIN [dbo].[ComplementosMatching] cm
				ON ci.FornecedorCodigo = cm.FornecedorCodigo
					AND ci._ComplementoCodigo = cm.Codigo

		-- filter only active matching rules with MapTo already settled, and not mapped incomplete quotations
		WHERE cm.Inativo = CAST('false' as bit)
			  AND ci.ComplementoCodigo IS NULL
			  AND cm.MapTo IS NOT NULL



		-- fill output @info with sucess message
		SET @Info = '[Step2b1b_Mappings_Addons_Map-01] Number of mapped quotations: ' + CAST(@@ROWCOUNT as nvarchar);

		-- send true to output
		RETURN 1;

	END TRY

	BEGIN CATCH
		-- fill output @info with occurred error message
		SET @Info = '[Step2b1b_Mappings_Addons_Map-02] ' + CAST(ERROR_NUMBER() as nvarchar) + ' - ' + ERROR_MESSAGE();

		-- send false to output
		RETURN 0;

	END CATCH

RETURN;
GO
PRINT N'Creating [dbo].[Step2b1b_Mappings_Brands_Map]...';


GO
/*
	This SP, perform Brand Mapping of incomplete Quotations.
*/


CREATE PROCEDURE [dbo].[Step2b1b_Mappings_Brands_Map]
	@Info nvarchar(256) OUTPUT
AS
	
	-- begin matching
	BEGIN TRY

		/*
			Map entities considering (...)Matching rules.
		*/
		UPDATE [dbo].[CotacoesIncompletasView]
		SET MarcaCodigo = mm.MapTo,
			Versao = GETDATE()

		/*  Using (...)IncompletasView I am assuring that I'm only working with Cotacoes where Inactivo='false' and Completo='false'
			(although, with this mapping lack, never the quotation whould be completed - so this control is redundant)
		*/
		FROM [dbo].[CotacoesIncompletasView] ci
			INNER JOIN [dbo].[MarcasMatching] mm
				ON ci.FornecedorCodigo = mm.FornecedorCodigo
					AND ci._MarcaCodigo = mm.Codigo

		-- filter only active matching rules with MapTo already settled, and not mapped incomplete quotations
		WHERE mm.Inativo = CAST('false' as bit)
			  AND ci.MarcaCodigo IS NULL
			  AND mm.MapTo IS NOT NULL



		-- fill output @info with sucess message
		SET @Info = '[Step2b1b_Mappings_Brands_Map-01] Number of mapped quotations: ' + CAST(@@ROWCOUNT as nvarchar);

		-- send true to output
		RETURN 1;

	END TRY

	BEGIN CATCH
		-- fill output @info with occurred error message
		SET @Info = '[Step2b1b_Mappings_Brands_Map-02] ' + CAST(ERROR_NUMBER() as nvarchar) + ' - ' + ERROR_MESSAGE();

		-- send false to output
		RETURN 0;

	END CATCH

RETURN;
GO
PRINT N'Creating [dbo].[Step2b1b_Mappings_Categories_Map]...';


GO
/*
	This SP, perform Category Mapping of incomplete Quotations.
*/


CREATE PROCEDURE [dbo].[Step2b1b_Mappings_Categories_Map]
	@Info nvarchar(256) OUTPUT
AS
	
	-- begin matching
	BEGIN TRY

		/*
			Map entities considering (...)Matching rules.
		*/
		UPDATE [dbo].[CotacoesIncompletasView]
		SET CategoriaCodigo = tm.MapTo,
			Versao = GETDATE()

		/*  Using (...)IncompletasView I am assuring that I'm only working with Cotacoes where Inactivo='false' and Completo='false'
			(although, with this mapping lack, never the quotation whould be completed - so this control is redundant)
		*/
		FROM [dbo].[CotacoesIncompletasView] ci
			INNER JOIN [dbo].[CategoriasMatching] tm
				ON ci.FornecedorCodigo = tm.FornecedorCodigo
					AND ci._CategoriaCodigo = tm.Codigo

		-- filter only active matching rules with MapTo already settled, and not mapped incomplete quotations
		WHERE tm.Inativo = CAST('false' as bit)
			  AND ci.CategoriaCodigo IS NULL
			  AND tm.MapTo IS NOT NULL



		-- fill output @info with sucess message
		SET @Info = '[Step2b1b_Mappings_Categories_Map-01] Number of mapped quotations: ' + CAST(@@ROWCOUNT as nvarchar);

		-- send true to output
		RETURN 1;

	END TRY

	BEGIN CATCH
		-- fill output @info with occurred error message
		SET @Info = '[Step2b1b_Mappings_Categories_Map-02] ' + CAST(ERROR_NUMBER() as nvarchar) + ' - ' + ERROR_MESSAGE();

		-- send false to output
		RETURN 0;

	END CATCH

RETURN;
GO
PRINT N'Creating [dbo].[Step2b1b_Mappings_Statuses_Map]...';


GO
/*
	This SP, perform Statuses Mapping of incomplete Quotations.
*/


CREATE PROCEDURE [dbo].[Step2b1b_Mappings_Statuses_Map]
	@Info nvarchar(256) OUTPUT
AS
	
	-- begin matching
	BEGIN TRY

		/*
			Map entities considering (...)Matching rules.
		*/
		UPDATE [dbo].[CotacoesIncompletasView]
		SET EstadoCodigo = dm.MapTo,
			Versao = GETDATE()

		/*  Using (...)IncompletasView I am assuring that I'm only working with Cotacoes where Inactivo='false' and Completo='false'
			(although, with this mapping lack, never the quotation whould be completed - so this control is redundant)
		*/
		FROM [dbo].[CotacoesIncompletasView] ci
			INNER JOIN [dbo].[EstadosMatching] dm
				ON ci.FornecedorCodigo = dm.FornecedorCodigo
					AND ci._EstadoCodigo = dm.Codigo

		-- filter only active matching rules with MapTo already settled, and not mapped incomplete quotations
		WHERE dm.Inativo = CAST('false' as bit)
			  AND ci.EstadoCodigo IS NULL
			  AND dm.MapTo IS NOT NULL



		-- fill output @info with sucess message
		SET @Info = '[Step2b1b_Mappings_Statuses_Map-01] Number of mapped quotations: ' + CAST(@@ROWCOUNT as nvarchar);

		-- send true to output
		RETURN 1;

	END TRY

	BEGIN CATCH
		-- fill output @info with occurred error message
		SET @Info = '[Step2b1b_Mappings_Statuses_Map-02] ' + CAST(ERROR_NUMBER() as nvarchar) + ' - ' + ERROR_MESSAGE();

		-- send false to output
		RETURN 0;

	END CATCH

RETURN;
GO
PRINT N'Creating [dbo].[Step2b1b_Mappings_Stocks_Map]...';


GO
/*
	This SP, perform Stock Mapping of incomplete Quotations.
*/


CREATE PROCEDURE [dbo].[Step2b1b_Mappings_Stocks_Map]
	@Info nvarchar(256) OUTPUT
AS
	
	-- begin matching
	BEGIN TRY

		/*
			Map entities considering (...)Matching rules.
		*/
		UPDATE [dbo].[CotacoesIncompletasView]
		SET StockCodigo = sm.MapTo,
			Versao = GETDATE()

		/*  Using (...)IncompletasView I am assuring that I'm only working with Cotacoes where Inactivo='false' and Completo='false'
			(although, with this mapping lack, never the quotation whould be completed - so this control is redundant)
		*/
		FROM [dbo].[CotacoesIncompletasView] ci
			INNER JOIN [dbo].[StocksMatching] sm
				ON ci.FornecedorCodigo = sm.FornecedorCodigo
					AND ci._StockCodigo = sm.Codigo

		-- filter only active matching rules with MapTo already settled, and not mapped incomplete quotations
		WHERE sm.Inativo = CAST('false' as bit)
			  AND ci.StockCodigo IS NULL
			  AND sm.MapTo IS NOT NULL



		-- fill output @info with sucess message
		SET @Info = '[Step2b1b_Mappings_Stocks_Map-01] Number of mapped quotations: ' + CAST(@@ROWCOUNT as nvarchar);

		-- send true to output
		RETURN 1;

	END TRY

	BEGIN CATCH
		-- fill output @info with occurred error message
		SET @Info = '[Step2b1b_Mappings_Stocks_Map-02] ' + CAST(ERROR_NUMBER() as nvarchar) + ' - ' + ERROR_MESSAGE();

		-- send false to output
		RETURN 0;

	END CATCH

RETURN;
GO
PRINT N'Creating [dbo].[Step2b1b_Mappings_Taxes_Map]...';


GO
/*
	This SP, perform Taxes Mapping of incomplete Quotations.
*/


CREATE PROCEDURE [dbo].[Step2b1b_Mappings_Taxes_Map]
	@Info nvarchar(256) OUTPUT
AS
	
	-- begin matching
	BEGIN TRY

		/*
			Map entities considering (...)Matching rules.
		*/
		UPDATE [dbo].[CotacoesIncompletasView]
		SET ImpostoCodigo = im.MapTo,
			Versao = GETDATE()

		/*  Using (...)IncompletasView I am assuring that I'm only working with Cotacoes where Inactivo='false' and Completo='false'
			(although, with this mapping lack, never the quotation whould be completed - so this control is redundant)
		*/
		FROM [dbo].[CotacoesIncompletasView] ci
			INNER JOIN [dbo].[ImpostosMatching] im
				ON ci.FornecedorCodigo = im.FornecedorCodigo
					AND ci._ImpostoCodigo = im.Codigo

		-- filter only active matching rules with MapTo already settled, and not mapped incomplete quotations
		WHERE im.Inativo = CAST('false' as bit)
			  AND ci.ImpostoCodigo IS NULL
			  AND im.MapTo IS NOT NULL



		-- fill output @info with sucess message
		SET @Info = '[Step2b1b_Mappings_Taxes_Map-01] Number of mapped quotations: ' + CAST(@@ROWCOUNT as nvarchar);

		-- send true to output
		RETURN 1;

	END TRY

	BEGIN CATCH
		-- fill output @info with occurred error message
		SET @Info = '[Step2b1b_Mappings_Taxes_Map-02] ' + CAST(ERROR_NUMBER() as nvarchar) + ' - ' + ERROR_MESSAGE();

		-- send false to output
		RETURN 0;

	END CATCH

RETURN;
GO
PRINT N'Creating [dbo].[Step2b1c_Mappings_Addons_Notifications]...';


GO
/*
	This SP makes sure that user is notified via CotacoesAvisos table, that something 
	wrong happened in the mapping task.
*/

CREATE PROCEDURE [dbo].[Step2b1c_Mappings_Addons_Notifications]
	@Info nvarchar(256) OUTPUT
AS
	
	-- insert notifications on CotacoesAvisos table
	BEGIN TRY

		/*
			Insert notifications rows for all incomplete quotations that remain unmapped
		*/
		INSERT INTO [dbo].[CotacoesAvisos] 
				    (Id, FornecedorCodigo, Data, _ProdutoCodigo, _ComplementoCodigo, AvisoTipoCodigo, Descricao, Criacao)

		SELECT NEWID(), 
			   ci.FornecedorCodigo,
			   ci.Data,
			   ci._ProdutoCodigo,
			   ci._ComplementoCodigo,
			   CASE WHEN cm.Inativo = CAST('true' as bit) THEN 'CICM1' -- inactive mapping rule
					ELSE 'CICM0'									   -- incomplete mapping rule
			   END AS AvisoTipoCodigo,
			   'verifique regra de matching!' AS Descricao,
			   GETDATE() AS Criacao

		FROM [dbo].[CotacoesIncompletasView] ci
			 INNER JOIN [dbo].[ComplementosMatching] cm
				ON ci.FornecedorCodigo = cm.FornecedorCodigo
					AND ci._ComplementoCodigo = cm.Codigo

		-- filter all quotations not yet mapped after the mapping occurrence
		WHERE ci.ComplementoCodigo IS NULL



		-- fill output @info with sucess message
		SET @Info = '[Step2b1c_Mappings_Addons_Notifications-01] Number of inserted notifications: ' + CAST(@@ROWCOUNT as nvarchar);

		-- send true to output
		RETURN 1;

	END TRY

	BEGIN CATCH
		-- fill output @info with occurred error message
		SET @Info = '[Step2b1c_Mappings_Addons_Notifications-02] ' + CAST(ERROR_NUMBER() as nvarchar) + ' - ' + ERROR_MESSAGE();

		-- send false to output
		RETURN 0;

	END CATCH

RETURN;
GO
PRINT N'Creating [dbo].[Step2b1c_Mappings_Brands_Notifications]...';


GO
/*
	This SP makes sure that user is notified via CotacoesAvisos table, that something 
	wrong happened in the mapping task.
*/

CREATE PROCEDURE [dbo].[Step2b1c_Mappings_Brands_Notifications]
	@Info nvarchar(256) OUTPUT
AS
	
	-- insert notifications on CotacoesAvisos table
	BEGIN TRY

		/*
			Insert notifications rows for all incomplete quotations that remain unmapped
		*/
		INSERT INTO [dbo].[CotacoesAvisos] 
				    (Id, FornecedorCodigo, Data, _ProdutoCodigo, _ComplementoCodigo, AvisoTipoCodigo, Descricao, Criacao)

		SELECT NEWID(), 
			   ci.FornecedorCodigo,
			   ci.Data,
			   ci._ProdutoCodigo,
			   ci._ComplementoCodigo,
			   CASE WHEN mm.Inativo = CAST('true' as bit) THEN 'CIMM1' -- inactive mapping rule
					ELSE 'CIMM0'									   -- incomplete mapping rule
			   END AS AvisoTipoCodigo,
			   'verifique regra de matching!' AS Descricao,
			   GETDATE() AS Criacao

		FROM [dbo].[CotacoesIncompletasView] ci
			 INNER JOIN [dbo].[MarcasMatching] mm
				ON ci.FornecedorCodigo = mm.FornecedorCodigo
					AND ci._MarcaCodigo = mm.Codigo

		-- filter all quotations not yet mapped after the mapping occurrence
		WHERE ci.MarcaCodigo IS NULL



		-- fill output @info with sucess message
		SET @Info = '[Step2b1c_Mappings_Brands_Notifications-01] Number of inserted notifications: ' + CAST(@@ROWCOUNT as nvarchar);

		-- send true to output
		RETURN 1;

	END TRY

	BEGIN CATCH
		-- fill output @info with occurred error message
		SET @Info = '[Step2b1c_Mappings_Brands_Notifications-02] ' + CAST(ERROR_NUMBER() as nvarchar) + ' - ' + ERROR_MESSAGE();

		-- send false to output
		RETURN 0;

	END CATCH

RETURN;
GO
PRINT N'Creating [dbo].[Step2b1c_Mappings_Categories_Notifications]...';


GO
/*
	This SP makes sure that user is notified via CotacoesAvisos table, that something 
	wrong happened in the mapping task.
*/

CREATE PROCEDURE [dbo].[Step2b1c_Mappings_Categories_Notifications]
	@Info nvarchar(256) OUTPUT
AS
	
	-- insert notifications on CotacoesAvisos table
	BEGIN TRY

		/*
			Insert notifications rows for all incomplete quotations that remain unmapped
		*/
		INSERT INTO [dbo].[CotacoesAvisos] 
				    (Id, FornecedorCodigo, Data, _ProdutoCodigo, _ComplementoCodigo, AvisoTipoCodigo, Descricao, Criacao)

		SELECT NEWID(), 
			   ci.FornecedorCodigo,
			   ci.Data,
			   ci._ProdutoCodigo,
			   ci._ComplementoCodigo,
			   CASE WHEN tm.Inativo = CAST('true' as bit) THEN 'CITM1' -- inactive mapping rule
					ELSE 'CITM0'									   -- incomplete mapping rule
			   END AS AvisoTipoCodigo,
			   'verifique regra de matching!' AS Descricao,
			   GETDATE() AS Criacao

		FROM [dbo].[CotacoesIncompletasView] ci
			 INNER JOIN [dbo].[CategoriasMatching] tm
				ON ci.FornecedorCodigo = tm.FornecedorCodigo
					AND ci._CategoriaCodigo = tm.Codigo

		-- filter all quotations not yet mapped after the mapping occurrence
		WHERE ci.CategoriaCodigo IS NULL



		-- fill output @info with sucess message
		SET @Info = '[Step2b1c_Mappings_Categories_Notifications-01] Number of inserted notifications: ' + CAST(@@ROWCOUNT as nvarchar);

		-- send true to output
		RETURN 1;

	END TRY

	BEGIN CATCH
		-- fill output @info with occurred error message
		SET @Info = '[Step2b1c_Mappings_Categories_Notifications-02] ' + CAST(ERROR_NUMBER() as nvarchar) + ' - ' + ERROR_MESSAGE();

		-- send false to output
		RETURN 0;

	END CATCH

RETURN;
GO
PRINT N'Creating [dbo].[Step2b1c_Mappings_Statuses_Notifications]...';


GO
/*
	This SP makes sure that user is notified via CotacoesAvisos table, that something 
	wrong happened in the mapping task.
*/

CREATE PROCEDURE [dbo].[Step2b1c_Mappings_Statuses_Notifications]
	@Info nvarchar(256) OUTPUT
AS
	
	-- insert notifications on CotacoesAvisos table
	BEGIN TRY

		/*
			Insert notifications rows for all incomplete quotations that remain unmapped
		*/
		INSERT INTO [dbo].[CotacoesAvisos] 
				    (Id, FornecedorCodigo, Data, _ProdutoCodigo, _ComplementoCodigo, AvisoTipoCodigo, Descricao, Criacao)

		SELECT NEWID(), 
			   ci.FornecedorCodigo,
			   ci.Data,
			   ci._ProdutoCodigo,
			   ci._ComplementoCodigo,
			   CASE WHEN dm.Inativo = CAST('true' as bit) THEN 'CIDM1' -- inactive mapping rule
					ELSE 'CIDM0'									   -- incomplete mapping rule
			   END AS AvisoTipoCodigo,
			   'verifique regra de matching!' AS Descricao,
			   GETDATE() AS Criacao

		FROM [dbo].[CotacoesIncompletasView] ci
			 INNER JOIN [dbo].[EstadosMatching] dm
				ON ci.FornecedorCodigo = dm.FornecedorCodigo
					AND ci._EstadoCodigo = dm.Codigo

		-- filter all quotations not yet mapped after the mapping occurrence
		WHERE ci.EstadoCodigo IS NULL



		-- fill output @info with sucess message
		SET @Info = '[Step2b1c_Mappings_Statuses_Notifications-01] Number of inserted notifications: ' + CAST(@@ROWCOUNT as nvarchar);

		-- send true to output
		RETURN 1;

	END TRY

	BEGIN CATCH
		-- fill output @info with occurred error message
		SET @Info = '[Step2b1c_Mappings_Statuses_Notifications-02] ' + CAST(ERROR_NUMBER() as nvarchar) + ' - ' + ERROR_MESSAGE();

		-- send false to output
		RETURN 0;

	END CATCH

RETURN;
GO
PRINT N'Creating [dbo].[Step2b1c_Mappings_Stocks_Notifications]...';


GO
/*
	This SP makes sure that user is notified via CotacoesAvisos table, that something 
	wrong happened in the mapping task.
*/

CREATE PROCEDURE [dbo].[Step2b1c_Mappings_Stocks_Notifications]
	@Info nvarchar(256) OUTPUT
AS
	
	-- insert notifications on CotacoesAvisos table
	BEGIN TRY

		/*
			Insert notifications rows for all incomplete quotations that remain unmapped
		*/
		INSERT INTO [dbo].[CotacoesAvisos] 
				    (Id, FornecedorCodigo, Data, _ProdutoCodigo, _ComplementoCodigo, AvisoTipoCodigo, Descricao, Criacao)

		SELECT NEWID(), 
			   ci.FornecedorCodigo,
			   ci.Data,
			   ci._ProdutoCodigo,
			   ci._ComplementoCodigo,
			   CASE WHEN sm.Inativo = CAST('true' as bit) THEN 'CISM1' -- inactive mapping rule
					ELSE 'CISM0'									   -- incomplete mapping rule
			   END AS AvisoTipoCodigo,
			   'verifique regra de matching!' AS Descricao,
			   GETDATE() AS Criacao

		FROM [dbo].[CotacoesIncompletasView] ci
			 INNER JOIN [dbo].[StocksMatching] sm
				ON ci.FornecedorCodigo = sm.FornecedorCodigo
					AND ci._StockCodigo = sm.Codigo

		-- filter all quotations not yet mapped after the mapping occurrence
		WHERE ci.StockCodigo IS NULL



		-- fill output @info with sucess message
		SET @Info = '[Step2b1c_Mappings_Stocks_Notifications-01] Number of inserted notifications: ' + CAST(@@ROWCOUNT as nvarchar);

		-- send true to output
		RETURN 1;

	END TRY

	BEGIN CATCH
		-- fill output @info with occurred error message
		SET @Info = '[Step2b1c_Mappings_Stocks_Notifications-02] ' + CAST(ERROR_NUMBER() as nvarchar) + ' - ' + ERROR_MESSAGE();

		-- send false to output
		RETURN 0;

	END CATCH

RETURN;
GO
PRINT N'Creating [dbo].[Step2b1c_Mappings_Taxes_Notifications]...';


GO
/*
	This SP makes sure that user is notified via CotacoesAvisos table, that something 
	wrong happened in the mapping task.
*/

CREATE PROCEDURE [dbo].[Step2b1c_Mappings_Taxes_Notifications]
	@Info nvarchar(256) OUTPUT
AS
	
	-- insert notifications on CotacoesAvisos table
	BEGIN TRY

		/*
			Insert notifications rows for all incomplete quotations that remain unmapped
		*/
		INSERT INTO [dbo].[CotacoesAvisos] 
				    (Id, FornecedorCodigo, Data, _ProdutoCodigo, _ComplementoCodigo, AvisoTipoCodigo, Descricao, Criacao)

		SELECT NEWID(), 
			   ci.FornecedorCodigo,
			   ci.Data,
			   ci._ProdutoCodigo,
			   ci._ComplementoCodigo,
			   CASE WHEN im.Inativo = CAST('true' as bit) THEN 'CIIM1' -- inactive mapping rule
					ELSE 'CIIM0'									   -- incomplete mapping rule
			   END AS AvisoTipoCodigo,
			   'verifique regra de matching!' AS Descricao,
			   GETDATE() AS Criacao

		FROM [dbo].[CotacoesIncompletasView] ci
			 INNER JOIN [dbo].[ImpostosMatching] im
				ON ci.FornecedorCodigo = im.FornecedorCodigo
					AND ci._ImpostoCodigo = im.Codigo

		-- filter all quotations not yet mapped after the mapping occurrence
		WHERE ci.ImpostoCodigo IS NULL



		-- fill output @info with sucess message
		SET @Info = '[Step2b1c_Mappings_Taxes_Notifications-01] Number of inserted notifications: ' + CAST(@@ROWCOUNT as nvarchar);

		-- send true to output
		RETURN 1;

	END TRY

	BEGIN CATCH
		-- fill output @info with occurred error message
		SET @Info = '[Step2b1c_Mappings_Taxes_Notifications-02] ' + CAST(ERROR_NUMBER() as nvarchar) + ' - ' + ERROR_MESSAGE();

		-- send false to output
		RETURN 0;

	END CATCH

RETURN;
GO
/*
Post-Deployment Script Template							
--------------------------------------------------------------------------------------
 This file contains SQL statements that will be appended to the build script.		
 Use SQLCMD syntax to include a file in the post-deployment script.			
 Example:      :r .\myfile.sql								
 Use SQLCMD syntax to reference a variable in the post-deployment script.		
 Example:      :setvar TableName MyTable							
               SELECT * FROM [$(TableName)]					
--------------------------------------------------------------------------------------
*/


/* IMPOSTOS */
IF NOT EXISTS(SELECT [Codigo] FROM [dbo].[Impostos])
BEGIN	
	INSERT INTO [dbo].[Impostos] ([Codigo], [Descricao], [DesignacaoFiscal], [Taxa], [Inativo], [Criacao], [Versao])
		VALUES ('PT.23', 'IVA PT Continental - Taxa Normal de 23%', 'IVA PT.Continental 23%', 23.00, CAST('false' AS bit), GETDATE(), GETDATE())
END


/* COMPLEMENTOS */
IF NOT EXISTS(SELECT [Codigo] FROM [dbo].[Complementos])
BEGIN	
	INSERT INTO [dbo].[Complementos] ([Codigo], [Descricao], [TermoAcrescentar], [TermosRemover], [Inativo], [Criacao], [Versao])
		VALUES ('N/A', 'Não aplicável', NULL, NULL, CAST('false' AS bit), GETDATE(), GETDATE())
END


/* AVISOSTIPO */
IF NOT EXISTS(SELECT [Codigo] FROM [dbo].[AvisosTipo])
BEGIN	
	INSERT INTO [dbo].[AvisosTipo] ([Codigo], [Descricao], [Gravidade], [Notas], [Icon], [Inativo], [Criacao], [Versao])
		 VALUES ('PFS', 'Prevenção Falso Stock', 3, NULL, NULL, CAST('false' AS bit), GETDATE(), GETDATE()),
				('IAPD', 'Inativação Administrativa (Prevenção Preço Desfazado)', 7, NULL, NULL, CAST('false' AS bit), GETDATE(), GETDATE()),
				('CICM0', 'Cotação Incompleta [Complemento] (mapeamento incompleto, preenchimento manual necessário)', 6, NULL, NULL, CAST('false' AS bit), GETDATE(), GETDATE()),
				('CICM1', 'Cotação Incompleta [Complemento] (mapeamento inativo)', 2, NULL, NULL, CAST('false' AS bit), GETDATE(), GETDATE()),
				('CIMM0', 'Cotação Incompleta [Marca] (mapeamento incompleto, preenchimento manual necessário)', 6, NULL, NULL, CAST('false' AS bit), GETDATE(), GETDATE()),
				('CIMM1', 'Cotação Incompleta [Marca] (mapeamento inativo)', 2, NULL, NULL, CAST('false' AS bit), GETDATE(), GETDATE()),
				('CITM0', 'Cotação Incompleta [Categoria] (mapeamento incompleto, preenchimento manual necessário)', 6, NULL, NULL, CAST('false' AS bit), GETDATE(), GETDATE()),
				('CITM1', 'Cotação Incompleta [Categoria] (mapeamento inativo)', 2, NULL, NULL, CAST('false' AS bit), GETDATE(), GETDATE()),
				('CISM0', 'Cotação Incompleta [Stock] (mapeamento incompleto, preenchimento manual necessário)', 6, NULL, NULL, CAST('false' AS bit), GETDATE(), GETDATE()),
				('CISM1', 'Cotação Incompleta [Stock] (mapeamento inativo)', 6, NULL, NULL, CAST('false' AS bit), GETDATE(), GETDATE()),
				('CIIM0', 'Cotação Incompleta [Imposto] (mapeamento incompleto, preenchimento manual necessário)', 6, NULL, NULL, CAST('false' AS bit), GETDATE(), GETDATE()),
				('CIIM1', 'Cotação Incompleta [Imposto] (mapeamento inativo)', 2, NULL, NULL, CAST('false' AS bit), GETDATE(), GETDATE()),
				('CIDM0', 'Cotação Incompleta [Estado] (mapeamento incompleto, preenchimento manual necessário)', 6, NULL, NULL, CAST('false' AS bit), GETDATE(), GETDATE()),
				('CIDM1', 'Cotação Incompleta [Estado] (mapeamento inativo)', 2, NULL, NULL, CAST('false' AS bit), GETDATE(), GETDATE()),
				('CIPM0', 'Cotação Incompleta [Produto] (mapeamento incompleto, preenchimento manual necessário)', 6, NULL, NULL, CAST('false' AS bit), GETDATE(), GETDATE()),
				('CIPM1', 'Cotação Incompleta [Produto] (mapeamento inativo)', 2, NULL, NULL, CAST('false' AS bit), GETDATE(), GETDATE()),
				('CIPM2', 'Cotação Incompleta [Produto] (fornecedor configurado para não criar automaticamente fichas de produtos)', 6, NULL, NULL, CAST('false' AS bit), GETDATE(), GETDATE()),
				('CIPM3', 'Cotação Incompleta [Produto] (fornecedor configurado para não mapear automaticamente produtos)', 6, NULL, NULL, CAST('false' AS bit), GETDATE(), GETDATE()),
				('CIPM4', 'Cotação Incompleta [Produto] (produto inativo)', 2, NULL, NULL, CAST('false' AS bit), GETDATE(), GETDATE()),
				('CIPM9', 'Cotação Incompleta [Produto] (ambiguidade detetada com outro partnumber de outra marca)', 8, NULL, NULL, CAST('false' AS bit), GETDATE(), GETDATE())

END



/* STOCKS */
IF NOT EXISTS(SELECT [Codigo] FROM [dbo].[Stocks])
BEGIN	
	INSERT INTO [dbo].[Stocks] ([Codigo], [Descricao], [DisponibilidadeNivel], [Notas], [Inativo], [Criacao], [Versao])
		 VALUES ('D-5','Indisponivel permanentemente', -5, NULL, CAST('false' AS bit), GETDATE(), GETDATE()),
				('D-4','Indisponivel sob encomenda (dias entrega: +40)', -4, NULL, CAST('false' AS bit), GETDATE(), GETDATE()),
				('D-3','Indisponivel sob encomenda (dias entrega: +25)', -3, NULL, CAST('false' AS bit), GETDATE(), GETDATE()),
				('D-2','Indisponivel sob encomenda (dias entrega: +10)', -2, NULL, CAST('false' AS bit), GETDATE(), GETDATE()),
				('D-1','Indisponivel sob encomenda (dias entrega: +6)', -1, NULL, CAST('false' AS bit), GETDATE(), GETDATE()),
				('D+0','Indisponivel momentaneamente (dias entrega: +2)', 0, NULL, CAST('false' AS bit), GETDATE(), GETDATE()),
				('D+1','Disponivel, stock reduzido', 1, NULL, CAST('false' AS bit), GETDATE(), GETDATE()),
				('D+2','Disponivel, stock limitado', 2, NULL, CAST('false' AS bit), GETDATE(), GETDATE()),
				('D+3','Disponivel, stock normal', 3, NULL, CAST('false' AS bit), GETDATE(), GETDATE()),
				('D+4','Disponivel, stock abundante', 4, NULL, CAST('false' AS bit), GETDATE(), GETDATE()),
				('D+5','Disponivel permanentemente', 5, NULL, CAST('false' AS bit), GETDATE(), GETDATE())
END




/* FORNECEDORES */
IF NOT EXISTS(SELECT [Codigo] FROM [dbo].[Fornecedores])
BEGIN	
	INSERT INTO [dbo].[Fornecedores]
			   ([Codigo], [Nome], [Morada], [CodigoPostal], [LocalidadePostal], [Contribuinte], 
				[Vendedor], [Telefone], [Telemovel], [SMS], [Email], [AcessoOnlineAtivo], [Username], [Password],
				[HorasValidadeSugestao], [ProdutosMatchingAutomatico], [ProdutosCriacaoAutomatica], [DisponibilizaInfoProdutoDetalhe],
				[DescricaoPontuacaoInicial], [CaracteristicasPontuacaoInicial], [LinkPontuacaoInicial], [ImagemPontuacaoInicial],
				[DescricaoSugereInativo], [CaracteristicasSugereInativo], [LinkSugereInativo], [ImagemSugereInativo],
				[AtualizacaoAutomaticaInativaSugestao], [ProdutosConfiancaPreco], [ProdutosConfiancaDisponibilidade],
				[Inativo], [Criacao], [Versao])
		 VALUES
			   ('00024', 'CPC - Companhia Portuguesa de Computadores...', 'Rua Monte dos Pipos, 649', '4460-059', 'Guifões', '999999990',
				'Susana', '222333444', '939949959', '969979989', 'susana@cpcdi.pt', CAST('false' AS bit), 'cpc001', 'cpcpass',
				24, CAST('true' AS bit), CAST('true' AS bit), CAST('true' AS bit),
				5, 5, 5, 5,
				CAST('false' AS bit), CAST('false' AS bit), CAST('false' AS bit), CAST('false' AS bit),
				CAST('false' AS bit), 90, 90,
				CAST('false' AS bit), GETDATE(), GETDATE())
END



/* ESTADOS */
IF NOT EXISTS(SELECT [Codigo] FROM [dbo].[Estados])
BEGIN	
	INSERT INTO [dbo].[Estados] ([Codigo], [Descricao], [Inativo], [Criacao], [Versao])
		VALUES ('NOVO', 'Produto novo (nunca usado)', CAST('false' AS bit), GETDATE(), GETDATE()),
			   ('PROMO', 'Produto em promoção', CAST('false' AS bit), GETDATE(), GETDATE()),
			   ('USADO', 'Produto usado', CAST('false' AS bit), GETDATE(), GETDATE()),
			   ('OPORT', 'Oportunidade', CAST('false' AS bit), GETDATE(), GETDATE()),
			   ('GOPOR', 'Grande oportunidade', CAST('false' AS bit), GETDATE(), GETDATE())
END
GO

GO
DECLARE @VarDecimalSupported AS BIT;

SELECT @VarDecimalSupported = 0;

IF ((ServerProperty(N'EngineEdition') = 3)
    AND (((@@microsoftversion / power(2, 24) = 9)
          AND (@@microsoftversion & 0xffff >= 3024))
         OR ((@@microsoftversion / power(2, 24) = 10)
             AND (@@microsoftversion & 0xffff >= 1600))))
    SELECT @VarDecimalSupported = 1;

IF (@VarDecimalSupported > 0)
    BEGIN
        EXECUTE sp_db_vardecimal_storage_format N'$(DatabaseName)', 'ON';
    END


GO
PRINT N'Update complete.';


GO
