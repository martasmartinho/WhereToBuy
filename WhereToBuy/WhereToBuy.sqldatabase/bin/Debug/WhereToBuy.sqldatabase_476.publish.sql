/*
Deployment script for WhereToBuy

This code was generated by a tool.
Changes to this file may cause incorrect behavior and will be lost if
the code is regenerated.
*/

GO
SET ANSI_NULLS, ANSI_PADDING, ANSI_WARNINGS, ARITHABORT, CONCAT_NULL_YIELDS_NULL, QUOTED_IDENTIFIER ON;

SET NUMERIC_ROUNDABORT OFF;


GO
:setvar DatabaseName "WhereToBuy"
:setvar DefaultFilePrefix "WhereToBuy"
:setvar DefaultDataPath "C:\Program Files\Microsoft SQL Server\MSSQL12.MSSQLSERVER\MSSQL\DATA\"
:setvar DefaultLogPath "C:\Program Files\Microsoft SQL Server\MSSQL12.MSSQLSERVER\MSSQL\DATA\"

GO
:on error exit
GO
/*
Detect SQLCMD mode and disable script execution if SQLCMD mode is not supported.
To re-enable the script after enabling SQLCMD mode, execute the following:
SET NOEXEC OFF; 
*/
:setvar __IsSqlCmdEnabled "True"
GO
IF N'$(__IsSqlCmdEnabled)' NOT LIKE N'True'
    BEGIN
        PRINT N'SQLCMD mode must be enabled to successfully execute this script.';
        SET NOEXEC ON;
    END


GO
USE [$(DatabaseName)];


GO
/*
 Pre-Deployment Script Template							
--------------------------------------------------------------------------------------
 This file contains SQL statements that will be executed before the build script.	
 Use SQLCMD syntax to include a file in the pre-deployment script.			
 Example:      :r .\myfile.sql								
 Use SQLCMD syntax to reference a variable in the pre-deployment script.		
 Example:      :setvar TableName MyTable							
               SELECT * FROM [$(TableName)]					
--------------------------------------------------------------------------------------
*/
-- cria a base de dados se não exstir ainda
IF NOT EXISTS(SELECT [Name] FROM [SYS].[DATABASES] WHERE [Name] = 'WhereToBuy')
BEGIN
	CREATE DATABASE WhereToBuy COLLATE LATIN1_GENERAL_CI_AS	-- ATENÇÃO QUE TEM TAMBÉM QUE SE ALTERAR A COLLATION NAS PROPRIEDADES DESTE PROJETO
END		
GO

GO
PRINT N'Altering [dbo].[GetCodigoExternoNormalizadoFunction]...';


GO
/*
	This function exist to normalize external coding system.
	The function receives an external code na normalize it to obey allways to the same internal rules of external codification.
	All external codes are normalized with this function when they are inserted on Quotations table.
	We want to prevent little externa changes on code strategy and so minimize not fake not matched situations. As an example, imagine some code that
	leaves lowercase and becomes uppercase. or the code is improved removing an extra space..
*/



ALTER FUNCTION [dbo].[GetCodigoExternoNormalizadoFunction]
(
	@codigo nvarchar(256)
)
RETURNS nvarchar(256)
AS
BEGIN

	-- change received separator chars by a space char. later will be changed again to underscore
	SET @codigo = REPLACE(@codigo, '-', ' ');
	SET @codigo = REPLACE(@codigo, '+', ' ');
	SET @codigo = REPLACE(@codigo, '*', ' ');
	SET @codigo = REPLACE(@codigo, '.', ' ');
	SET @codigo = REPLACE(@codigo, ':', ' ');
	SET @codigo = REPLACE(@codigo, ';', ' ');
	SET @codigo = REPLACE(@codigo, '#', ' ');
	SET @codigo = REPLACE(@codigo, '?', ' ');
	SET @codigo = REPLACE(@codigo, '!', ' ');
	SET @codigo = REPLACE(@codigo, 'º', ' ');
	SET @codigo = REPLACE(@codigo, 'ª', ' ');

	-- normalize external code
	SET @codigo = REPLACE(@codigo, '\', '/');
	SET @codigo = REPLACE(@codigo, '|', '/');
	
	-- remove accentuation
	SET @codigo = [dbo].[RemoveAccentuationFunction](@codigo);

	-- remove bad chars
	SET @codigo = [dbo].[CleanBadCharsFunction](@codigo);

	-- external codes will allways lowercase
	SET @codigo = LOWER(@codigo);

	-- change space chars to underscore (wrong multiple spaces were normalized behind)
	SET @codigo = REPLACE(@codigo, ' ', '_');

	-- devolver o codigo normalizado e limpo
	RETURN @codigo;
END
GO
PRINT N'Altering [dbo].[GetCotacaoCaracteristicasFunction]...';


GO
/*
	This function receives the original features and deal with it to clean and normalize it.
*/


ALTER FUNCTION [dbo].[GetCotacaoCaracteristicasFunction]
(
	@_Caracteristicas nvarchar(2048)
)
RETURNS nvarchar(2048)
AS
BEGIN

	-- variables
	DECLARE @caracteristicas nvarchar(2048);

	-- force lowercase
	SET @caracteristicas = LOWER(@_Caracteristicas);

	-- strip html tags
	SET @caracteristicas = [dbo].[StripHtmlTagsFunction](@caracteristicas);

	-- correct some chars
	SET @caracteristicas = REPLACE(@caracteristicas, '\', '/');
	SET @caracteristicas = REPLACE(@caracteristicas, '|', '/');

	-- force some linguistic rules (if extra bad spaces generated, they will be removed in CleanBadCharsFunction..
	SET @caracteristicas = REPLACE(@caracteristicas, '.', '. ');
	SET @caracteristicas = REPLACE(@caracteristicas, ',', ', ');
	SET @caracteristicas = REPLACE(@caracteristicas, ':', ': ');
	SET @caracteristicas = REPLACE(@caracteristicas, ';', '; ');
	SET @caracteristicas = REPLACE(@caracteristicas, '!', '! ');
	SET @caracteristicas = REPLACE(@caracteristicas, '?', '? ');

	-- clean bad chars
	SET @caracteristicas = [dbo].[CleanBadCharsFunction](@caracteristicas);

	-- send back the normalized features
	RETURN @caracteristicas;
END
GO
PRINT N'Altering [dbo].[GetCotacaoPartnumberFunction]...';


GO
/*
	This function, also used on step 1 of wheretobuy processing, it's used to clean received Partnumber of incorrect spaces 
	(imagine that instead of one space inside the partnumber, external user put two or more spaces wrongly), and prevents too
	from wrong accented chars.. etc.

	We want to best normalize the Partnumber to make it more cross comun between several suppliers.

	We decid too that all Partnumbers will be in uppercase.
*/



ALTER FUNCTION [dbo].[GetCotacaoPartnumberFunction]
(
	@_Partnumber nvarchar(25)
)
RETURNS nvarchar(25)
AS
BEGIN

	-- variables
	DECLARE @partnumber nvarchar(25);

	-- partnumber will be allways stored on uppercase
	SET @partnumber = UPPER(@_Partnumber);

	-- remove accentuation
	SET @partnumber = [dbo].[RemoveAccentuationFunction](@partnumber);

	-- remove bad chars
	SET @partnumber = [dbo].[CleanBadCharsFunction](@partnumber);

	-- correct chars
	SET @partnumber = REPLACE(@partnumber, '\', '/');
	SET @partnumber = REPLACE(@partnumber, ',', '.');
	SET @partnumber = REPLACE(@partnumber, 'º', '');
	SET @partnumber = REPLACE(@partnumber, 'ª', '');

	-- remove all sepaces inside partnumber
	SET @partnumber = REPLACE(@partnumber, ' ','');

	-- devolver o partnumber limpo e normalizado
	RETURN @partnumber;
END
GO
PRINT N'Altering [dbo].[GetCotacaoPartnumberSimplificadoFunction]...';


GO
/*
	This function receives the original Partnumber sended by the supplier and minimize it to only keep the essencials chars (alpha-numeric chars).

	The goal of this processing task, is to improve the chances of matching the partnumber between diferent suppliers (external systems)

	Be aware that, the received Partnumber have already been object of cleaning on Quotations Insert process. However, while in the cleaning
	process only undesirable chars were cleaned, now, with this function, the already cleaned partnumber is reduced to the minimum of representative chars
	to improve chances of matching between several external systems..
*/


ALTER FUNCTION [dbo].[GetCotacaoPartnumberSimplificadoFunction]
(
	@Partnumber nvarchar(25)
)
RETURNS nvarchar(25)
AS
BEGIN

	-- variables
	DECLARE @minimizedPartnumber nvarchar(25);

	-- minimize received Partnumber to the minimum of representative chars
	SET @minimizedPartnumber = [dbo].GetTextoOnlyAllowedCharsFunction(@Partnumber, '[A-Za-z0-9]');

	-- send back the minimized Partnumber version
	RETURN @minimizedPartnumber;
END
GO
PRINT N'Altering [dbo].[GetIndicePreocupacaoFunction]...';


GO
/*
	This function receives some text and, after analyse it, send back a value [0:9] representing the danger of terms..
	Zero (0) represents a no preocupation at all and nine (9) represents text with extremely danger terms.
*/


ALTER FUNCTION [dbo].[GetIndicePreocupacaoFunction]
(
	@texto nvarchar(MAX)
)
RETURNS tinyint
AS
BEGIN
	
	-- variables
	DECLARE @indice tinyint = 0;

	-- search for the greather preocupation index present in @texto
	SELECT TOP 1 @indice = Indice
	FROM [dbo].[TermosPreocupantes]
	WHERE LOWER(@texto) LIKE LOWER(Termo)
	ORDER BY Indice DESC;

	-- send back preocupation index
	return @indice;

END
GO
PRINT N'Altering [dbo].[GetProdutoCodigoFunction]...';


GO
/*
	This function calculates the Product Code for each Quotation.
	It receives the Brand Code, Addon Code and Partnumber and, after minimize the Partnumber, 
	generates a Product Code concatenating the Brand Code with the Partnumber and with Addon Code as shown below
		
		Product Code = Brand Code + Minimized Partnumber + '[' + Addon Code + ']'

	With this function, we can have access to the Product Code, even before the Product record has been created.

	This function reuses the GetCotacaoPartnumberSimplificado function too minimize the Partnumber, thereby improving
	the chances of matching product codes between different suppliers.
	
	This function receives the Addon Code. Addons are the way to differenciate the same product when a supplier offers
	with some specific add like delivery or extra warranty.
*/


ALTER FUNCTION [dbo].[GetProdutoCodigoFunction]
(
	@Partnumber nvarchar(25),
	@MarcaCodigo nvarchar(5),
	@ComplementoCodigo nvarchar(5)
)
RETURNS nvarchar(40)
AS
BEGIN

	-- variables
	DECLARE @complemento nvarchar(7) = ''; -- ComplementoCodigo + Parenteses = 5 + 2 = 7
	DECLARE @partnumberSimplificado nvarchar(25);

	-- simplify partnumber to be used as part of product code
	SET @partnumberSimplificado = [dbo].[GetCotacaoPartnumberSimplificadoFunction](@Partnumber)

	-- define addon part to be concatenated
	IF UPPER(@ComplementoCodigo) <> 'N/A' AND LEN(RTRIM(@ComplementoCodigo)) > 0
	BEGIN
		SET @complemento = '[' + RTRIM(UPPER(@ComplementoCodigo)) + ']';
	END

	-- return the product code to be used
	RETURN RTRIM(@MarcaCodigo) + @partnumberSimplificado + @complemento;
END
GO
PRINT N'Altering [dbo].[GetCotacaoPrecoFunction]...';


GO
/*
	This function pretends to calculate final price of quotation.
	Formula will permit to know later how the final price was calculated.
*/


ALTER FUNCTION [dbo].[GetCotacaoPrecoFunction]
(
	@_Preco decimal(14,4),
	@_OutrosCustos decimal(14,4),
	@_OutrosCustosDescricao nvarchar(128)
)
RETURNS @results TABLE
(
	__id integer PRIMARY KEY NOT NULL IDENTITY(1,1),
	PrecoCusto decimal(14,4) NOT NULL,
	Formula nvarchar(256) NOT NULL
)
AS
BEGIN

	-- variables
	DECLARE @precoCusto decimal(14,4), @formula nvarchar(256);


	-- final cost price is calculated as the sum of Preco with OutrosCustos
	SET @precoCusto = @_Preco + @_OutrosCustos;


	-- now, if @_OutrosCustosDescricao has text inside it, that text it is the justification of existing adicional costs (@_OutrosCustos)
	-- however, if @_OutrosCustos = 0, that description justifies the @_Preco (maybe more expensive because..)
	IF COALESCE(@_OutrosCustosDescricao, '(vazio)') = '(vazio)'
	BEGIN
		SET @formula = 'PrecoCusto = Preco';
	END
	ELSE
	BEGIN
		
		IF @_OutrosCustos <> 0
		BEGIN
			
			-- formula must show that the PrecoCusto is the sum of Preço and OutrosCustos
			SET @formula = 'PrecoCusto = Preco + @OutrosCustos';
			SET @formula = @formula + ' = ';
			SET @formula = @formula + CONVERT(varchar, @_Preco);
			SET @formula = @formula + ' + ';
			SET @formula = @formula + ' (';
			SET @formula = @formula + LOWER(RTRIM(@_OutrosCustosDescricao));
			SET @formula = @formula + ': ';
			SET @formula = @formula + CONVERT(varchar, @_OutrosCustos);;
			SET @formula = @formula + ') ';
			SET @formula = @formula + ' = ';
			SET @formula = @formula + CONVERT(varchar, @precoCusto);

		END
		ELSE
		BEGIN

			-- formula must show that the price itself include other associated costs
			SET @formula = 'PrecoCusto = Preco + @OutrosCustos';
			SET @formula = @formula + ' <=> ';
			SET @formula = @formula + CONVERT(varchar, @precoCusto);
			SET @formula = @formula + ' = ';
			SET @formula = @formula + ' Preco + (';
			SET @formula = @formula + LOWER(RTRIM(@_OutrosCustosDescricao));
			SET @formula = @formula + ': ';
			SET @formula = @formula + CONVERT(varchar, @_OutrosCustos);
			SET @formula = @formula + ')';

		END
	END


	-- prepare data to be send back
	INSERT INTO @results
	SELECT @precoCusto, @formula;


	-- terminate
	RETURN;
END
GO
PRINT N'Altering [dbo].[GetProdutoMedidasDisponibilidadeFunction]...';


GO
/*
	This function generates product statistics:

		> U1VD - last availability variation (x = 1 not changed, x > 1 means availability level was rise and x < 1 means the availability level was dropped
		> U2VD - penultimate..
		> U3VD - antepenultimate..

		> EED (Estatistica de Estabilidade da Disponibilidade) means Statistic of Stability of Availability.
	          Represents a estimation in days of the stability of actual Stock Availability level.
			  How much days will the current level of availability stay actual.

		> ICD (Indice de Confiança na Disponibilidade) means Availability Trust Index.
		      Thats a value between [0:1] that represents the current level of availability trust.

			  ICD = 0.5CE + 0.2CT + 0.3CF

		> CE  (Componente Estabilidade) Estability Component
		      Is the availability level trust in prespective to EED. 
		
		> CT  (Componente Tendencia) Trend Component
			  Is the availability trust in prespective of last evolution of stock availability.

		> CF  (Confiança Fornecedor) Trust on the Supplier
			  Is the trust that exists on the supplier (supplier table record)

*/

ALTER FUNCTION [dbo].GetProdutoMedidasDisponibilidadeFunction
(
	@U3Disponivel smallint,
	@U3Data smalldatetime,
	@U2Disponivel smallint,
	@U2Data smalldatetime,
	@U1Disponivel smallint,
	@U1Data smalldatetime,
	@UDisponivel smallint,
	@UData smalldatetime,
	@ConfiancaFornecedor float
)
RETURNS @results TABLE
(
	__idMedidaDisponibilidade integer PRIMARY KEY NOT NULL IDENTITY(1,1),
	U3VD float NULL,
	U2VD float NULL,
	U1VD float NULL,
	EED float NOT NULL,
	ICD float NOT NULL,
	EEDFormula nvarchar(256),
	ICDCEFormula nvarchar(256),
	ICDCTFormula nvarchar(256),
	ICDCFFormula nvarchar(256),
	ICDFormula nvarchar(256)
)
AS
BEGIN

	-- variables
	DECLARE @eedFormula nvarchar(256), @icdFormula nvarchar(256), @ceFormula nvarchar(256), @ctFormula nvarchar(256), @cfFormula nvarchar(256),
	        @u3vd float, @u2vd float, @u1vd float, @eed float, @icd float, @ce float, @ct float, @cf float;


	-- initialize variables
	SET @eedFormula = '';
	SET @icdFormula = '';
	SET @ceFormula = '';
	SET @ctFormula = '';
	SET @cfFormula = '';
	SET @u3vd = NULL;
	SET @u2vd = NULL;
	SET @u1vd = NULL;
	SET @eed = 1;	-- minimum stability: 1 day
	SET @icd = 0;
	SET @ce = 0;
	SET @ct = 0;
	SET @cf = 0



	-- trend calculation
	IF @U3Disponivel IS NOT NULL	-- if this level it is not null, then we have the guarantee that @U2Disponivel it isn't too.
	BEGIN
		SET @u3vd = CAST(@U2Disponivel as float) - @U3Disponivel;
	END

	IF @U2Disponivel IS NOT NULL	-- if this level it is not null, then we have the guarantee that @U1Disponivel it isn't too.
	BEGIN
		SET @u2vd = CAST(@U1Disponivel as float) - @U2Disponivel;
	END

	IF @U1Disponivel IS NOT NULL	-- if this level it is not null, then we have the guarantee that @UDisponivel it isn't too.
	BEGIN
		SET @u1vd = CAST(@UDisponivel as float) - @U1Disponivel;
	END



	-- EED and EEDFormula calculation
	SELECT @eed =
				CASE WHEN @U3Data IS NOT NULL THEN 
													0.1 * DATEDIFF(DAY, @U3Data, @U2Data) +
													0.2 * DATEDIFF(DAY, @U2Data, @U1Data) +
													0.7 * DATEDIFF(DAY, @U1Data, @UData)

					 WHEN @U2Data IS NOT NULL THEN	
													0.2 * DATEDIFF(DAY, @U2Data, @U1Data) +
													0.7 * DATEDIFF(DAY, @U1Data, @UData)

					 WHEN @U1Data IS NOT NULL THEN	
													0.7 * DATEDIFF(DAY, @U1Data, @UData)

					 ELSE 1
				END,

			@eedFormula = 
				CASE WHEN @U3Data IS NOT NULL THEN 
													'EED = 0.1(U3Data - U2Data) + ' +
														  '0.2(U2Data - U1Data) + ' +
													      '0.7(U1Data - UData) <=> ' +
													'EED = 0.1(' + CONVERT(varchar, @U3Data, 103) + ' - ' + CONVERT(varchar, @U2Data, 103)  + ') + ' +
													      '0.2(' + CONVERT(varchar, @U2Data, 103) + ' - ' + CONVERT(varchar, @U1Data, 103)  + ') + ' +
														  '0.7(' + CONVERT(varchar, @U1Data, 103) + ' - ' + CONVERT(varchar, @UData, 103)  + ') <=> ' +
													'EED = ' + CAST(@eed as varchar)

					 WHEN @U2Data IS NOT NULL THEN	
													'EED = 0.2(U2Data - U1Data) + ' +
													      '0.7(U1Data - UData) <=> ' +
													'EED = 0.2(' + CONVERT(varchar, @U2Data, 103) + ' - ' + CONVERT(varchar, @U1Data, 103)  + ') + ' +
														  '0.7(' + CONVERT(varchar, @U1Data, 103) + ' - ' + CONVERT(varchar, @UData, 103)  + ') <=> ' +
													'EED = ' + CAST(@eed as varchar)

					 WHEN @U1Data IS NOT NULL THEN	
													'EED = 0.7(U1Data - UData) <=> ' +
													'EED = 0.7(' + CONVERT(varchar, @U1Data, 103) + ' - ' + CONVERT(varchar, @UData, 103)  + ') <=> ' +
													'EED = ' + CAST(@eed as varchar)

					 ELSE 'EED = 1 (default)'
			    END



	
	-- CE (ICD component calculation)
	IF @UData IS NOT NULL
	BEGIN
		
		-- CE calculation
		SELECT @ce = (1 - (DATEDIFF(DAY, @UData, GETDATE()) / @eed));

		-- CE formula calculation
		SELECT @ceFormula = 'CE = (1 - ((Hoje - UData) / EEP)) <=> ' +
							'CE = (1 - ((' + CONVERT(varchar, GETDATE(), 103) + ' - ' + CONVERT(varchar, @UData, 103) + ') / ' + CAST(@eed as varchar)  + ')) <=> ' +
							'CE = ' + CAST(@ce as varchar);
	END
	ELSE
	BEGIN
		-- default
		SELECT @ce = 0, 
			   @ceFormula = 'CE = 0 (default)';
	END




	-- CT (ICD component calculation)
	IF @U1Disponivel IS NOT NULL -- we have sure that @UDisponivel is not null too
	BEGIN

		-- CT calculation
		SELECT @ct = 
				   CASE WHEN @UDisponivel < @U1Disponivel THEN (1 - ABS(((CAST(@UDisponivel as float) - @U1Disponivel) / 11) * 5))
						ELSE (1 - ABS((CAST(@UDisponivel as float) - @U1Disponivel) / 11))
				   END;

		-- CT formula calculation
		SELECT @ctFormula = 
				   CASE WHEN @UDisponivel < @U1Disponivel THEN 
														'CT = (1 - |((UDisponivel - U1Disponivel) / 11) * 5|) <=> ' + 
														'CT = (1 - |(((' + CONVERT(varchar, @UDisponivel) + ') - (' + CONVERT(varchar, @U1Disponivel) + ')) / 11) * 5|) <=> ' +
														'CT = ' + CAST(@ct as varchar)
						ELSE 
							  'CT = (1 - |(UDisponivel - U1Disponivel) / 11|) <=> ' + 
							  'CT = (1 - |((' + CONVERT(varchar, @UDisponivel) + ') - (' + CONVERT(varchar, @U1Disponivel) + ')) / 11|) <=> ' +
							  'CT = ' + CAST(@ct as varchar)
				   END;
	END
	ELSE
	BEGIN
		-- default
		SELECT @ct = 0, 
			   @ctFormula = 'CT = 0 (default)';
	END




	-- CF (ICP component calculation)
	IF @ConfiancaFornecedor IS NOT NULL
	BEGIN
		
		-- CF calculation
		SELECT @cf = @ConfiancaFornecedor / 100;

		-- CF formula calculation
		SELECT @cfFormula = 'CF = (ConfiancaFornecedor / 100) <=> ' +
							'CF = (' + CAST(@ConfiancaFornecedor as varchar) + ' / 100) <=> ' +
							'CF = ' + CAST(@cf as varchar);

	END
	ELSE
	BEGIN
		-- default
		SELECT @cf = 0, 
			   @cfFormula = 'CF = 0 (default)';
	END




	-- ICD calculation
	SELECT @icd = (0.5 * @ce) + (0.2 * @ct) + (0.3 * @cf);

	-- ICD Formula calculation
	SELECT @icdFormula = 'ICD = 0.5CE + 0.2CT + 0.3CF <=> ' + 
						 'ICD = (0.5 * ' + CAST(@ce as varchar) + ') + (0.2 * ' + CAST(@ct as varchar) + ') + (0.3 * ' + CAST(@cf as varchar) + ') <=> ' +
						 'ICD = ' + CAST(@icd as varchar);

	-- ICD must be inside [0:1] interval
	SELECT @icdFormula =
					CASE WHEN @icd < 0 THEN @icdFormula + ', !E [0:1] => ICP = 0'
					     WHEN @icd > 1 THEN @icdFormula + ', !E [0:1] => ICP = 1'
						 ELSE @icdFormula
					END,
			@icd =
					CASE WHEN @icd < 0 THEN 0
					     WHEN @icd > 1 THEN 1
						 ELSE @icd
					END;
		  


	-- send back results
	INSERT INTO @results
	SELECT @u3vd, @u2vd, @u1vd, @eed, @icd, @eedFormula, @ceFormula, @ctFormula, @cfFormula, @icdFormula;


	-- the end
	RETURN;
END
GO
PRINT N'Altering [dbo].[GetProdutoMedidasPrecoFunction]...';


GO
/*
	This function generates product statistics:

		> U1VP - last price variation (x = 1 not changed, x > 1 means price was rise and x < 1 means the price was dropped
		> U2VP - penultimate..
		> U3VP - antepenultimate..

		> EEP (Estatistica de Estabilidade de Preço) means Price Stability Statistic.
	          Represents a estimation in days of the stability of actual price.

		> ICP (Indice de Confiança no Preço) means Price Trust Index.
		      Thats a value between [0:1] that represents the current price trust.

			  ICP = 0.5CE + 0.2CT + 0.3CF

		> CE  (Componente Estabilidade) Estability Component
		      Is the price trust in prespective to EEP. 
		
		> CT  (Componente Tendencia) Trend Component
			  Is the price trust in prespective of last evolution of the price.

		> CF  (Confiança Fornecedor) Trust on the Supplier
			  Is the trust that exists on the supplier (supplier table record)

*/

ALTER FUNCTION [dbo].GetProdutoMedidasPrecoFunction
(
	@U3Preco decimal(14,4),
	@U3Data smalldatetime,
	@U2Preco decimal(14,4),
	@U2Data smalldatetime,
	@U1Preco decimal(14,4),
	@U1Data smalldatetime,
	@UPreco decimal(14,4),
	@UData smalldatetime,
	@ConfiancaFornecedor float
)
RETURNS @results TABLE
(
	__idMedidaPreco integer PRIMARY KEY NOT NULL IDENTITY(1,1),
	U3VP decimal(14,4) NULL,
	U2VP decimal(14,4) NULL,
	U1VP decimal(14,4) NULL,
	EEP float NOT NULL,
	ICP float NOT NULL,
	EEPFormula nvarchar(256),
	ICPCEFormula nvarchar(256),
	ICPCTFormula nvarchar(256),
	ICPCFFormula nvarchar(256),
	ICPFormula nvarchar(256)
)
AS
BEGIN

	-- variables
	DECLARE @eepFormula NVARCHAR(256), @icpFormula nvarchar(256), @ceFormula nvarchar(256), @ctFormula nvarchar(256), @cfFormula nvarchar(256),
	        @u3vp float, @u2vp float, @u1vp float, @eep float, @icp float, @ce float, @ct float, @cf float;


	-- initialize variables
	SET @eepFormula = '';
	SET @icpFormula = '';
	SET @ceFormula = '';
	SET @ctFormula = '';
	SET @cfFormula = '';
	SET @u3vp = NULL;
	SET @u2vp = NULL;
	SET @u1vp = NULL;
	SET @eep = 1;	-- minimum stability: 1 day
	SET @icp = 0;
	SET @ce = 0;
	SET @ct = 0;
	SET @cf = 0



	-- trend calculation
	IF @U3Preco IS NOT NULL	-- if this price it is not null, then we have the guarantee that @U2Preco it isn't too.
	BEGIN
		SET @u3vp = @U2Preco / @U3Preco;
	END

	IF @U2Preco IS NOT NULL -- if this price it is not null, then we have the guarantee that @U1Preco it isn't too.
	BEGIN
		SET @u2vp = @U1Preco / @U2Preco;
	END

	IF @U1Preco IS NOT NULL -- if this price it is not null, then we have the guarantee that @UPreco it isn't too.
	BEGIN
		SET @u1vp = @UPreco / @U1Preco;
	END



	-- EEP and EEPFormula calculation
	SELECT @eep =
				CASE WHEN @U3Data IS NOT NULL THEN 
													0.1 * DATEDIFF(DAY, @U3Data, @U2Data) +
													0.4 * DATEDIFF(DAY, @U2Data, @U1Data) +
													0.5 * DATEDIFF(DAY, @U1Data, @UData)

					 WHEN @U2Data IS NOT NULL THEN	
													0.4 * DATEDIFF(DAY, @U2Data, @U1Data) +
													0.5 * DATEDIFF(DAY, @U1Data, @UData)

					 WHEN @U1Data IS NOT NULL THEN	
													0.5 * DATEDIFF(DAY, @U1Data, @UData)

					 ELSE 1
				END,

			@eepFormula = 
				CASE WHEN @U3Data IS NOT NULL THEN 
													'EEP = 0.1(U3Data - U2Data) + ' +
														  '0.4(U2Data - U1Data) + ' +
													      '0.5(U1Data - UData) <=> ' +
													'EEP = 0.1(' + CONVERT(varchar, @U3Data, 103) + ' - ' + CONVERT(varchar, @U2Data, 103)  + ') + ' +
													      '0.4(' + CONVERT(varchar, @U2Data, 103) + ' - ' + CONVERT(varchar, @U1Data, 103)  + ') + ' +
														  '0.5(' + CONVERT(varchar, @U1Data, 103) + ' - ' + CONVERT(varchar, @UData, 103)  + ') <=> ' +
													'EEP = ' + CAST(@eep as varchar)

					 WHEN @U2Data IS NOT NULL THEN	
													'EEP = 0.4(U2Data - U1Data) + ' +
													      '0.5(U1Data - UData) <=> ' +
													'EEP = 0.4(' + CONVERT(varchar, @U2Data, 103) + ' - ' + CONVERT(varchar, @U1Data, 103)  + ') + ' +
														  '0.5(' + CONVERT(varchar, @U1Data, 103) + ' - ' + CONVERT(varchar, @UData, 103)  + ') <=> ' +
													'EEP = ' + CAST(@eep as varchar)

					 WHEN @U1Data IS NOT NULL THEN	
													'EEP = 0.5(U1Data - UData) <=> ' +
													'EEP = 0.5(' + CONVERT(varchar, @U1Data, 103) + ' - ' + CONVERT(varchar, @UData, 103)  + ') <=> ' +
													'EEP = ' + CAST(@eep as varchar)

					 ELSE 'EEP = 1 (default)'
			    END



	
	-- CE (ICP component calculation)
	IF @UData IS NOT NULL
	BEGIN
		
		-- CE calculation
		SELECT @ce = (1 - (DATEDIFF(DAY, @UData, GETDATE()) / @eep));

		-- CE formula calculation
		SELECT @ceFormula = 'CE = (1 - ((Hoje - UData) / EEP)) <=> ' +
							'CE = (1 - ((' + CONVERT(varchar, GETDATE(), 103) + ' - ' + CONVERT(varchar, @UData, 103) + ') / ' + CAST(@eep as varchar)  + ')) <=> ' +
							'CE = ' + CAST(@ce as varchar);
	END
	ELSE
	BEGIN
		-- default
		SELECT @ce = 0, 
			   @ceFormula = 'CE = 0 (default)';
	END




	-- CT (ICP component calculation)
	IF @U1Preco IS NOT NULL -- we have sure that @UPreco is not null too
	BEGIN

		-- CT calculation
		SELECT @ct = 
				   CASE WHEN @UPreco > @U1Preco THEN (@U1Preco / @UPreco) - (50 * (1 - (@U1Preco / @UPreco)))
						ELSE (@UPreco / @U1Preco)
				   END;

		-- CT formula calculation
		SELECT @ctFormula = 
				   CASE WHEN @UPreco > @U1Preco THEN 
														'CT = (U1Preco / UPreco) - ' + 
																	'(50 * (1 - (@U1Preco / @UPreco))) <=> ' +
														'CT = (' + CONVERT(varchar, @U1Preco) + ' / ' + CONVERT(varchar, @UPreco) + ') - ' +
																	'(50 * (1 - (' + CONVERT(varchar, @U1Preco) + ' / ' + CONVERT(varchar, @UPreco) + '))) <=> ' +
														'CT = ' + CAST(@ct as varchar)
						ELSE 
							  'CT = (UPreco / U1Preco) <=> ' +
							  'CT = (' + CONVERT(varchar, @UPreco) + ' / ' + CONVERT(varchar, @U1Preco) + ') <=> ' +
							  'CT = ' + CAST(@ct as varchar)
				   END;
	END
	ELSE
	BEGIN
		-- default
		SELECT @ct = 0, 
			   @ctFormula = 'CT = 0 (default)';
	END




	-- CF (ICP component calculation)
	IF @ConfiancaFornecedor IS NOT NULL
	BEGIN
		
		-- CF calculation
		SELECT @cf = @ConfiancaFornecedor / 100;

		-- CF formula calculation
		SELECT @cfFormula = 'CF = (ConfiancaFornecedor / 100) <=> ' +
							'CF = (' + CAST(@ConfiancaFornecedor as varchar) + ' / 100) <=> ' +
							'CF = ' + CAST(@cf as varchar);

	END
	ELSE
	BEGIN
		-- default
		SELECT @cf = 0, 
			   @cfFormula = 'CF = 0 (default)';
	END




	-- ICP calculation
	SELECT @icp = (0.5 * @ce) + (0.2 * @ct) + (0.3 * @cf);

	-- ICP Formula calculation
	SELECT @icpFormula = 'ICP = 0.5CE + 0.2CT + 0.3CF <=> ' + 
						 'ICP = (0.5 * ' + CAST(@ce as varchar) + ') + (0.2 * ' + CAST(@ct as varchar) + ') + (0.3 * ' + CAST(@cf as varchar) + ') <=> ' +
						 'ICP = ' + CAST(@icp as varchar);

	-- ICP must be inside [0:1] interval
	SELECT @icpFormula =
					CASE WHEN @icp < 0 THEN @icpFormula + ', !E [0:1] => ICP = 0'
					     WHEN @icp > 1 THEN @icpFormula + ', !E [0:1] => ICP = 1'
						 ELSE @icpFormula
					END,
			@icp =
					CASE WHEN @icp < 0 THEN 0
					     WHEN @icp > 1 THEN 1
						 ELSE @icp
					END;
		  



	-- send back results
	INSERT INTO @results
	SELECT @u3vp, @u2vp, @u1vp, @eep, @icp, @eepFormula, @ceFormula, @ctFormula, @cfFormula, @icpFormula;


	-- the end
	RETURN;
END
GO
PRINT N'Altering [dbo].[CotacoesAtuaisRecalcularView]...';


GO
/*
	On this step, we must be sure that all fields in Actual Quotations (CotacoesAtuais) are correctly fulfilled regarding to actual
	ProdutosMatching and CotacoesRegras rules..

	This view reuses functions implemented to step 2 - normalization.
*/

ALTER VIEW [dbo].[CotacoesAtuaisRecalcularView]
	AS 

	SELECT -- original values from CotacoesAtuaisView
		   c.*,

		   -- calculated values of price
		   cp.PrecoCusto AS [PrecoCustoCalculado],
		   cp.Formula AS [FormulaPrecoCustoCalculado],

		   -- calculated values of expiration date
		   cv.Validade AS [ValidadeCalculada],
		   cv.Formula AS [FormulaValidadeCalculada],

		   -- calculated values of surrogate stock code
		   cs.StockCodigo AS [StockCodigoSubstitutoCalculado],
		   cs.Justificacao AS [JustificacaoStockCodigoSubstitutoCalculado],

		   -- get text fields uniformed
		   [dbo].[GetCotacaoDescricaoFunction](c._Descricao, m.Descricao, c.Partnumber, p.TermoAcrescentar, p.TermosRemover) AS [DescricaoUniformizada],
		   [dbo].[GetCotacaoCaracteristicasFunction](c._Caracteristicas) AS [CaracteristicasUniformizadas],
		   [dbo].[GetCotacaoLinkFunction](c._Link) AS [LinkUniformizado],
		   [dbo].[GetCotacaoImagemFunction](c._Imagem) AS [ImagemUniformizada]

	-- link tables and user functions as needed
	FROM [dbo].[CotacoesAtuaisView] c
		 INNER JOIN [dbo].[CotacoesRegras] cr
			   ON c.FornecedorCodigo = cr.FornecedorCodigo
				  AND c.MarcaCodigo = cr.MarcaCodigo
				  AND c.CategoriaCodigo = cr.CategoriaCodigo
				  AND c.StockCodigo = cr.StockCodigo
		 INNER JOIN [dbo].[ProdutosMatching] pm
			   ON c.FornecedorCodigo = pm.FornecedorCodigo
				  AND c.ComplementoCodigo = pm.ComplementoCodigo
				  AND c._ProdutoCodigo = pm.Codigo
		 INNER JOIN [dbo].[Marcas] m
			   ON c.MarcaCodigo = m.Codigo
		 INNER JOIN [dbo].[Complementos] p
			   ON c.ComplementoCodigo = p.Codigo
		 CROSS APPLY [dbo].[GetCotacaoPrecoFunction](c._Preco, c._OutrosCustos, c._OutrosCustosDescricao) cp
		 CROSS APPLY [dbo].[GetCotacaoValidadeFunction](c.Data, c._Validade, c._ValidadeDescricao, cr.HorasValidade, pm.HorasValidadeCotacao) cv
		 CROSS APPLY [dbo].[GetCotacaoStockSubstitutoFunction](c.StockCodigo, cr.StockCodigoSubstituto, pm.StockCodigoSubstituto) cs

	-- we want to filter only quotations that have data to be updated
	WHERE c.PrecoCusto <> cp.PrecoCusto
		  OR c.PrecoCustoFormula <> cp.Formula
		  OR c.Validade <> cv.Validade
		  OR c.ValidadeFormula <> cv.Formula
		  OR c.Descricao <> [dbo].[GetCotacaoDescricaoFunction](c._Descricao, m.Descricao, c.Partnumber, p.TermoAcrescentar, p.TermosRemover)
		  OR c.Caracteristicas <> [dbo].[GetCotacaoCaracteristicasFunction](c._Caracteristicas)
		  OR COALESCE(c.StockCodigoSubstituto, '') <> cs.StockCodigo				-- comparation of null with something else is always false
		  OR COALESCE(c.StockCodigoSubstitutoJustificacao, '') <> cs.Justificacao	-- " " "
GO
PRINT N'Refreshing [dbo].[ProdutosAtuaisView]...';


GO
EXECUTE sp_refreshsqlmodule N'[dbo].[ProdutosAtuaisView]';


GO
PRINT N'Altering [dbo].[CotacoesAtuaisAmplitudeIrregularView]...';


GO
/*
	Quotations of this view will be configured as disabled because it's offset price..
*/

ALTER VIEW [dbo].[CotacoesAtuaisAmplitudeIrregularView]
	AS 

	SELECT c.*,
		   ca.AmplitudePercentual, ca.AmplitudeFormulaDetecaoDesfasamento, ca.PrecoDesfasado, ca.PrecoDesfasadoFormulaDecisao

	FROM [dbo].[CotacoesAtuaisAmplitudeExcedidaView] ca
		 INNER JOIN [dbo].[CotacoesAtuaisView] c
			   ON ca.ProdutoCodigo = c.ProdutoCodigo
				  AND ca.PrecoDesfasado = c.PrecoCusto
GO
PRINT N'Altering [dbo].[CotacoesAtuaisPrecosForaIntervaloView]...';


GO
/*
	This view simplifies the process of determining what quotations have price out of the category interval..
*/

ALTER VIEW [dbo].[CotacoesAtuaisPrecosForaIntervaloView]
	AS 

	SELECT c.*,
		   t.PrecoMinimoPermitido, t.PrecoMaximoPermitido

	FROM [dbo].[CotacoesAtuaisView] c
		 INNER JOIN [dbo].[Categorias] t
			   ON c.CategoriaCodigo = t.Codigo
		 INNER JOIN [dbo].[ProdutosMatching] m
			   ON c.FornecedorCodigo = m.FornecedorCodigo
				  AND c.ComplementoCodigo = m.ComplementoCodigo
				  AND c._ProdutoCodigo = m.Codigo

	-- filter all Actual Quotations that the price is out of the interval defined on category,
	-- considering only ProductMatching rules that are configured with DispensaPrevencaoPrecosDesfazados = 'false'
	WHERE (c.PrecoCusto < t.PrecoMinimoPermitido OR c.PrecoCusto > t.PrecoMaximoPermitido)
		  AND m.DispensaPrevencaoPrecosDesfasados = CAST('false' as bit)
GO
PRINT N'Altering [dbo].[CotacoesIncompletasView]...';


GO
/*
	Esta View facilita a vista sobre as cotações incompletas e, lógicamente, não integradas (já que uma cotação só pode ser integrada depois de estar completa)
	(Uma cotação incompleta é aquela que falta informação, por exemplo, mapeamentos..)
	(Uma cotação incompleta é uma cotação que ainda falta sofrer processamento para poder ser integrada!)
*/

ALTER VIEW [dbo].[CotacoesIncompletasView]
	AS 
	SELECT *
	FROM [dbo].[CotacoesAtivasView]
	WHERE [Completo] = CAST('false' as bit)
GO
PRINT N'Refreshing [dbo].[CotacoesIncompletasFinalizacaoView]...';


GO
EXECUTE sp_refreshsqlmodule N'[dbo].[CotacoesIncompletasFinalizacaoView]';


GO
PRINT N'Refreshing [dbo].[CotacoesIncompletasMapeamentoProdutoView]...';


GO
EXECUTE sp_refreshsqlmodule N'[dbo].[CotacoesIncompletasMapeamentoProdutoView]';


GO
PRINT N'Refreshing [dbo].[CotacoesMatrizPreenchimentoMapToView]...';


GO
EXECUTE sp_refreshsqlmodule N'[dbo].[CotacoesMatrizPreenchimentoMapToView]';


GO
PRINT N'Altering [dbo].[PartnumbersAmbiguosView]...';


GO
/*
	This view compares the deducted Product Codes from Incomplete Quotations and Product Codes already created. Then, when
	they have a match and the entites (quotation vs product) have different brands, it assumes a Partnumber conflit.

	The view shows ambiguous partnumbers, in other words, all partnumbers that on quotations side belongs to a brand 1 and in product table
	belongs to brand 2..

	If that prevention was a fake negative, user must create the product manually and map it manually too.
*/


ALTER VIEW [dbo].[PartnumbersAmbiguosView]
	AS 
	
	SELECT DISTINCT c.Partnumber

	-- link Products to Quotations via Simplified Partnumber on both sides
	FROM [dbo].[Produtos] p
		 INNER JOIN [dbo].[CotacoesIncompletasMapeamentoProdutoView] c
				ON [dbo].[GetCotacaoPartnumberSimplificadoFunction](p.Partnumber) = [dbo].GetCotacaoPartnumberSimplificadoFunction(c.Partnumber)

	-- filter only not existing products and the ones that brand does not fit on the two sides (quotations - products)
	WHERE c.Referencia NOT IN
		(
			SELECT Codigo FROM [dbo].[Produtos]
		)
		AND p.MarcaCodigo <> c.MarcaCodigo
GO
PRINT N'Refreshing [dbo].[ProdutosCodigosInexistentesView]...';


GO
EXECUTE sp_refreshsqlmodule N'[dbo].[ProdutosCodigosInexistentesView]';


GO
PRINT N'Refreshing [dbo].[CotacoesIncompletasNormalizacaoView]...';


GO
EXECUTE sp_refreshsqlmodule N'[dbo].[CotacoesIncompletasNormalizacaoView]';


GO
PRINT N'Refreshing [dbo].[CotacoesMatrizCriacaoProdutosView]...';


GO
EXECUTE sp_refreshsqlmodule N'[dbo].[CotacoesMatrizCriacaoProdutosView]';


GO
PRINT N'Altering [dbo].[BrandInsert]...';


GO
ALTER PROCEDURE [dbo].[BrandInsert]
	@Codigo nvarchar(5),
	@Descricao nvarchar(50),
	@Inativo bit
AS
	
	DECLARE @Criacao smalldatetime, @Versao datetime, @NumeroLinhasAfetadas int, @Erro nvarchar(255)

	SET @Criacao = GETDATE()
	SET @Versao = GETDATE()


	-- INSERÇÃO DO REGISTO
	BEGIN TRY
		 
		-- INICIA CONTAGEM DE @@ROWCOUNT (para quando usado o ExecuteNonQuery())
		SET NOCOUNT OFF

		-- INSERIR REGISTO
		INSERT INTO [dbo].[Marcas] ([Codigo], [Descricao], [Inativo], [Criacao], [Versao]) 
					VALUES (@Codigo, @Descricao, @Inativo, @Criacao, @Versao);
		
		SET @NumeroLinhasAfetadas = @@ROWCOUNT -- GUARDAR O NUMERO DE LINHAS AFETADAS

		-- ACABA CONTAGEM DE @@ROWCOUNT
		SET NOCOUNT ON

		-- RETORNAR O NUMERO DE LINHAS AFETADAS
		-- Quando usado o ExecuteNonQuery é o @@ROWCOUNT que é lido (SET NOCOUNT OFF/ON),  e não esta variável
		RETURN @NumeroLinhasAfetadas

	END TRY


	-- SE EXISTIRAM ERROS, DESFAZER TRANSACÇÃO
	BEGIN CATCH

		-- DISPARAR UM ERRO
		SET @Erro = '[WhereToBuy-I10] ' + ERROR_MESSAGE();
		RAISERROR (@Erro, 15, 1)
		RETURN 0

	END CATCH
GO
PRINT N'Altering [dbo].[CatalogInsert]...';


GO
ALTER PROCEDURE [dbo].[CatalogInsert]
	@Codigo nvarchar(5),
	@Descricao nvarchar(50),
	@Notas nvarchar(256),
	@Inativo bit
AS
	
	DECLARE @Criacao smalldatetime, @Versao datetime, @NumeroLinhasAfetadas int, @Erro nvarchar(255)

	SET @Criacao = GETDATE()
	SET @Versao = GETDATE()


	-- INSERÇÃO DO REGISTO
	BEGIN TRY
		 
		-- INICIA CONTAGEM DE @@ROWCOUNT (para quando usado o ExecuteNonQuery())
		SET NOCOUNT OFF

		-- INSERIR REGISTO
		INSERT INTO [dbo].[Catalogos] ([Codigo], [Descricao], [Notas], [Inativo], [Criacao], [Versao]) 
					VALUES (@Codigo, @Descricao, @Notas, @Inativo, @Criacao, @Versao);
		
		SET @NumeroLinhasAfetadas = @@ROWCOUNT -- GUARDAR O NUMERO DE LINHAS AFETADAS

		-- ACABA CONTAGEM DE @@ROWCOUNT
		SET NOCOUNT ON

		-- RETORNAR O NUMERO DE LINHAS AFETADAS
		-- Quando usado o ExecuteNonQuery é o @@ROWCOUNT que é lido (SET NOCOUNT OFF/ON),  e não esta variável
		RETURN @NumeroLinhasAfetadas

	END TRY


	-- SE EXISTIRAM ERROS, DESFAZER TRANSACÇÃO
	BEGIN CATCH

		-- DISPARAR UM ERRO
		SET @Erro = '[WhereToBuy-I10] ' + ERROR_MESSAGE();
		RAISERROR (@Erro, 15, 1)
		RETURN 0

	END CATCH
GO
PRINT N'Altering [dbo].[CategoryInsert]...';


GO
ALTER PROCEDURE [dbo].[CategoryInsert]
	@Codigo nvarchar(5),
	@Descricao nvarchar(50),
	@PesoMedioUnidade float,
	@PrecoMinimoPermitido decimal(14,4),
	@PrecoMaximoPermitido decimal(14,4),
	@PrecoAmplitudeMax float,
	@Confianca float,
	@Inativo bit
AS
	
	DECLARE @Criacao smalldatetime, @Versao datetime, @NumeroLinhasAfetadas int, @Erro nvarchar(255)

	SET @Criacao = GETDATE()
	SET @Versao = GETDATE()


	-- INSERÇÃO DO REGISTO
	BEGIN TRY
		 
		-- INICIA CONTAGEM DE @@ROWCOUNT (para quando usado o ExecuteNonQuery())
		SET NOCOUNT OFF

		-- INSERIR REGISTO
		INSERT INTO [dbo].[Categorias] ([Codigo], [Descricao], [PesoMedioUnidade],[PrecoMaximoPermitido],[PrecoMinimoPermitido], [PrecoAmplitudeMax], [Confianca], [Inativo], [Criacao], [Versao]) 
					VALUES (@Codigo, @Descricao, @PesoMedioUnidade, @PrecoMinimoPermitido, @PrecoMaximoPermitido, @PrecoAmplitudeMax, @Confianca, @Inativo, @Criacao, @Versao);
		
		SET @NumeroLinhasAfetadas = @@ROWCOUNT -- GUARDAR O NUMERO DE LINHAS AFETADAS

		-- ACABA CONTAGEM DE @@ROWCOUNT
		SET NOCOUNT ON

		-- RETORNAR O NUMERO DE LINHAS AFETADAS
		-- Quando usado o ExecuteNonQuery é o @@ROWCOUNT que é lido (SET NOCOUNT OFF/ON),  e não esta variável
		RETURN @NumeroLinhasAfetadas

	END TRY


	-- SE EXISTIRAM ERROS, DESFAZER TRANSACÇÃO
	BEGIN CATCH

		-- DISPARAR UM ERRO
		SET @Erro = '[WhereToBuy-I10] ' + ERROR_MESSAGE();
		RAISERROR (@Erro, 15, 1)
		RETURN 0

	END CATCH
GO
PRINT N'Altering [dbo].[CotacaoInsertSP]...';


GO
/*
	Esta Stored Procedure é tanto usada nas inserções unitárias (por exemplo a partir de um formulário na web), como
	nas inserções em lote..

	No caso das inserções em lote, antes da importação própriamente dita, as CotacoesIncompletas do fornecedor em questão 
	têm que ser removidas. Assim, o argumento @PrevineDuplicacoes deve ser passado com o valor 'false' já que esta prevenção
	foi efetuada com antecedência.

	No caso das inserções unitárias, o parametro @PrevineDuplicacoes deve ser passado com o valor 'true' para que a remoção
	de qualquer cotação incompleta, seja feita pela própria SP.

	!!! IMPORTANTE !!!
	> Existem campo que têm que ser obrigatóriamente indicados e outros que, se forem null (ou seja não indicados) serão sugeridos
	  automáticamente com (vazio).
	
	> Os campos Validade e ValidadeFormula são recebidos porque os prazos de validade de uma cotação podem ser
	  também comunicados pelo fornecedor. Se forem recebidos como NULL, então é o WhereToBuy que vai atribuir a validade.
*/

ALTER PROCEDURE [dbo].[CotacaoInsertSP]
	@PrevineDuplicacoes bit,
	@FornecedorCodigo nvarchar(20),
	@Data datetime,
	@_ProdutoCodigo nvarchar(256),
	@_ComplementoCodigo nvarchar(128),
	@_ComplementoDescricao nvarchar(128),
	@_Partnumber nvarchar(25),
	@_MarcaCodigo nvarchar(128),
	@_MarcaDescricao nvarchar(128),
	@_CategoriaCodigo nvarchar(128),
	@_CategoriaDescricao nvarchar(128),
	@_StockCodigo nvarchar(128),
	@_StockDescricao nvarchar(128),
	@_ImpostoCodigo nvarchar(128),
	@_ImpostoDescricao nvarchar(128),
	@_EstadoCodigo nvarchar(128),
	@_EstadoDescricao nvarchar(128),
	@_Descricao nvarchar(256),
	@_Link nvarchar(1024),
	@_Caracteristicas nvarchar(2048),
	@_Imagem nvarchar(1024),
	@_Preco decimal(14,4),
	@_OutrosCustos decimal(14,4),
	@_OutrosCustosDescricao nvarchar(128),
	@_Validade smalldatetime,
	@_ValidadeDescricao nvarchar(128),
	@Info nvarchar(256) OUTPUT
AS

	-- variaveis
	DECLARE @Partnumber nvarchar(25);


	/*
		Como esta SP é executada automaticamente para cada linha com o SSIS, pretende-se preencher duas colunas adicionais no resulset
		com o objetivo de, linha a linha, ser possivel perceber o problema encontrado.
	
		Para atingir este objetivo existem dois parametros a ter em conta:
			> @Info é um parametro de saída e deve conter a mensagem a colocar na linha / coluna em processamento no SSIS
			> @RETURN_VALUE que é o interno enviado à frente do RETURN e que corresponde ao numero de registos inseridos.

		Assim, se a SP não for executada pelo SSIS mas sim por uma outra aplicação, caso o RETURN_VALUE seja 0 (zero), o programador 
		deve considerar a mensagem de erro que existirá no parametro de saída @info.
	*/



	-- @PrevineDuplicacoes
	IF @PrevineDuplicacoes IS NULL
	BEGIN
		SET @Info = '[CotacaoInsertSP-01] (StoredProcedure)' + 'o valor do parametro @PrevineDuplicacoes não pode ser nulo!';
		RETURN 0
	END




	-- @FornecedorCodigo
	IF @FornecedorCodigo IS NULL
	BEGIN
		SET @Info = '[CotacaoInsertSP-02] (StoredProcedure)' + 'o valor do parametro @FornecedorCodigo não pode ser nulo!';
		RETURN 0
	END

	IF LEN(RTRIM(@FornecedorCodigo)) < 1
	BEGIN
		SET @Info ='[CotacaoInsertSP-03] (StoredProcedure)' + 'o valor do parametro @FornecedorCodigo tem um tamanho inválido!';
		RETURN 0
	END



	-- @Data
	IF @Data IS NULL
	BEGIN
		SET @Info = '[CotacaoInsertSP-04] (StoredProcedure)' + 'o valor do parametro @Data não pode ser nulo!';
		RETURN 0
	END



	-- @_ProdutoCodigo
	/*
		SERÁ AVALIADO APENAS NO FINAL DOS OUTROS PARAMETROS, PORQUE PRECISAMOS DO VALOR DA MARCA E PARTNUMBER PARA CONSTRUIR UM 
		CÓDIGO DE FORNECEDOR CASO ESTE NÃO ENVIE UM.
	*/



	-- @_ComplementoCodigo
	IF @_ComplementoCodigo IS NULL
	BEGIN
		SET @_ComplementoCodigo = '(vazio)';
	END

	IF LEN(RTRIM(@_ComplementoCodigo)) < 1
	BEGIN
		SET @_ComplementoCodigo = '(vazio)';
	END



	-- @_ComplementoDescricao
	IF @_ComplementoDescricao IS NULL
	BEGIN
		SET @_ComplementoDescricao = @_ComplementoCodigo;
	END

	IF LEN(RTRIM(@_ComplementoDescricao)) < 1
	BEGIN
		SET @_ComplementoDescricao = @_ComplementoCodigo;
	END



	-- @_Partnumber
	IF @_Partnumber IS NULL
	BEGIN
		SET @Info = '[CotacaoInsertSP-11] (StoredProcedure)' + 'o valor do parametro @_Partnumber não pode ser nulo!';
		RETURN 0
	END

	IF LEN(RTRIM(@_Partnumber)) < 1
	BEGIN
		SET @Info = '[CotacaoInsertSP-12] (StoredProcedure)' + 'o valor do parametro @_Partnumber tem um tamanho inválido!';
		RETURN 0
	END



	-- @_MarcaCodigo
	IF @_MarcaCodigo IS NULL
	BEGIN
		SET @Info ='[CotacaoInsertSP-13] (StoredProcedure)' + 'o valor do parametro @_MarcaCodigo não pode ser nulo!';
		RETURN 0
	END

	IF LEN(RTRIM(@_MarcaCodigo)) < 1
	BEGIN
		SET @Info = '[CotacaoInsertSP-14] (StoredProcedure)' + 'o valor do parametro @_MarcaCodigo tem um tamanho inválido!';
		RETURN 0
	END



	-- @_MarcaDescricao
	IF @_MarcaDescricao IS NULL
	BEGIN
		SET @_MarcaDescricao = @_MarcaCodigo;
	END

	IF LEN(RTRIM(@_MarcaDescricao)) < 1
	BEGIN
		SET @_MarcaDescricao = @_MarcaCodigo;
	END



	-- @_CategoriaCodigo
	IF @_CategoriaCodigo IS NULL
	BEGIN
		SET @Info = '[CotacaoInsertSP-17] (StoredProcedure)' + 'o valor do parametro @_CategoriaCodigo não pode ser nulo!';
		RETURN 0
	END

	IF LEN(RTRIM(@_CategoriaCodigo)) < 1
	BEGIN
		SET @Info = '[CotacaoInsertSP-18] (StoredProcedure)' + 'o valor do parametro @_CategoriaCodigo tem um tamanho inválido!';
		RETURN 0
	END




	-- @_CategoriaDescricao
	IF @_CategoriaDescricao IS NULL
	BEGIN
		SET @_CategoriaDescricao = @_CategoriaCodigo;
	END

	IF LEN(RTRIM(@_CategoriaDescricao)) < 1
	BEGIN
		SET @_CategoriaDescricao = @_CategoriaCodigo;
	END




	-- @_StockCodigo
	IF @_StockCodigo IS NULL
	BEGIN
		SET @_StockCodigo = '(vazio)';
	END

	IF LEN(RTRIM(@_StockCodigo)) < 1
	BEGIN
		SET @_StockCodigo = '(vazio)';
	END



	
	-- @_StockDescricao
	IF @_StockDescricao IS NULL
	BEGIN
		SET @_StockDescricao = @_StockCodigo;
	END

	IF LEN(RTRIM(@_StockDescricao)) < 1
	BEGIN
		SET @_StockDescricao = @_StockCodigo;
	END




	-- @_ImpostoCodigo
	IF @_ImpostoCodigo IS NULL
	BEGIN
		SET @_ImpostoCodigo = '(vazio)';
	END

	IF LEN(RTRIM(@_ImpostoCodigo)) < 1
	BEGIN
		SET @_ImpostoCodigo = '(vazio)';
	END



	
	-- @_ImpostoDescricao
	IF @_ImpostoDescricao IS NULL
	BEGIN
		SET @_ImpostoDescricao = @_ImpostoCodigo;
	END

	IF LEN(RTRIM(@_ImpostoDescricao)) < 1
	BEGIN
		SET @_ImpostoDescricao = @_ImpostoCodigo;
	END




	-- @_EstadoCodigo
	IF @_EstadoCodigo IS NULL
	BEGIN
		SET @_EstadoCodigo = '(vazio)';
	END

	IF LEN(RTRIM(@_EstadoCodigo)) < 1
	BEGIN
		SET @_EstadoCodigo = '(vazio)';
	END



	
	-- @_EstadoDescricao
	IF @_EstadoDescricao IS NULL
	BEGIN
		SET @_EstadoDescricao = @_EstadoCodigo;
	END

	IF LEN(RTRIM(@_EstadoDescricao)) < 1
	BEGIN
		SET @_EstadoDescricao = @_EstadoCodigo;
	END




	-- @_Descricao
	IF @_Descricao IS NULL
	BEGIN
		SET @Info = '[CotacaoInsertSP-29] (StoredProcedure)' + 'o valor do parametro @_Descricao não pode ser nulo!';
		RETURN 0
	END

	IF LEN(RTRIM(@_Descricao)) < 1
	BEGIN
		SET @Info = '[CotacaoInsertSP-30] (StoredProcedure)' + 'o valor do parametro @_Descricao tem um tamanho inválido!';
		RETURN 0
	END




	-- @_Link
	IF @_Link IS NULL
	BEGIN
		SET @_Link = '(vazio)';
	END

	IF LEN(RTRIM(@_Link)) < 1
	BEGIN
		SET @_Link = '(vazio)';
	END




	-- @_Caracteristicas
	IF @_Caracteristicas IS NULL
	BEGIN
		SET @_Caracteristicas = '(vazio)';
	END

	IF LEN(RTRIM(@_Caracteristicas)) < 1
	BEGIN
		SET @_Caracteristicas = '(vazio)';
	END




	-- @_Imagem
	IF @_Imagem IS NULL
	BEGIN
		SET @_Imagem = '(vazio)';
	END

	IF LEN(RTRIM(@_Imagem)) < 1
	BEGIN
		SET @_Imagem = '(vazio)';
	END





	-- @_Preco
	IF @_Preco IS NULL
	BEGIN
		SET @Info = '[CotacaoInsertSP-37] (StoredProcedure)' + 'o valor do parametro @_Preco não pode ser nulo!';
		RETURN 0
	END





	-- @_OutrosCustos
	IF @_OutrosCustos IS NULL
	BEGIN
		SET @_OutrosCustos = 0.0;
	END





	-- @_OutrosCustosDescricao
	IF @_OutrosCustosDescricao IS NULL
	BEGIN
		SET @_OutrosCustosDescricao = '(vazio)';
	END

	IF LEN(RTRIM(@_OutrosCustosDescricao)) < 1
	BEGIN
		SET @_OutrosCustosDescricao = '(vazio)';
	END




	-- @_Validade
	IF @_Validade IS NULL
	BEGIN
		SET @_Validade = CAST('01-01-2000' AS smalldatetime);
	END





	-- @_ValidadeDescricao
	IF @_ValidadeDescricao IS NULL
	BEGIN
		SET @_ValidadeDescricao = '(vazio)';
	END

	IF LEN(RTRIM(@_ValidadeDescricao)) < 1
	BEGIN
		SET @_OutrosCustosDescricao = '(vazio)';
	END





	-- PREPARAR @Partnumber (INTERNO)
	SET @Partnumber = dbo.GetCotacaoPartnumberFunction(@_Partnumber);



	-- impor regras para códigos externos (sistemas operacionais externos)
	SET @_ComplementoCodigo = dbo.GetCodigoExternoNormalizadoFunction(@_ComplementoCodigo);
	SET @_MarcaCodigo = dbo.GetCodigoExternoNormalizadoFunction(@_MarcaCodigo);
	SET @_CategoriaCodigo = dbo.GetCodigoExternoNormalizadoFunction(@_CategoriaCodigo);
	SET @_StockCodigo = dbo.GetCodigoExternoNormalizadoFunction(@_StockCodigo);
	SET @_ImpostoCodigo = dbo.GetCodigoExternoNormalizadoFunction(@_ImpostoCodigo);
	SET @_EstadoCodigo = dbo.GetCodigoExternoNormalizadoFunction(@_EstadoCodigo);



	-- @_ProdutoCodigo
	IF @_ProdutoCodigo IS NULL
	BEGIN
		SET @_ProdutoCodigo = '(' + @_MarcaCodigo + ')' + @Partnumber; -- uso o @Partnumber interno porque está limpo de caracteres anómalos
	END

	IF LEN(RTRIM(@_ProdutoCodigo)) < 1
	BEGIN
		SET @_ProdutoCodigo = '(' + @_MarcaCodigo + ')' + @Partnumber; -- uso o @Partnumber interno porque está limpo de caracteres anómalos
	END




	-- PREVINE DUPLICAÇÕES (remove a CotacaoNaoIntegrada que possa existir para este FornecedorCodigo / _ProdutoCodigo
	IF @PrevineDuplicacoes = CAST('true' as bit)
	BEGIN
		-- remove cotacoes já completas mas ainda não integradas
		DELETE FROM [dbo].CotacoesNaoIntegradasView
			   WHERE [FornecedorCodigo] = @FornecedorCodigo
					 AND [_ProdutoCodigo] = @_ProdutoCodigo

		-- remove cotações incompletas
		DELETE FROM [dbo].CotacoesIncompletasView
			   WHERE [FornecedorCodigo] = @FornecedorCodigo
					 AND [_ProdutoCodigo] = @_ProdutoCodigo

	END




	-- INSERIR
	SET NOCOUNT ON; -- não há necessidade de contar os registos (é sempre 1)


	BEGIN TRY
	
		INSERT INTO [dbo].[Cotacoes]
			   (
				   [FornecedorCodigo], [Data], [_ProdutoCodigo], [_ComplementoCodigo], [_ComplementoDescricao],
				   [_Partnumber], [_MarcaCodigo], [_MarcaDescricao], [_CategoriaCodigo], [_CategoriaDescricao], [_StockCodigo], [_StockDescricao],
				   [_ImpostoCodigo], [_ImpostoDescricao], [_EstadoCodigo], [_EstadoDescricao], [_Descricao], [_Link], [_Caracteristicas], [_Imagem], 
				   [_Preco], [_OutrosCustos], [_OutrosCustosDescricao], [_Validade], [_ValidadeDescricao],
				   [ComplementoCodigo], [Partnumber], [MarcaCodigo], [CategoriaCodigo], 
				   [StockCodigo], [StockCodigoSubstituto], [StockCodigoSubstitutoJustificacao], 
				   [ImpostoCodigo], [EstadoCodigo], [Descricao], [Link], [Caracteristicas], [PrecoCusto], [PrecoCustoFormula],
				   [Validade], [ValidadeFormula], [ProdutoCodigo], 
				   [Completo], [Integrado],
				   [Inativo], [Versao]
				)
				VALUES
				(
				   @FornecedorCodigo, @Data, @_ProdutoCodigo, @_ComplementoCodigo, @_ComplementoDescricao,
				   @_Partnumber, @_MarcaCodigo, @_MarcaDescricao, @_CategoriaCodigo, @_CategoriaDescricao, @_StockCodigo, @_StockDescricao,
				   @_ImpostoCodigo, @_ImpostoDescricao, @_EstadoCodigo, @_EstadoDescricao, @_Descricao, @_Link, @_Caracteristicas, @_Imagem, 
				   @_Preco, @_OutrosCustos, @_OutrosCustosDescricao, @_Validade, @_ValidadeDescricao,
				   null, @Partnumber, null, null, 
				   null, null, null, 
				   null, null, null, null, null, null, null, 
				   null, null, null, 
				   CAST('false' as bit), CAST('false' as bit),
				   CAST('false' as bit), GETDATE()
				);


		-- preencher output com informação - sucesso
		SET @Info = 'Cotação inserida com sucesso.';

		-- devolver informação que foi inserido um registo
		RETURN 1;

	END TRY
	BEGIN CATCH

		-- preencher output com informação - sucesso
		SET @Info = '[CotacaoInsertSP-50] ' +CAST(ERROR_NUMBER() as nvarchar) + ' - ' +ERROR_MESSAGE();

		-- devolver informação que foi inserido um registo
		RETURN 1;

	END CATCH

RETURN;
GO
PRINT N'Altering [dbo].[GroupInsert]...';


GO
ALTER PROCEDURE [dbo].[GroupInsert]
	@Codigo nvarchar(5),
	@Descricao nvarchar(50),
	@Inativo bit
AS
	
	DECLARE @Criacao smalldatetime, @Versao datetime, @NumeroLinhasAfetadas int, @Erro nvarchar(255)

	SET @Criacao = GETDATE()
	SET @Versao = GETDATE()


	-- INSERÇÃO DO REGISTO
	BEGIN TRY
		 
		-- INICIA CONTAGEM DE @@ROWCOUNT (para quando usado o ExecuteNonQuery())
		SET NOCOUNT OFF

		-- INSERIR REGISTO
		INSERT INTO [dbo].[Grupos] ([Codigo], [Descricao], [Inativo], [Criacao], [Versao]) 
					VALUES (@Codigo, @Descricao, @Inativo, @Criacao, @Versao);
		
		SET @NumeroLinhasAfetadas = @@ROWCOUNT -- GUARDAR O NUMERO DE LINHAS AFETADAS

		-- ACABA CONTAGEM DE @@ROWCOUNT
		SET NOCOUNT ON

		-- RETORNAR O NUMERO DE LINHAS AFETADAS
		-- Quando usado o ExecuteNonQuery é o @@ROWCOUNT que é lido (SET NOCOUNT OFF/ON),  e não esta variável
		RETURN @NumeroLinhasAfetadas

	END TRY


	-- SE EXISTIRAM ERROS, DESFAZER TRANSACÇÃO
	BEGIN CATCH

		-- DISPARAR UM ERRO
		SET @Erro = '[WhereToBuy-I10] ' + ERROR_MESSAGE();
		RAISERROR (@Erro, 15, 1)
		RETURN 0

	END CATCH
GO
PRINT N'Altering [dbo].[LanguageInsert]...';


GO
ALTER PROCEDURE [dbo].[LanguageInsert]
	@Codigo nvarchar(5),
	@Descricao nvarchar(50),
	@Inativo bit
AS
	
	DECLARE @Criacao smalldatetime, @Versao datetime, @NumeroLinhasAfetadas int, @Erro nvarchar(255)

	SET @Criacao = GETDATE()
	SET @Versao = GETDATE()


	-- INSERÇÃO DO REGISTO
	BEGIN TRY
		 
		-- INICIA CONTAGEM DE @@ROWCOUNT (para quando usado o ExecuteNonQuery())
		SET NOCOUNT OFF

		-- INSERIR REGISTO
		INSERT INTO [dbo].[Idiomas] ([Codigo], [Descricao], [Inativo], [Criacao], [Versao]) 
					VALUES (@Codigo, @Descricao, @Inativo, @Criacao, @Versao);
		
		SET @NumeroLinhasAfetadas = @@ROWCOUNT -- GUARDAR O NUMERO DE LINHAS AFETADAS

		-- ACABA CONTAGEM DE @@ROWCOUNT
		SET NOCOUNT ON

		-- RETORNAR O NUMERO DE LINHAS AFETADAS
		-- Quando usado o ExecuteNonQuery é o @@ROWCOUNT que é lido (SET NOCOUNT OFF/ON),  e não esta variável
		RETURN @NumeroLinhasAfetadas

	END TRY


	-- SE EXISTIRAM ERROS, DESFAZER TRANSACÇÃO
	BEGIN CATCH

		-- DISPARAR UM ERRO
		SET @Erro = '[WhereToBuy-I10] ' + ERROR_MESSAGE();
		RAISERROR (@Erro, 15, 1)
		RETURN 0

	END CATCH
GO
PRINT N'Altering [dbo].[QuotationWarningInsert]...';


GO
ALTER PROCEDURE [dbo].[QuotationWarningInsert]
	@Id uniqueidentifier,
	@Data smalldatetime,
	@ProdutoCodigo nvarchar(256),
	@ComplementoCodigo nvarchar(128),
	@FornecedorCodigo nvarchar(5),
	@AvisoTipoCodigo nvarchar(5),
	@Descricao nvarchar(20)
AS
	
	DECLARE @Criacao smalldatetime, @NumeroLinhasAfetadas int, @Erro nvarchar(255)

	SET @Criacao = GETDATE()


	-- INSERÇÃO DO REGISTO
	BEGIN TRY
		 
		-- INICIA CONTAGEM DE @@ROWCOUNT (para quando usado o ExecuteNonQuery())
		SET NOCOUNT OFF

		-- INSERIR REGISTO
		INSERT INTO [dbo].[CotacoesAvisos] ([Id], [Data], [_ProdutoCodigo], [_ComplementoCodigo], [FornecedorCodigo], [AvisoTipoCodigo], [Descricao], [Criacao]) 
					VALUES (@Id, @Data, @ProdutoCodigo, @ComplementoCodigo, @FornecedorCodigo, @AvisoTipoCodigo, @Descricao, @Criacao);
		
		SET @NumeroLinhasAfetadas = @@ROWCOUNT -- GUARDAR O NUMERO DE LINHAS AFETADAS

		-- ACABA CONTAGEM DE @@ROWCOUNT
		SET NOCOUNT ON

		-- RETORNAR O NUMERO DE LINHAS AFETADAS
		-- Quando usado o ExecuteNonQuery é o @@ROWCOUNT que é lido (SET NOCOUNT OFF/ON),  e não esta variável
		RETURN @NumeroLinhasAfetadas

	END TRY


	-- SE EXISTIRAM ERROS, DESFAZER TRANSACÇÃO
	BEGIN CATCH

		-- DISPARAR UM ERRO
		SET @Erro = '[WhereToBuy-I10] ' + ERROR_MESSAGE();
		RAISERROR (@Erro, 15, 1)
		RETURN 0

	END CATCH
GO
PRINT N'Altering [dbo].[StateInsert]...';


GO
ALTER PROCEDURE [dbo].[StateInsert]
	@Codigo nvarchar(5),
	@Descricao nvarchar(50),
	@Inativo bit
AS
	
	DECLARE @Criacao smalldatetime, @Versao datetime, @NumeroLinhasAfetadas int, @Erro nvarchar(255)

	SET @Criacao = GETDATE()
	SET @Versao = GETDATE()


	-- INSERÇÃO DO REGISTO
	BEGIN TRY
		 
		-- INICIA CONTAGEM DE @@ROWCOUNT (para quando usado o ExecuteNonQuery())
		SET NOCOUNT OFF

		-- INSERIR REGISTO
		INSERT INTO [dbo].[Estados] ([Codigo], [Descricao], [Inativo], [Criacao], [Versao]) 
					VALUES (@Codigo, @Descricao, @Inativo, @Criacao, @Versao);
		
		SET @NumeroLinhasAfetadas = @@ROWCOUNT -- GUARDAR O NUMERO DE LINHAS AFETADAS

		-- ACABA CONTAGEM DE @@ROWCOUNT
		SET NOCOUNT ON

		-- RETORNAR O NUMERO DE LINHAS AFETADAS
		-- Quando usado o ExecuteNonQuery é o @@ROWCOUNT que é lido (SET NOCOUNT OFF/ON),  e não esta variável
		RETURN @NumeroLinhasAfetadas

	END TRY


	-- SE EXISTIRAM ERROS, DESFAZER TRANSACÇÃO
	BEGIN CATCH

		-- DISPARAR UM ERRO
		SET @Erro = '[WhereToBuy-I10] ' + ERROR_MESSAGE();
		RAISERROR (@Erro, 15, 1)
		RETURN 0

	END CATCH
GO
PRINT N'Altering [dbo].[Step2b1a_Mappings_Addons_FeedNewRules]...';


GO
/*
	This SP feeds Addons Matching table with new rules, considering the new incoming quotations
*/


ALTER PROCEDURE [dbo].[Step2b1a_Mappings_Addons_FeedNewRules]
	@Info nvarchar(256) OUTPUT
AS
	
	-- new rules feeding
	BEGIN TRY

		/*
			Feed (..)Matching table with new incomplete rules, to simplify mapping work to the user.
		*/
		INSERT [dbo].[ComplementosMatching] (FornecedorCodigo, Codigo, Descricao, MapTo, Inativo, Criacao, Versao)
	
		SELECT um.FornecedorCodigo, 
			   um.Codigo,
			   (
					-- get 1st existing description in CotacoesIncompletasView for this entity
					SELECT TOP 1 CASE WHEN ci._ComplementoDescricao IS NULL THEN '(vazio)'
									  ELSE ci._ComplementoDescricao
								 END
					FROM [dbo].[CotacoesIncompletasView] ci
					WHERE ci.FornecedorCodigo = um.FornecedorCodigo
						  AND ci._ComplementoCodigo = um.Codigo
				    ORDER BY ci._ComplementoDescricao DESC  -- prevents the existence of some _ComplementoDescricao = NULL
		      ) AS [Descricao],
			  NULL, -- MapTo will be filled later by user
			  CAST('false' as bit),
			  GETDATE(),
			  GETDATE()
		FROM
			  (
					-- un-existing but needed matching rules
					SELECT DISTINCT ci.FornecedorCodigo, ci._ComplementoCodigo AS Codigo
					FROM [dbo].[CotacoesIncompletasView] ci
					EXCEPT
					SELECT cm.FornecedorCodigo, cm.Codigo
					FROM [dbo].[ComplementosMatching] cm
			  ) um

		



		-- fill output @info with sucess message
		SET @Info = '[Step2b1a_Mappings_Addons_FeedNewRules-01] Number of created matching rules: ' + CAST(@@ROWCOUNT as nvarchar);

		-- send true to output
		RETURN 1;

	END TRY

	BEGIN CATCH
		-- fill output @info with occurred error message
		SET @Info = '[Step2b1a_Mappings_Addons_FeedNewRules-02] ' + CAST(ERROR_NUMBER() as nvarchar) + ' - ' + ERROR_MESSAGE();

		-- send false to output
		RETURN 0;

	END CATCH

RETURN;
GO
PRINT N'Altering [dbo].[Step2b1a_Mappings_Brands_FeedNewRules]...';


GO
/*
	This SP feeds MarcasMatching table with new rules, considering the new incoming quotations
*/


ALTER PROCEDURE [dbo].[Step2b1a_Mappings_Brands_FeedNewRules]
	@Info nvarchar(256) OUTPUT
AS
	
	-- new rules feeding
	BEGIN TRY

		/*
			Feed (..)Matching table with new incomplete rules, to simplify mapping work to the user.
		*/

		INSERT [dbo].[MarcasMatching] (FornecedorCodigo, Codigo, Descricao, MapTo, Inativo, Criacao, Versao)
	
		SELECT um.FornecedorCodigo, 
			   um.Codigo,
			   (
					-- get 1st existing description in CotacoesIncompletasView for this entity
					SELECT TOP 1 CASE WHEN ci._MarcaDescricao IS NULL THEN '(vazio)'
									  ELSE ci._MarcaDescricao
								 END
					FROM [dbo].[CotacoesIncompletasView] ci
					WHERE ci.FornecedorCodigo = um.FornecedorCodigo
						  AND ci._MarcaCodigo = um.Codigo
				    ORDER BY ci._MarcaDescricao DESC  -- prevents the existence of some _MarcaDescricao = NULL
		      ) AS [Descricao],
			  NULL, -- MapTo will be filled later by user
			  CAST('false' as bit),
			  GETDATE(),
			  GETDATE()
		FROM
			  (
					-- un-existing but needed matching rules
					SELECT DISTINCT ci.FornecedorCodigo, ci._MarcaCodigo AS Codigo
					FROM [dbo].[CotacoesIncompletasView] ci
					EXCEPT
					SELECT mm.FornecedorCodigo, mm.Codigo
					FROM [dbo].[MarcasMatching] mm
			  ) um
		



		-- fill output @info with sucess message
		SET @Info = '[Step2b1a_Mappings_Brands_FeedNewRules-01] Number of created matching rules: ' + CAST(@@ROWCOUNT as nvarchar);

		-- send true to output
		RETURN 1;

	END TRY

	BEGIN CATCH
		-- fill output @info with occurred error message
		SET @Info = '[Step2b1a_Mappings_Brands_FeedNewRules-02] ' + CAST(ERROR_NUMBER() as nvarchar) + ' - ' + ERROR_MESSAGE();

		-- send false to output
		RETURN 0;

	END CATCH

RETURN;
GO
PRINT N'Altering [dbo].[Step2b1a_Mappings_Categories_FeedNewRules]...';


GO
/*
	This SP feeds CategoriesMatching table with new rules, considering the new incoming quotations
*/


ALTER PROCEDURE [dbo].[Step2b1a_Mappings_Categories_FeedNewRules]
	@Info nvarchar(256) OUTPUT
AS
	
	-- new rules feeding
	BEGIN TRY

		/*
			Feed (..)Matching table with new incomplete rules, to simplify mapping work to the user.
		*/

		INSERT [dbo].[CategoriasMatching] (FornecedorCodigo, Codigo, Descricao, MapTo, Inativo, Criacao, Versao)
	
		SELECT um.FornecedorCodigo, 
			   um.Codigo,
			   (
					-- get 1st existing description in CotacoesIncompletasView for this entity
					SELECT TOP 1 CASE WHEN ci._CategoriaDescricao IS NULL THEN '(vazio)'
									  ELSE ci._CategoriaDescricao
								 END
					FROM [dbo].[CotacoesIncompletasView] ci
					WHERE ci.FornecedorCodigo = um.FornecedorCodigo
						  AND ci._CategoriaCodigo = um.Codigo
				    ORDER BY ci._CategoriaDescricao DESC  -- prevents the existence of some _CategoriaDescricao = NULL
		      ) AS [Descricao],
			  NULL, -- MapTo will be filled later by user
			  CAST('false' as bit),
			  GETDATE(),
			  GETDATE()
		FROM
			  (
					-- un-existing but needed matching rules
					SELECT DISTINCT ci.FornecedorCodigo, ci._CategoriaCodigo AS Codigo
					FROM [dbo].[CotacoesIncompletasView] ci
					EXCEPT
					SELECT tm.FornecedorCodigo, tm.Codigo
					FROM [dbo].[CategoriasMatching] tm
			  ) um
		



		-- fill output @info with sucess message
		SET @Info = '[Step2b1a_Mappings_Categories_FeedNewRules-01] Number of created matching rules: ' + CAST(@@ROWCOUNT as nvarchar);

		-- send true to output
		RETURN 1;

	END TRY

	BEGIN CATCH
		-- fill output @info with occurred error message
		SET @Info = '[Step2b1a_Mappings_Categories_FeedNewRules-02] ' + CAST(ERROR_NUMBER() as nvarchar) + ' - ' + ERROR_MESSAGE();

		-- send false to output
		RETURN 0;

	END CATCH

RETURN;
GO
PRINT N'Altering [dbo].[Step2b1a_Mappings_Statuses_FeedNewRules]...';


GO
/*
	This SP feeds Statuses Matching table with new rules, considering the new incoming quotations
*/


ALTER PROCEDURE [dbo].[Step2b1a_Mappings_Statuses_FeedNewRules]
	@Info nvarchar(256) OUTPUT
AS
	
	-- new rules feeding
	BEGIN TRY

		/*
			Feed (..)Matching table with new incomplete rules, to simplify mapping work to the user.
		*/
		INSERT [dbo].[EstadosMatching] (FornecedorCodigo, Codigo, Descricao, MapTo, Inativo, Criacao, Versao)
	
		SELECT um.FornecedorCodigo, 
			   um.Codigo,
			   (
					-- get 1st existing description in CotacoesIncompletasView for this entity
					SELECT TOP 1 CASE WHEN ci._EstadoDescricao IS NULL THEN '(vazio)'
									  ELSE ci._EstadoDescricao
								 END
					FROM [dbo].[CotacoesIncompletasView] ci
					WHERE ci.FornecedorCodigo = um.FornecedorCodigo
						  AND ci._EstadoCodigo = um.Codigo
				    ORDER BY ci._EstadoDescricao DESC  -- prevents the existence of some _EstadoDescricao = NULL
		      ) AS [Descricao],
			  NULL, -- MapTo will be filled later by user
			  CAST('false' as bit),
			  GETDATE(),
			  GETDATE()
		FROM
			  (
					-- un-existing but needed matching rules
					SELECT DISTINCT ci.FornecedorCodigo, ci._EstadoCodigo AS Codigo
					FROM [dbo].[CotacoesIncompletasView] ci
					EXCEPT
					SELECT dm.FornecedorCodigo, dm.Codigo
					FROM [dbo].[EstadosMatching] dm
			  ) um

		



		-- fill output @info with sucess message
		SET @Info = '[Step2b1a_Mappings_Statuses_FeedNewRules-01] Number of created matching rules: ' + CAST(@@ROWCOUNT as nvarchar);

		-- send true to output
		RETURN 1;

	END TRY

	BEGIN CATCH
		-- fill output @info with occurred error message
		SET @Info = '[Step2b1a_Mappings_Statuses_FeedNewRules-02] ' + CAST(ERROR_NUMBER() as nvarchar) + ' - ' + ERROR_MESSAGE();

		-- send false to output
		RETURN 0;

	END CATCH

RETURN;
GO
PRINT N'Altering [dbo].[Step2b1a_Mappings_Stocks_FeedNewRules]...';


GO
/*
	This SP feeds StocksMatching table with new rules, considering the new incoming quotations
*/


ALTER PROCEDURE [dbo].[Step2b1a_Mappings_Stocks_FeedNewRules]
	@Info nvarchar(256) OUTPUT
AS
	
	-- new rules feeding
	BEGIN TRY

		/*
			Feed (..)Matching table with new incomplete rules, to simplify mapping work to the user.
		*/

		INSERT [dbo].[StocksMatching] (FornecedorCodigo, Codigo, Descricao, MapTo, Inativo, Criacao, Versao)
	
		SELECT um.FornecedorCodigo, 
			   um.Codigo,
			   (
					-- get 1st existing description in CotacoesIncompletasView for this entity
					SELECT TOP 1 CASE WHEN ci._StockDescricao IS NULL THEN '(vazio)'
									  ELSE ci._StockDescricao
								 END
					FROM [dbo].[CotacoesIncompletasView] ci
					WHERE ci.FornecedorCodigo = um.FornecedorCodigo
						  AND ci._StockCodigo = um.Codigo
				    ORDER BY ci._StockDescricao DESC  -- prevents the existence of some _StockDescricao = NULL
		      ) AS [Descricao],
			  NULL, -- MapTo will be filled later by user
			  CAST('false' as bit),
			  GETDATE(),
			  GETDATE()
		FROM
			  (
					-- un-existing but needed matching rules
					SELECT DISTINCT ci.FornecedorCodigo, ci._StockCodigo AS Codigo
					FROM [dbo].[CotacoesIncompletasView] ci
					EXCEPT
					SELECT sm.FornecedorCodigo, sm.Codigo
					FROM [dbo].[StocksMatching] sm
			  ) um
		



		-- fill output @info with sucess message
		SET @Info = '[Step2b1a_Mappings_Stocks_FeedNewRules-01] Number of created matching rules: ' + CAST(@@ROWCOUNT as nvarchar);

		-- send true to output
		RETURN 1;

	END TRY

	BEGIN CATCH
		-- fill output @info with occurred error message
		SET @Info = '[Step2b1a_Mappings_Stocks_FeedNewRules-02] ' + CAST(ERROR_NUMBER() as nvarchar) + ' - ' + ERROR_MESSAGE();

		-- send false to output
		RETURN 0;

	END CATCH

RETURN;
GO
PRINT N'Altering [dbo].[Step2b1a_Mappings_Taxes_FeedNewRules]...';


GO
/*
	This SP feeds Taxes Matching table with new rules, considering the new incoming quotations
*/


ALTER PROCEDURE [dbo].[Step2b1a_Mappings_Taxes_FeedNewRules]
	@Info nvarchar(256) OUTPUT
AS
	
	-- new rules feeding
	BEGIN TRY

		/*
			Feed (..)Matching table with new incomplete rules, to simplify mapping work to the user.
		*/

		INSERT [dbo].[ImpostosMatching] (FornecedorCodigo, Codigo, Descricao, MapTo, Inativo, Criacao, Versao)
	
		SELECT um.FornecedorCodigo, 
			   um.Codigo,
			   (
					-- get 1st existing description in CotacoesIncompletasView for this entity
					SELECT TOP 1 CASE WHEN ci._ImpostoDescricao IS NULL THEN '(vazio)'
									  ELSE ci._ImpostoDescricao
								 END
					FROM [dbo].[CotacoesIncompletasView] ci
					WHERE ci.FornecedorCodigo = um.FornecedorCodigo
						  AND ci._ImpostoCodigo = um.Codigo
				    ORDER BY ci._ImpostoDescricao DESC  -- prevents the existence of some _ImpostoDescricao = NULL
		      ) AS [Descricao],
			  NULL, -- MapTo will be filled later by user
			  CAST('false' as bit),
			  GETDATE(),
			  GETDATE()
		FROM
			  (
					-- un-existing but needed matching rules
					SELECT DISTINCT ci.FornecedorCodigo, ci._ImpostoCodigo AS Codigo
					FROM [dbo].[CotacoesIncompletasView] ci
					EXCEPT
					SELECT im.FornecedorCodigo, im.Codigo
					FROM [dbo].[ImpostosMatching] im
			  ) um
		



		-- fill output @info with sucess message
		SET @Info = '[Step2b1a_Mappings_Taxes_FeedNewRules-01] Number of created matching rules: ' + CAST(@@ROWCOUNT as nvarchar);

		-- send true to output
		RETURN 1;

	END TRY

	BEGIN CATCH
		-- fill output @info with occurred error message
		SET @Info = '[Step2b1a_Mappings_Taxes_FeedNewRules-02] ' + CAST(ERROR_NUMBER() as nvarchar) + ' - ' + ERROR_MESSAGE();

		-- send false to output
		RETURN 0;

	END CATCH

RETURN;
GO
PRINT N'Altering [dbo].[Step2b1b_Mappings_Addons_Map]...';


GO
/*
	This SP, perform Addons Mapping of incomplete Quotations.
*/


ALTER PROCEDURE [dbo].[Step2b1b_Mappings_Addons_Map]
	@Info nvarchar(256) OUTPUT
AS
	
	-- begin matching
	BEGIN TRY

		/*
			Map entities considering (..)Matching rules.
		*/
		UPDATE [dbo].[CotacoesIncompletasView]
		SET ComplementoCodigo = cm.MapTo,
			Versao = GETDATE()

		/*  Using (..)IncompletasView I am assuring that I'm only working with Cotacoes where Inactivo='false' and Completo='false'
			(although, with this mapping lack, never the quotation whould be completed - so this control is redundant)
		*/
		FROM [dbo].[CotacoesIncompletasView] ci
			INNER JOIN [dbo].[ComplementosMatching] cm
				ON ci.FornecedorCodigo = cm.FornecedorCodigo
					AND ci._ComplementoCodigo = cm.Codigo

		-- filter only active matching rules with MapTo already settled, and not mapped incomplete quotations
		WHERE cm.Inativo = CAST('false' as bit)
			  AND ci.ComplementoCodigo IS NULL
			  AND cm.MapTo IS NOT NULL



		-- fill output @info with sucess message
		SET @Info = '[Step2b1b_Mappings_Addons_Map-01] Number of mapped quotations: ' + CAST(@@ROWCOUNT as nvarchar);

		-- send true to output
		RETURN 1;

	END TRY

	BEGIN CATCH
		-- fill output @info with occurred error message
		SET @Info = '[Step2b1b_Mappings_Addons_Map-02] ' + CAST(ERROR_NUMBER() as nvarchar) + ' - ' + ERROR_MESSAGE();

		-- send false to output
		RETURN 0;

	END CATCH

RETURN;
GO
PRINT N'Altering [dbo].[Step2b1b_Mappings_Brands_Map]...';


GO
/*
	This SP, perform Brand Mapping of incomplete Quotations.
*/


ALTER PROCEDURE [dbo].[Step2b1b_Mappings_Brands_Map]
	@Info nvarchar(256) OUTPUT
AS
	
	-- begin matching
	BEGIN TRY

		/*
			Map entities considering (..)Matching rules.
		*/
		UPDATE [dbo].[CotacoesIncompletasView]
		SET MarcaCodigo = mm.MapTo,
			Versao = GETDATE()

		/*  Using (..)IncompletasView I am assuring that I'm only working with Cotacoes where Inactivo='false' and Completo='false'
			(although, with this mapping lack, never the quotation whould be completed - so this control is redundant)
		*/
		FROM [dbo].[CotacoesIncompletasView] ci
			INNER JOIN [dbo].[MarcasMatching] mm
				ON ci.FornecedorCodigo = mm.FornecedorCodigo
					AND ci._MarcaCodigo = mm.Codigo

		-- filter only active matching rules with MapTo already settled, and not mapped incomplete quotations
		WHERE mm.Inativo = CAST('false' as bit)
			  AND ci.MarcaCodigo IS NULL
			  AND mm.MapTo IS NOT NULL



		-- fill output @info with sucess message
		SET @Info = '[Step2b1b_Mappings_Brands_Map-01] Number of mapped quotations: ' + CAST(@@ROWCOUNT as nvarchar);

		-- send true to output
		RETURN 1;

	END TRY

	BEGIN CATCH
		-- fill output @info with occurred error message
		SET @Info = '[Step2b1b_Mappings_Brands_Map-02] ' + CAST(ERROR_NUMBER() as nvarchar) + ' - ' + ERROR_MESSAGE();

		-- send false to output
		RETURN 0;

	END CATCH

RETURN;
GO
PRINT N'Altering [dbo].[Step2b1b_Mappings_Categories_Map]...';


GO
/*
	This SP, perform Category Mapping of incomplete Quotations.
*/


ALTER PROCEDURE [dbo].[Step2b1b_Mappings_Categories_Map]
	@Info nvarchar(256) OUTPUT
AS
	
	-- begin matching
	BEGIN TRY

		/*
			Map entities considering (..)Matching rules.
		*/
		UPDATE [dbo].[CotacoesIncompletasView]
		SET CategoriaCodigo = tm.MapTo,
			Versao = GETDATE()

		/*  Using (..)IncompletasView I am assuring that I'm only working with Cotacoes where Inactivo='false' and Completo='false'
			(although, with this mapping lack, never the quotation whould be completed - so this control is redundant)
		*/
		FROM [dbo].[CotacoesIncompletasView] ci
			INNER JOIN [dbo].[CategoriasMatching] tm
				ON ci.FornecedorCodigo = tm.FornecedorCodigo
					AND ci._CategoriaCodigo = tm.Codigo

		-- filter only active matching rules with MapTo already settled, and not mapped incomplete quotations
		WHERE tm.Inativo = CAST('false' as bit)
			  AND ci.CategoriaCodigo IS NULL
			  AND tm.MapTo IS NOT NULL



		-- fill output @info with sucess message
		SET @Info = '[Step2b1b_Mappings_Categories_Map-01] Number of mapped quotations: ' + CAST(@@ROWCOUNT as nvarchar);

		-- send true to output
		RETURN 1;

	END TRY

	BEGIN CATCH
		-- fill output @info with occurred error message
		SET @Info = '[Step2b1b_Mappings_Categories_Map-02] ' + CAST(ERROR_NUMBER() as nvarchar) + ' - ' + ERROR_MESSAGE();

		-- send false to output
		RETURN 0;

	END CATCH

RETURN;
GO
PRINT N'Altering [dbo].[Step2b1b_Mappings_Statuses_Map]...';


GO
/*
	This SP, perform Statuses Mapping of incomplete Quotations.
*/


ALTER PROCEDURE [dbo].[Step2b1b_Mappings_Statuses_Map]
	@Info nvarchar(256) OUTPUT
AS
	
	-- begin matching
	BEGIN TRY

		/*
			Map entities considering (..)Matching rules.
		*/
		UPDATE [dbo].[CotacoesIncompletasView]
		SET EstadoCodigo = dm.MapTo,
			Versao = GETDATE()

		/*  Using (..)IncompletasView I am assuring that I'm only working with Cotacoes where Inactivo='false' and Completo='false'
			(although, with this mapping lack, never the quotation whould be completed - so this control is redundant)
		*/
		FROM [dbo].[CotacoesIncompletasView] ci
			INNER JOIN [dbo].[EstadosMatching] dm
				ON ci.FornecedorCodigo = dm.FornecedorCodigo
					AND ci._EstadoCodigo = dm.Codigo

		-- filter only active matching rules with MapTo already settled, and not mapped incomplete quotations
		WHERE dm.Inativo = CAST('false' as bit)
			  AND ci.EstadoCodigo IS NULL
			  AND dm.MapTo IS NOT NULL



		-- fill output @info with sucess message
		SET @Info = '[Step2b1b_Mappings_Statuses_Map-01] Number of mapped quotations: ' + CAST(@@ROWCOUNT as nvarchar);

		-- send true to output
		RETURN 1;

	END TRY

	BEGIN CATCH
		-- fill output @info with occurred error message
		SET @Info = '[Step2b1b_Mappings_Statuses_Map-02] ' + CAST(ERROR_NUMBER() as nvarchar) + ' - ' + ERROR_MESSAGE();

		-- send false to output
		RETURN 0;

	END CATCH

RETURN;
GO
PRINT N'Altering [dbo].[Step2b1b_Mappings_Stocks_Map]...';


GO
/*
	This SP, perform Stock Mapping of incomplete Quotations.
*/


ALTER PROCEDURE [dbo].[Step2b1b_Mappings_Stocks_Map]
	@Info nvarchar(256) OUTPUT
AS
	
	-- begin matching
	BEGIN TRY

		/*
			Map entities considering (..)Matching rules.
		*/
		UPDATE [dbo].[CotacoesIncompletasView]
		SET StockCodigo = sm.MapTo,
			Versao = GETDATE()

		/*  Using (..)IncompletasView I am assuring that I'm only working with Cotacoes where Inactivo='false' and Completo='false'
			(although, with this mapping lack, never the quotation whould be completed - so this control is redundant)
		*/
		FROM [dbo].[CotacoesIncompletasView] ci
			INNER JOIN [dbo].[StocksMatching] sm
				ON ci.FornecedorCodigo = sm.FornecedorCodigo
					AND ci._StockCodigo = sm.Codigo

		-- filter only active matching rules with MapTo already settled, and not mapped incomplete quotations
		WHERE sm.Inativo = CAST('false' as bit)
			  AND ci.StockCodigo IS NULL
			  AND sm.MapTo IS NOT NULL



		-- fill output @info with sucess message
		SET @Info = '[Step2b1b_Mappings_Stocks_Map-01] Number of mapped quotations: ' + CAST(@@ROWCOUNT as nvarchar);

		-- send true to output
		RETURN 1;

	END TRY

	BEGIN CATCH
		-- fill output @info with occurred error message
		SET @Info = '[Step2b1b_Mappings_Stocks_Map-02] ' + CAST(ERROR_NUMBER() as nvarchar) + ' - ' + ERROR_MESSAGE();

		-- send false to output
		RETURN 0;

	END CATCH

RETURN;
GO
PRINT N'Altering [dbo].[Step2b1b_Mappings_Taxes_Map]...';


GO
/*
	This SP, perform Taxes Mapping of incomplete Quotations.
*/


ALTER PROCEDURE [dbo].[Step2b1b_Mappings_Taxes_Map]
	@Info nvarchar(256) OUTPUT
AS
	
	-- begin matching
	BEGIN TRY

		/*
			Map entities considering (..)Matching rules.
		*/
		UPDATE [dbo].[CotacoesIncompletasView]
		SET ImpostoCodigo = im.MapTo,
			Versao = GETDATE()

		/*  Using (..)IncompletasView I am assuring that I'm only working with Cotacoes where Inactivo='false' and Completo='false'
			(although, with this mapping lack, never the quotation whould be completed - so this control is redundant)
		*/
		FROM [dbo].[CotacoesIncompletasView] ci
			INNER JOIN [dbo].[ImpostosMatching] im
				ON ci.FornecedorCodigo = im.FornecedorCodigo
					AND ci._ImpostoCodigo = im.Codigo

		-- filter only active matching rules with MapTo already settled, and not mapped incomplete quotations
		WHERE im.Inativo = CAST('false' as bit)
			  AND ci.ImpostoCodigo IS NULL
			  AND im.MapTo IS NOT NULL



		-- fill output @info with sucess message
		SET @Info = '[Step2b1b_Mappings_Taxes_Map-01] Number of mapped quotations: ' + CAST(@@ROWCOUNT as nvarchar);

		-- send true to output
		RETURN 1;

	END TRY

	BEGIN CATCH
		-- fill output @info with occurred error message
		SET @Info = '[Step2b1b_Mappings_Taxes_Map-02] ' + CAST(ERROR_NUMBER() as nvarchar) + ' - ' + ERROR_MESSAGE();

		-- send false to output
		RETURN 0;

	END CATCH

RETURN;
GO
PRINT N'Altering [dbo].[Step2c1_MappingProducts_FeedNewRules]...';


GO
/*
	This SP feeds Products Matching rules (ProdutosMatching) with new rules to be filled manually by user
	or automatic (specific to products matching) later in algorithm process.
*/


ALTER PROCEDURE [dbo].[Step2c1_MappingProducts_FeedNewRules]
	@Info nvarchar(256) OUTPUT
AS
	
	-- new rules feeding
	BEGIN TRY

		/*
			Feed (..)Matching table with new incomplete rules, to simplify mapping work to the user or to be automatically mapped later.
		*/
		INSERT [dbo].[ProdutosMatching] (FornecedorCodigo, ComplementoCodigo, Codigo, Descricao, MapTo, 
			   HorasValidadeCotacao, StockCodigoSubstituto, DispensaPrevencaoPrecosDesfasados, DispensaPrevencaoFalsoStock, DataReset, Notas,
			   Inativo, Criacao, Versao)

		SELECT um.FornecedorCodigo,
			   um.ComplementoCodigo, 
			   um.Codigo,
			   (
					-- get 1st existing description in CotacoesIncompletasMapeamentoProdutoView for this product
					SELECT TOP 1 CASE WHEN ci._Descricao IS NULL THEN '(vazio)'
									  ELSE ci._Descricao
								 END
					FROM [dbo].[CotacoesIncompletasMapeamentoProdutoView] ci
					WHERE ci.FornecedorCodigo = um.FornecedorCodigo
						  AND ci.ComplementoCodigo = um.ComplementoCodigo
						  AND ci._ProdutoCodigo = um.Codigo
				    ORDER BY ci._Descricao DESC  -- prevents the existence of some _Descricao = NULL
		      ) AS [Descricao],
			  NULL,		-- MapTo will be filled later by user or automatic next in the algorithm (specific to products)
			  NULL,		-- this null means that prevails the rules defined on CotacoesRegras. (to automatic set as inative all quotations for this supplier / product, set this value to -1)
			  NULL,		-- use this field if you want to specify a stock position directly to the product. this rule prevails to CotacoesRegras rules
			  CAST('false' as bit),	-- by default all products must be tested to offset prices.
			  CAST('false' as bit),	-- by default all products must be tested on FakeStock prevention
			  NULL,		-- Date to auto reset this custom definitions
			  NULL,
			  CAST('false' as bit),
			  GETDATE(),
			  GETDATE()
		FROM
			  (
					-- un-existing but needed matching rules
					SELECT DISTINCT ci.FornecedorCodigo, ci.ComplementoCodigo, ci._ProdutoCodigo AS Codigo
					FROM [dbo].[CotacoesIncompletasMapeamentoProdutoView] ci
					EXCEPT
					SELECT pm.FornecedorCodigo, pm.ComplementoCodigo, pm.Codigo
					FROM [dbo].[ProdutosMatching] pm
			  ) um



		-- fill output @info with sucess message
		SET @Info = '[Step2c1_MappingProducts_FeedNewRules-01] Number of created matching rules: ' + CAST(@@ROWCOUNT as nvarchar);

		-- send true to output
		RETURN 1;

	END TRY

	BEGIN CATCH
		-- fill output @info with occurred error message
		SET @Info = '[Step2c1_MappingProducts_FeedNewRules-02] ' + CAST(ERROR_NUMBER() as nvarchar) + ' - ' + ERROR_MESSAGE();

		-- send false to output
		RETURN 0;

	END CATCH

RETURN;
GO
PRINT N'Altering [dbo].[Step2c5_MappingProducts_Notifications1]...';


GO
/*
	Notifications SP: 1 of 3	(not ambiguous partnumbers)

	This SP makes sure that user is notified via CotacoesAvisos table, that something 
	wrong happened in the mapping task.
*/

ALTER PROCEDURE [dbo].[Step2c5_MappingProducts_Notifications1]
	@Info nvarchar(256) OUTPUT
AS
	
	-- insert notifications on CotacoesAvisos table
	BEGIN TRY

		/*
			Insert notifications rows for all incomplete quotations that remain unmapped
		*/
		INSERT INTO [dbo].[CotacoesAvisos] 
				    (Id, FornecedorCodigo, Data, _ProdutoCodigo, _ComplementoCodigo, AvisoTipoCodigo, Descricao, Criacao)

		SELECT NEWID(), 
			   ci.FornecedorCodigo,
			   ci.Data,
			   ci._ProdutoCodigo,
			   ci._ComplementoCodigo,
			   
			   CASE WHEN pm.Inativo = CAST('true' as bit) THEN 'CIPM1'															-- rule mapping inactive
			        WHEN pm.Inativo = CAST('false' as bit) AND f.ProdutosCriacaoAutomatica = CAST('false' as bit) THEN 'CIPM2'	-- supplier can not insert products..
					WHEN pm.Inativo = CAST('false' as bit) AND f.ProdutosMatchingAutomatico = CAST('false' as bit) THEN 'CIPM3'	-- supplier can not do automatic matching
					ELSE 'CIPM0'																								-- mapping rule is incomplete (misses MapTo)
			   END AS AvisoTipoCodigo,

			   'verifique configurações de matching!' AS Descricao,
			   GETDATE() AS Criacao

		-- consider again only quotations missing yet (after processing) ProdutoCodigo mapping.
		FROM [dbo].[CotacoesIncompletasMapeamentoProdutoView] ci
			 INNER JOIN [dbo].[ProdutosMatching] pm
				ON ci.FornecedorCodigo = pm.FornecedorCodigo
				   AND ci.ComplementoCodigo = pm.ComplementoCodigo
				   AND ci._ProdutoCodigo = pm.Codigo
			 INNER JOIN [dbo].[Fornecedores] f
				ON ci.FornecedorCodigo = f.Codigo

		-- consider only quotations not in Partnumbers ambiguous list
		WHERE ci.Partnumber NOT IN
			  (
				   SELECT Partnumber FROM [dbo].[PartnumbersAmbiguosView]
			  )




		-- fill output @info with sucess message
		SET @Info = '[Step2c5_MappingProducts_Notifications1-01] Number of inserted notifications: ' + CAST(@@ROWCOUNT as nvarchar);

		-- send true to output
		RETURN 1;

	END TRY

	BEGIN CATCH
		-- fill output @info with occurred error message
		SET @Info = '[Step2c5_MappingProducts_Notifications1-02] ' + CAST(ERROR_NUMBER() as nvarchar) + ' - ' + ERROR_MESSAGE();

		-- send false to output
		RETURN 0;

	END CATCH

RETURN;
GO
PRINT N'Altering [dbo].[Step2c5_MappingProducts_Notifications3]...';


GO
/*
	Notifications SP: 3 of 3   (inactive products)

	This SP makes sure that user is notified via CotacoesAvisos table, that althought the quotation is mapped
	the product record is inactive..
*/

ALTER PROCEDURE [dbo].[Step2c5_MappingProducts_Notifications3]
	@Info nvarchar(256) OUTPUT
AS
	
	-- insert notifications on CotacoesAvisos table
	BEGIN TRY

		/*
			Insert notifications rows for all inactive products with active quotations
		*/
		INSERT INTO [dbo].[CotacoesAvisos] 
				    (Id, FornecedorCodigo, Data, _ProdutoCodigo, _ComplementoCodigo, AvisoTipoCodigo, Descricao, Criacao)

		SELECT NEWID(), 
			   c.FornecedorCodigo,
			   c.Data,
			   c._ProdutoCodigo,
			   c._ComplementoCodigo,
			   'CIPM4',	-- product is configured as inative (not active)
			   'produto configurado como inativo mas com cotações ativas, verifque!' AS Descricao,
			   GETDATE() AS Criacao

		-- consider again only quotations missing yet (after processing) ProdutoCodigo mapping.
		FROM [dbo].[CotacoesAtivasView] c
			 INNER JOIN [dbo].[Produtos] p
				ON c.ProdutoCodigo = p.Codigo

		-- consider only quotations that are in Partnumbers ambiguous list
		WHERE p.Inativo = CAST('true' as bit)



		-- fill output @info with sucess message
		SET @Info = '[Step2c5_MappingProducts_Notifications3-01] Number of inserted notifications: ' + CAST(@@ROWCOUNT as nvarchar);

		-- send true to output
		RETURN 1;

	END TRY

	BEGIN CATCH
		-- fill output @info with occurred error message
		SET @Info = '[Step2c5_MappingProducts_Notifications3-02] ' + CAST(ERROR_NUMBER() as nvarchar) + ' - ' + ERROR_MESSAGE();

		-- send false to output
		RETURN 0;

	END CATCH

RETURN;
GO
PRINT N'Altering [dbo].[Step3a1_Preparation_ProductMatchingsReset]...';


GO
/*
	This SP, resets all Product Matching rules (ProdutosMatching table) to it's defaults when date on DataReset field is reached.
*/


ALTER PROCEDURE [dbo].[Step3a1_Preparation_ProductMatchingsReset]
	@Info nvarchar(256) OUTPUT
AS

	BEGIN TRY

		/*
			Reset to default Product Matching rules with DataReset date <= GETDATE()
		*/
		
		UPDATE pm

			-- restablish defaults
		SET pm.HorasValidadeCotacao = NULL,
		    pm.StockCodigoSubstituto = NULL,
			pm.DispensaPrevencaoPrecosDesfasados = CAST('false' as bit),
			
			-- if there are some notes already settled on row do not remove them (append text at begining)
			pm.Notas =
					CASE WHEN pm.Notas IS NULL THEN '!reset (' + CONVERT(varchar, GETDATE(), 120) + ')'
					     ELSE SUBSTRING('!reset (' + CONVERT(varchar, GETDATE(), 120) + ') | ' + pm.Notas, 1, 256)
					END,

			-- set DataReset to default to
			pm.DataReset = NULL,

			-- thats a new row version
			pm.Versao = GETDATE()


		/*  Join to Suppliers table is not necessary at the moment, but could make sense in future to retreive defaults from
			Supplier data
		*/
		FROM [dbo].[ProdutosMatching] pm
			 INNER JOIN [dbo].[Fornecedores] f
				   ON pm.FornecedorCodigo = f.Codigo

		-- filter all rules with a DataReset settled with a date <= today..
		WHERE pm.DataReset IS NOT NULL
			  AND pm.DataReset <= GETDATE()




		-- fill output @info with sucess message
		SET @Info = '[Step3a1_Preparation_ProductMatchingsReset-01] Number of ProductMatching rules reseted to default: ' + CAST(@@ROWCOUNT as nvarchar);

		-- send true to output
		RETURN 1;

	END TRY

	BEGIN CATCH
		-- fill output @info with occurred error message
		SET @Info = '[Step3a1_Preparation_ProductMatchingsReset-02] ' + CAST(ERROR_NUMBER() as nvarchar) + ' - ' + ERROR_MESSAGE();

		-- send false to output
		RETURN 0;

	END CATCH

RETURN;
GO
PRINT N'Altering [dbo].[Step3a2_Preparation_QuotationRulesReset]...';


GO
/*
	This SP, resets all Quotation Rules (CotacoesRegras table) to it's defaults when date on DataReset field is reached.
*/


ALTER PROCEDURE [dbo].[Step3a2_Preparation_QuotationRulesReset]
	@Info nvarchar(256) OUTPUT
AS

	BEGIN TRY

		/*
			Reset to default Quotation Rules with DataReset date <= GETDATE()
		*/
		
		UPDATE cr

			-- restablish defaults
		SET cr.HorasValidade = f.HorasValidadeSugestao,
			cr.StockCodigoSubstituto = NULL,
			
			-- if there are some notes already settled on row do not remove them (append text at begining)
			cr.Notas =
					CASE WHEN cr.Notas IS NULL THEN '!reset (' + CONVERT(varchar, GETDATE(), 120) + ')'
					     ELSE SUBSTRING('!reset (' + CONVERT(varchar, GETDATE(), 120) + ') | ' + cr.Notas, 1, 256)
					END,
		
			-- set DataReset to default to
			cr.DataReset = NULL,

			-- thats a new row version
			cr.Versao = GETDATE()


		FROM [dbo].[CotacoesRegras] cr
			 INNER JOIN [dbo].[Fornecedores] f
				   ON cr.FornecedorCodigo = f.Codigo

		-- filter all rules with a DataReset settled with a date <= today..
		WHERE cr.DataReset IS NOT NULL
			  AND cr.DataReset <= GETDATE()





		-- fill output @info with sucess message
		SET @Info = '[Step3a2_Preparation_QuotationRulesReset-01] Number of Quotation Rules reseted to default: ' + CAST(@@ROWCOUNT as nvarchar);

		-- send true to output
		RETURN 1;

	END TRY

	BEGIN CATCH
		-- fill output @info with occurred error message
		SET @Info = '[Step3a2_Preparation_QuotationRulesReset-02] ' + CAST(ERROR_NUMBER() as nvarchar) + ' - ' + ERROR_MESSAGE();

		-- send false to output
		RETURN 0;

	END CATCH

RETURN;
GO
PRINT N'Altering [dbo].[Step4a5_Finishing_ProductResurrection]...';


GO
/*
	This SP, set as not descontinued all descontinued products that back to have Actual Quotations (CotacoesAtuais).
	If a product no longer have quotations (CotacoesAtuais), that means that the product is been descontinued. Hoever, if it
	comes back having quotations later, the product must be ressurected..
*/


ALTER PROCEDURE [dbo].[Step4a5_Finishing_ProductResurrection]
	@Info nvarchar(256) OUTPUT
AS

	BEGIN TRY

		/*
			Set as ressurected (not descontinued) all descontinued products that have Actual Quotations (again).
		*/

		UPDATE p
		SET p.Descontinuado = CAST('false' as bit),
			p.Versao = GETDATE()

		FROM [dbo].[Produtos] p
		WHERE p.Inativo = CAST('false' as bit)
			  AND p.Descontinuado = CAST('true' as bit)
			  AND p.Codigo IN 
						  (
							   SELECT DISTINCT ProdutoCodigo FROM [dbo].[CotacoesAtuaisView]
						  )


		-- fill output @info with sucess message
		SET @Info = '[Step4a5_Finishing_ProductResurrection-01] Number of Resurrected Products: ' + CAST(@@ROWCOUNT as nvarchar);

		-- send true to output
		RETURN 1;

	END TRY

	BEGIN CATCH
		-- fill output @info with occurred error message
		SET @Info = '[Step4a5_Finishing_ProductResurrection-02] ' + CAST(ERROR_NUMBER() as nvarchar) + ' - ' + ERROR_MESSAGE();

		-- send false to output
		RETURN 0;

	END CATCH

RETURN;
GO
PRINT N'Altering [dbo].[Step4c1_Finishing_ProductsUpdate]...';


GO
/*
	This stored procedure will update Products table with recent processed information.
	This SP will use CotacoesVencedoras view to support product updating..
*/


ALTER PROCEDURE [dbo].[Step4c1_Finishing_ProductsUpdate]
	@Info nvarchar(256) OUTPUT
AS

	-- variables
	DECLARE @numberOfAffectedRows integer = 0;


	-- start a transaction scope
	BEGIN TRANSACTION


	BEGIN TRY

		/*
			Update Product information
		*/
		-- new day prices update (do update price history) (update prices if needed of products not updated today already)
		UPDATE p
		SET p.PrecoCusto_U3 = p.PrecoCusto_U2,
			p.PrecoCusto_U3Data = p.PrecoCusto_U2Data,
			p.PrecoCusto_U2 = p.PrecoCusto_U1,
			p.PrecoCusto_U2Data = p.PrecoCusto_U1Data,
			p.PrecoCusto_U1 = p.PrecoCusto,
			p.PrecoCusto_U1Data = p.PrecoCusto_Data,
			p.PrecoCusto = c.PrecoCusto,
			p.PrecoCusto_Data = CAST(GETDATE() AS DATE),
			p.Versao = GETDATE()

		FROM [dbo].[Produtos] p
			 INNER JOIN [dbo].[CotacoesVencedorasView] c
				   ON p.Codigo = c.ProdutoCodigo

		-- we want to update only different prices (product vs quotations) and last update date was not today..
		WHERE COALESCE(p.PrecoCusto, -999999999) <> c.PrecoCusto
			  AND COALESCE(p.PrecoCusto_Data, CAST('01-01-2000' as date)) <> CAST(GETDATE() AS DATE)


		-- sum to @numberOfAffectedRows
		SET @numberOfAffectedRows += @@ROWCOUNT;





		-- same day prices update (do NOT update price history)
		UPDATE p
		SET p.PrecoCusto = c.PrecoCusto,
			p.Versao = GETDATE()

		FROM [dbo].[Produtos] p
			 INNER JOIN [dbo].[CotacoesVencedorasView] c
				   ON p.Codigo = c.ProdutoCodigo

		-- we want to update only different prices (product vs quotations) and last update date was today..
		WHERE COALESCE(p.PrecoCusto, -999999999) <> c.PrecoCusto
			  AND COALESCE(p.PrecoCusto_Data, CAST('01-01-2000' as date)) = CAST(GETDATE() AS DATE)


		-- sum to @numberOfAffectedRows
		SET @numberOfAffectedRows += @@ROWCOUNT;





		-- new day stock update (do update stock history) (update stocks if needed of products not updated today already)
		UPDATE p
		SET p.StockCodigo_U3 = p.StockCodigo_U2,
			p.StockCodigo_U3Data = p.StockCodigo_U2Data,
			p.StockCodigo_U2 = p.StockCodigo_U1,
			p.StockCodigo_U2Data = p.StockCodigo_U1Data,
			p.StockCodigo_U1 = p.StockCodigo,
			p.StockCodigo_U1Data = p.StockCodigo_Data,
			p.StockCodigo = c.StockCodigoEfetivo,
			p.StockCodigo_Data = CAST(GETDATE() AS DATE),
			p.Versao = GETDATE()

		FROM [dbo].[Produtos] p
			 INNER JOIN [dbo].[CotacoesVencedorasView] c
				   ON p.Codigo = c.ProdutoCodigo

		-- we want to update only different stocks (product vs quotations) and last update date was not today..
		WHERE COALESCE(p.StockCodigo, '') <> c.StockCodigoEfetivo
			  AND COALESCE(p.StockCodigo_Data, CAST('01-01-2000' as date)) <> CAST(GETDATE() AS DATE)


		-- sum to @numberOfAffectedRows
		SET @numberOfAffectedRows += @@ROWCOUNT;





		-- same day stocks update (do NOT update stock history)
		UPDATE p
		SET p.StockCodigo = c.StockCodigoEfetivo,
			p.Versao = GETDATE()

		FROM [dbo].[Produtos] p
			 INNER JOIN [dbo].[CotacoesVencedorasView] c
				   ON p.Codigo = c.ProdutoCodigo

		-- we want to update only different stocks (product vs quotations) and last update date was today..
		WHERE COALESCE(p.StockCodigo, '') <> c.StockCodigoEfetivo
			  AND COALESCE(p.StockCodigo_Data, CAST('01-01-2000' as date)) = CAST(GETDATE() AS DATE)


		-- sum to @numberOfAffectedRows
		SET @numberOfAffectedRows += @@ROWCOUNT;





		-- update other fields of quotation
		UPDATE p
		SET p.Descricao = c.Descricao,
			p.Partnumber = c.Partnumber,
			p.FornecedorCodigo = c.FornecedorCodigo,
			p.Versao = GETDATE()

		FROM [dbo].[Produtos] p
			 INNER JOIN [dbo].[CotacoesVencedorasView] c
				   ON p.Codigo = c.ProdutoCodigo

		-- filter only records with info to be updated
		WHERE COALESCE(p.Descricao,'') <> c.Descricao
			  OR COALESCE(p.Partnumber, '') <> c.Partnumber
			  OR COALESCE(p.FornecedorCodigo, '') <> c.FornecedorCodigo


		-- sum to @numberOfAffectedRows
		SET @numberOfAffectedRows += @@ROWCOUNT;




		-- commit all changes
		COMMIT TRANSACTION

		-- fill output @info with sucess message
		SET @Info = '[Step4c1_Finishing_ProductsUpdate-01] Total of affected rows (one product could be updated by several instructions): ' + CAST(@numberOfAffectedRows as nvarchar);

		-- send true to output
		RETURN 1;

	END TRY

	BEGIN CATCH
		-- rollback transaction
		ROLLBACK TRANSACTION

		-- fill output @info with occurred error message
		SET @Info = '[Step4c1_Finishing_ProductsUpdate-02] ' + CAST(ERROR_NUMBER() as nvarchar) + ' - ' + ERROR_MESSAGE();

		-- send false to output
		RETURN 0;

	END CATCH

RETURN;
GO
PRINT N'Altering [dbo].[Step4c2_Finishing_ProductsDetailUpdate]...';


GO
/*
	This stored procedure will update Products Detail (ProdutosDetalhe) table with recent information.
*/


ALTER PROCEDURE [dbo].[Step4c2_Finishing_ProductsDetailUpdate]
	@Info nvarchar(256) OUTPUT
AS

	-- variables
	DECLARE @numberOfAffectedRows integer = 0;


	-- start a transaction scope
	BEGIN TRANSACTION


	BEGIN TRY

		/*
			Update Products Detail information
		*/
		

	
		-- set new content preocupation index (based on description and features from Quotations table - the new value..)
		UPDATE pd
		SET pd.IndicePreocupacaoConteudo = [dbo].[GetProdutoDetalheIndicePreocupacaoFunction](c.Descricao, c.Caracteristicas),
			pd.Versao = GETDATE()
		FROM [dbo].[ProdutosDetalhe] pd
			 INNER JOIN [dbo].[CotacoesAtuaisView] c
				   ON pd.FornecedorCodigo = c.FornecedorCodigo
					  AND pd.ProdutoCodigo = c.ProdutoCodigo
		-- process only rows that has changes on description or features..
		WHERE pd.AtualizacaoAutomaticaInativa = CAST('false' as bit)
			  AND (
					pd.Descricao <> c.Descricao
					OR pd.Caracteristicas <> c.Caracteristicas
				  )

		-- sum to @numberOfAffectedRows
		SET @numberOfAffectedRows += @@ROWCOUNT;





		-- description
		UPDATE pd
		SET pd.DescricaoPontuacao += 1,
			pd.Descricao = c.Descricao,
			pd.Versao = GETDATE()
		FROM [dbo].[ProdutosDetalhe] pd
			 INNER JOIN [dbo].[CotacoesAtuaisView] c
				   ON pd.FornecedorCodigo = c.FornecedorCodigo
					  AND pd.ProdutoCodigo = c.ProdutoCodigo
		-- process only rows that are settled to update automaticaly and need description update
		WHERE pd.AtualizacaoAutomaticaInativa = CAST('false' as bit)
			  AND pd.Descricao <> c.Descricao

		-- sum to @numberOfAffectedRows
		SET @numberOfAffectedRows += @@ROWCOUNT;





		-- features
		UPDATE pd
		SET pd.CaracteristicasPontuacao += 1,
			pd.Caracteristicas = c.Caracteristicas,
			pd.Versao = GETDATE()
		FROM [dbo].[ProdutosDetalhe] pd
			 INNER JOIN [dbo].[CotacoesAtuaisView] c
				   ON pd.FornecedorCodigo = c.FornecedorCodigo
					  AND pd.ProdutoCodigo = c.ProdutoCodigo
		-- process only rows that are settled to update automaticaly and need features update
		WHERE pd.AtualizacaoAutomaticaInativa = CAST('false' as bit)
			  AND pd.Caracteristicas <> c.Caracteristicas

		-- sum to @numberOfAffectedRows
		SET @numberOfAffectedRows += @@ROWCOUNT;




		-- link
		UPDATE pd
		SET pd.LinkPontuacao += 1,
			pd.Link = c.Link,
			pd.Versao = GETDATE()
		FROM [dbo].[ProdutosDetalhe] pd
			 INNER JOIN [dbo].[CotacoesAtuaisView] c
				   ON pd.FornecedorCodigo = c.FornecedorCodigo
					  AND pd.ProdutoCodigo = c.ProdutoCodigo
		-- process only rows that are settled to update automaticaly and need link update
		WHERE pd.AtualizacaoAutomaticaInativa = CAST('false' as bit)
			  AND pd.Link <> c.Link

		-- sum to @numberOfAffectedRows
		SET @numberOfAffectedRows += @@ROWCOUNT;




		-- image
		UPDATE pd
		SET pd.ImagemPontuacao += 1,
			pd.Imagem = c.Imagem,
			pd.Versao = GETDATE()
		FROM [dbo].[ProdutosDetalhe] pd
			 INNER JOIN [dbo].[CotacoesAtuaisView] c
				   ON pd.FornecedorCodigo = c.FornecedorCodigo
					  AND pd.ProdutoCodigo = c.ProdutoCodigo
		-- process only rows that are settled to update automaticaly and need image update
		WHERE pd.AtualizacaoAutomaticaInativa = CAST('false' as bit)
			  AND pd.Imagem <> c.Imagem

		-- sum to @numberOfAffectedRows
		SET @numberOfAffectedRows += @@ROWCOUNT;





		-- notify user manual update if needed
		UPDATE pd
		SET pd.AtualizacaoManualNecessaria = CAST('true' as bit),
			pd.Versao = GETDATE()
		FROM [dbo].[ProdutosDetalhe] pd
			 INNER JOIN [dbo].[CotacoesAtuaisView] c
				   ON pd.FornecedorCodigo = c.FornecedorCodigo
					  AND pd.ProdutoCodigo = c.ProdutoCodigo
		-- filter rows needing some update and configured to do not update automaticaly
		WHERE pd.AtualizacaoAutomaticaInativa = CAST('true' as bit)
			  AND (
					pd.Descricao <> c.Descricao
					OR pd.Caracteristicas <> c.Caracteristicas
					OR pd.Link <> c.Link
					OR pd.Imagem <> c.Imagem
				  )

		-- sum to @numberOfAffectedRows
		SET @numberOfAffectedRows += @@ROWCOUNT;



		-- commit all changes
		COMMIT TRANSACTION

		-- fill output @info with sucess message
		SET @Info = '[Step4c2_Finishing_ProductsDetailUpdate-01] Total of affected rows (one product detail could be updated by several instructions): ' + CAST(@numberOfAffectedRows as nvarchar);

		-- send true to output
		RETURN 1;

	END TRY

	BEGIN CATCH
		-- rollback transaction
		ROLLBACK TRANSACTION

		-- fill output @info with occurred error message
		SET @Info = '[Step4c2_Finishing_ProductsDetailUpdate-02] ' + CAST(ERROR_NUMBER() as nvarchar) + ' - ' + ERROR_MESSAGE();

		-- send false to output
		RETURN 0;

	END CATCH

RETURN;
GO
PRINT N'Altering [dbo].[SupplementInsert]...';


GO
ALTER PROCEDURE [SupplementInsert]
	@Codigo nvarchar(5),
	@Descricao nvarchar(50),
	@TermoAcrescentar nvarchar(50),
	@TermosRemover nvarchar(100),
	@Inativo bit
AS
	
	DECLARE @Criacao smalldatetime, @Versao datetime, @NumeroLinhasAfetadas int, @Erro nvarchar(255)

	SET @Criacao = GETDATE()
	SET @Versao = GETDATE()


	-- INSERÇÃO DO REGISTO
	BEGIN TRY
		 
		-- INICIA CONTAGEM DE @@ROWCOUNT (para quando usado o ExecuteNonQuery())
		SET NOCOUNT OFF

		-- INSERIR REGISTO
		INSERT INTO [dbo].[Complementos] ([Codigo], [Descricao], [TermoAcrescentar], [TermosRemover], [Inativo], [Criacao], [Versao]) 
					VALUES (@Codigo, @Descricao, @TermoAcrescentar, @TermosRemover, @Inativo, @Criacao, @Versao);
		
		SET @NumeroLinhasAfetadas = @@ROWCOUNT -- GUARDAR O NUMERO DE LINHAS AFETADAS

		-- ACABA CONTAGEM DE @@ROWCOUNT
		SET NOCOUNT ON

		-- RETORNAR O NUMERO DE LINHAS AFETADAS
		-- Quando usado o ExecuteNonQuery é o @@ROWCOUNT que é lido (SET NOCOUNT OFF/ON),  e não esta variável
		RETURN @NumeroLinhasAfetadas

	END TRY


	-- SE EXISTIRAM ERROS, DESFAZER TRANSACÇÃO
	BEGIN CATCH

		-- DISPARAR UM ERRO
		SET @Erro = '[WhereToBuy-I10] ' + ERROR_MESSAGE();
		RAISERROR (@Erro, 15, 1)
		RETURN 0

	END CATCH
GO
PRINT N'Altering [dbo].[SupplierInsert]...';


GO
ALTER PROCEDURE [dbo].[SupplierInsert]
	@Codigo nvarchar(5), 
	@Nome nvarchar(50), 
	@Morada nvarchar(200), 
	@CodigoPostal nvarchar(15),
	@LocalidadePostal nvarchar(50), 
	@Contribuinte nvarchar(20), 
	@Vendedor nvarchar(50), 
	@Telefone nvarchar(20), 
	@Telemovel nvarchar(15), 
	@SMS nvarchar(15), 
	@Email nvarchar(100), 
	@AcessoOnlineAtivo bit, 
	@Username nvarchar(20), 
	@Password nvarchar(20), 
	@HorasValidadeSugestao smallint, 
	@ProdutosMatchingAutomatico bit, 
	@ProdutosCriacaoAutomatica bit, 
	@DisponibilizaInfoProdutoDetalhe bit, 
	@DescricaoPontuacaoInicial smallint, 
	@CaracteristicasPontuacaoInicial smallint, 
	@LinkPontuacaoInicial smallint, 
	@ImagemPontuacaoInicial smallint, 
	@DescricaoSugereInativo bit, 
	@CaracteristicasSugereInativo bit, 
	@LinkSugereInativo bit, 
	@ImagemSugereInativo bit, 
	@AtualizacaoAutomaticaInativaSugestao bit, 
	@ProdutosConfiancaPreco float, 
	@ProdutosConfiancaDisponibilidade float, 
	@Inativo bit 

AS
	
	DECLARE @Criacao smalldatetime, @Versao datetime, @NumeroLinhasAfetadas int, @Erro nvarchar(255)

	SET @Criacao = GETDATE()
	SET @Versao = GETDATE()


	-- INSERÇÃO DO REGISTO
	BEGIN TRY
		 
		-- INICIA CONTAGEM DE @@ROWCOUNT (para quando usado o ExecuteNonQuery())
		SET NOCOUNT OFF

		-- INSERIR REGISTO
		INSERT INTO [dbo].[Fornecedores] ([Codigo], [Nome], [Morada], [CodigoPostal], [LocalidadePostal], [Contribuinte], 
											[Vendedor], [Telefone], [Telemovel], [SMS], [Email], [AcessoOnlineAtivo], 
											[Username], [Password], [HorasValidadeSugestao], [ProdutosMatchingAutomatico], 
											[ProdutosCriacaoAutomatica], [DisponibilizaInfoProdutoDetalhe], 
											[DescricaoPontuacaoInicial], [CaracteristicasPontuacaoInicial], 
											[LinkPontuacaoInicial], [ImagemPontuacaoInicial], [DescricaoSugereInativo], 
											[CaracteristicasSugereInativo], [LinkSugereInativo], [ImagemSugereInativo], 
											[AtualizacaoAutomaticaInativaSugestao], [ProdutosConfiancaPreco], 
											[ProdutosConfiancaDisponibilidade], [Inativo], [Criacao], [Versao])
 
					VALUES (@Codigo, @Nome, @Morada, @CodigoPostal, @LocalidadePostal, @Contribuinte, 
											@Vendedor, @Telefone, @Telemovel, @SMS, @Email, @AcessoOnlineAtivo, 
											@Username, @Password, @HorasValidadeSugestao, @ProdutosMatchingAutomatico, 
											@ProdutosCriacaoAutomatica, @DisponibilizaInfoProdutoDetalhe, 
											@DescricaoPontuacaoInicial, @CaracteristicasPontuacaoInicial, 
											@LinkPontuacaoInicial, @ImagemPontuacaoInicial, @DescricaoSugereInativo, 
											@CaracteristicasSugereInativo, @LinkSugereInativo, @ImagemSugereInativo, 
											@AtualizacaoAutomaticaInativaSugestao, @ProdutosConfiancaPreco, 
											@ProdutosConfiancaDisponibilidade, @Inativo, @Criacao, @Versao);

		
		SET @NumeroLinhasAfetadas = @@ROWCOUNT -- GUARDAR O NUMERO DE LINHAS AFETADAS

		-- ACABA CONTAGEM DE @@ROWCOUNT
		SET NOCOUNT ON

		-- RETORNAR O NUMERO DE LINHAS AFETADAS
		-- Quando usado o ExecuteNonQuery é o @@ROWCOUNT que é lido (SET NOCOUNT OFF/ON),  e não esta variável
		RETURN @NumeroLinhasAfetadas

	END TRY


	-- SE EXISTIRAM ERROS, DESFAZER TRANSACÇÃO
	BEGIN CATCH

		-- DISPARAR UM ERRO
		SET @Erro = '[WhereToBuy-I10] ' + ERROR_MESSAGE();
		RAISERROR (@Erro, 15, 1)
		RETURN 0

	END CATCH
GO
PRINT N'Altering [dbo].[TaxInsert]...';


GO
ALTER PROCEDURE [dbo].[TaxInsert]
	@Codigo nvarchar(5),
	@Descricao nvarchar(50),
	@DesignacaoFiscal nvarchar(50),
	@Taxa float,
	@Inativo bit
AS
	
	DECLARE @Criacao smalldatetime, @Versao datetime, @NumeroLinhasAfetadas int, @Erro nvarchar(255)

	SET @Criacao = GETDATE()
	SET @Versao = GETDATE()


	-- INSERÇÃO DO REGISTO
	BEGIN TRY
		 
		-- INICIA CONTAGEM DE @@ROWCOUNT (para quando usado o ExecuteNonQuery())
		SET NOCOUNT OFF

		-- INSERIR REGISTO
		INSERT INTO [dbo].[Impostos] ([Codigo], [Descricao], [DesignacaoFiscal], [Taxa], [Inativo], [Criacao], [Versao]) 
					VALUES (@Codigo, @Descricao, @DesignacaoFiscal, @Taxa, @Inativo, @Criacao, @Versao);
		
		SET @NumeroLinhasAfetadas = @@ROWCOUNT -- GUARDAR O NUMERO DE LINHAS AFETADAS

		-- ACABA CONTAGEM DE @@ROWCOUNT
		SET NOCOUNT ON

		-- RETORNAR O NUMERO DE LINHAS AFETADAS
		-- Quando usado o ExecuteNonQuery é o @@ROWCOUNT que é lido (SET NOCOUNT OFF/ON),  e não esta variável
		RETURN @NumeroLinhasAfetadas

	END TRY


	-- SE EXISTIRAM ERROS, DESFAZER TRANSACÇÃO
	BEGIN CATCH

		-- DISPARAR UM ERRO
		SET @Erro = '[WhereToBuy-I10] ' + ERROR_MESSAGE();
		RAISERROR (@Erro, 15, 1)
		RETURN 0

	END CATCH
GO
PRINT N'Altering [dbo].[UserInsert]...';


GO
ALTER PROCEDURE [dbo].[UserInsert]
	@Username nvarchar(20),
	@Password varbinary(64),
	@Nome nvarchar(50),
	@Email nvarchar(100),
	@Mobile nvarchar(15),
	@Sms nvarchar(15),
	@Administrador bit,
	@Inativo bit
AS
	
	DECLARE @Criacao smalldatetime, @Versao datetime, @NumeroLinhasAfetadas int, @Erro nvarchar(255)

	SET @Criacao = GETDATE()
	SET @Versao = GETDATE()


	-- INSERÇÃO DO REGISTO
	BEGIN TRY
		 
		-- INICIA CONTAGEM DE @@ROWCOUNT (para quando usado o ExecuteNonQuery())
		SET NOCOUNT OFF

		-- INSERIR REGISTO
		INSERT INTO [dbo].[Utilizadores] ([Username], [Password], [Nome], [Email], [Mobile], [Sms], [Administrador], [Inativo], [Criacao], [Versao]) 
					VALUES (@Username, HASHBYTES('SHA2_512', @Password), @Nome, @Email, @Mobile, @Sms, @Administrador, @Inativo, @Criacao, @Versao);
		
		SET @NumeroLinhasAfetadas = @@ROWCOUNT -- GUARDAR O NUMERO DE LINHAS AFETADAS

		-- ACABA CONTAGEM DE @@ROWCOUNT
		SET NOCOUNT ON

		-- RETORNAR O NUMERO DE LINHAS AFETADAS
		-- Quando usado o ExecuteNonQuery é o @@ROWCOUNT que é lido (SET NOCOUNT OFF/ON),  e não esta variável
		RETURN @NumeroLinhasAfetadas

	END TRY


	-- SE EXISTIRAM ERROS, DESFAZER TRANSACÇÃO
	BEGIN CATCH

		-- DISPARAR UM ERRO
		SET @Erro = '[WhereToBuy-I10] ' + ERROR_MESSAGE();
		RAISERROR (@Erro, 15, 1)
		RETURN 0

	END CATCH
GO
PRINT N'Altering [dbo].[WarningTypeInsert]...';


GO
ALTER PROCEDURE [dbo].[WarningTypeInsert]
	@Codigo nvarchar(5),
	@Descricao nvarchar(128),
	@Gravidade smallint,
	@Notas nvarchar(256),
	@Icon nvarchar(20),
	@Inativo bit
AS
	
	DECLARE @Criacao smalldatetime, @Versao datetime, @NumeroLinhasAfetadas int, @Erro nvarchar(255)

	SET @Criacao = GETDATE()
	SET @Versao = GETDATE()


	-- INSERÇÃO DO REGISTO
	BEGIN TRY
		 
		-- INICIA CONTAGEM DE @@ROWCOUNT (para quando usado o ExecuteNonQuery())
		SET NOCOUNT OFF

		-- INSERIR REGISTO
		INSERT INTO [dbo].[AvisosTipo] ([Codigo], [Descricao], [Gravidade], [Notas], [Icon], [Inativo], [Criacao], [Versao]) 
					VALUES (@Codigo, @Descricao, @Gravidade, @Notas, @Icon, @Inativo, @Criacao, @Versao);
		
		SET @NumeroLinhasAfetadas = @@ROWCOUNT -- GUARDAR O NUMERO DE LINHAS AFETADAS

		-- ACABA CONTAGEM DE @@ROWCOUNT
		SET NOCOUNT ON

		-- RETORNAR O NUMERO DE LINHAS AFETADAS
		-- Quando usado o ExecuteNonQuery é o @@ROWCOUNT que é lido (SET NOCOUNT OFF/ON),  e não esta variável
		RETURN @NumeroLinhasAfetadas

	END TRY


	-- SE EXISTIRAM ERROS, DESFAZER TRANSACÇÃO
	BEGIN CATCH

		-- DISPARAR UM ERRO
		SET @Erro = '[WhereToBuy-I10] ' + ERROR_MESSAGE();
		RAISERROR (@Erro, 15, 1)
		RETURN 0

	END CATCH
GO
PRINT N'Altering [dbo].[WorryingTermInsert]...';


GO
ALTER PROCEDURE [dbo].[WorryingTermInsert]
	@Termo nvarchar(50),
	@Indice tinyint,
	@Notas nvarchar(256),
	@Inativo bit
AS
	
	DECLARE @Criacao smalldatetime, @Versao datetime, @NumeroLinhasAfetadas int, @Erro nvarchar(255)

	SET @Criacao = GETDATE()
	SET @Versao = GETDATE()


	-- INSERÇÃO DO REGISTO
	BEGIN TRY
		 
		-- INICIA CONTAGEM DE @@ROWCOUNT (para quando usado o ExecuteNonQuery())
		SET NOCOUNT OFF

		-- INSERIR REGISTO
		INSERT INTO [dbo].[TermosPreocupantes] ([Termo], [Indice], [Notas], [Inativo], [Criacao], [Versao]) 
					VALUES (@Termo, @Indice, @Notas, @Inativo, @Criacao, @Versao);
		
		SET @NumeroLinhasAfetadas = @@ROWCOUNT -- GUARDAR O NUMERO DE LINHAS AFETADAS

		-- ACABA CONTAGEM DE @@ROWCOUNT
		SET NOCOUNT ON

		-- RETORNAR O NUMERO DE LINHAS AFETADAS
		-- Quando usado o ExecuteNonQuery é o @@ROWCOUNT que é lido (SET NOCOUNT OFF/ON),  e não esta variável
		RETURN @NumeroLinhasAfetadas

	END TRY


	-- SE EXISTIRAM ERROS, DESFAZER TRANSACÇÃO
	BEGIN CATCH

		-- DISPARAR UM ERRO
		SET @Erro = '[WhereToBuy-I10] ' + ERROR_MESSAGE();
		RAISERROR (@Erro, 15, 1)
		RETURN 0

	END CATCH
GO
PRINT N'Creating [dbo].[ClassCount]...';


GO
CREATE PROCEDURE [dbo].[ClassCount]
	@WhereClause nvarchar(512) = ''			-- ex1: Codigo IN ('001', '002'); ex2: Descricao LIKE '_este'; ex3: Descricao LIKE '%est%'
AS

	DECLARE @select nvarchar(1024), @where nvarchar(512), @sqlQuery nvarchar(2048)

	SET @select = 'SELECT Count([Codigo]) FROM [dbo].[Classes]' 

	SET @where = LTRIM(RTRIM(@WhereClause))
	IF Len(@where) > 0
	BEGIN
		SET @where = ' WHERE ' + @where
	END


	SET @sqlQuery = @select + @where


	EXEC(@sqlQuery)

RETURN  -- This SP must be used with ExecuteScalar
GO
PRINT N'Creating [dbo].[ClassDelete]...';


GO
CREATE PROCEDURE [dbo].[ClassDelete]
	@Codigo nvarchar(5),
	@Versao datetime
AS
	DECLARE @Erro nvarchar(255)


	-- VALIDAR SE O CODIGO EXISTE
	IF NOT EXISTS(SELECT [Codigo] FROM [dbo].[Classes] WHERE [Codigo] = @Codigo)
	BEGIN
		-- DISPARAR UM ERRO
		SET @Erro = '[WhereToBuy-D01] ' + 'O registo que pretende eliminar não existe!';
		RAISERROR (@Erro, 15, 1)
		RETURN 0
	END

	-- VALIDAR SE A VERSÃO AINDA É A MESMA
	IF NOT EXISTS(SELECT [Codigo] FROM [dbo].[Classes] WHERE [Codigo] = @Codigo AND [Versao] = @Versao)
	BEGIN
		-- DISPARAR UM ERRO
		SET @Erro = '[WhereToBuy-D02] ' + 'O registo que pretende eliminar, já foi alterado desde que o abriu!';
		RAISERROR (@Erro, 15, 1)
		RETURN 0
	END


	-- TUDO OK PARA SEGUIR EM FRENTE
	DECLARE @NumeroLinhasAfetadas int


	-- ELIMINAR O REGISTO
	BEGIN TRY

		-- INICIA CONTAGEM DE @@ROWCOUNT (para quando usado o ExecuteNonQuery())
		SET NOCOUNT OFF
		 
		-- ELIMINAR REGISTO
		DELETE FROM [dbo].[Classes] Where [Codigo] = @Codigo

		SET @NumeroLinhasAfetadas = @@ROWCOUNT -- GUARDAR O NUMERO DE LINHAS AFETADAS

		-- ACABA CONTAGEM DE @@ROWCOUNT
		SET NOCOUNT ON

		-- RETORNAR O NUMERO DE LINHAS AFETADAS
		-- Quando usado o ExecuteNonQuery é o @@ROWCOUNT que é lido (SET NOCOUNT OFF/ON), e não esta variável
		RETURN @NumeroLinhasAfetadas

	END TRY


	-- SE EXISTIRAM ERROS
	BEGIN CATCH
		
		-- DISPARAR UM ERRO
		SET @Erro = '[WhereToBuy-D10] ' + ERROR_MESSAGE();
		RAISERROR (@Erro, 15, 1)
		RETURN 0

	END CATCH
GO
PRINT N'Creating [dbo].[ClasseInsert]...';


GO
CREATE PROCEDURE [dbo].[ClasseInsert]
	@Codigo nvarchar(5),
	@Descricao nvarchar(50),
	@CatalogoCodigo nvarchar(20),
	@Margem float,
	@MargemValorMinimo decimal(14,4),
	@Notas nvarchar(256),
	@Inativo bit
AS
	
	DECLARE @Criacao smalldatetime, @Versao datetime, @NumeroLinhasAfetadas int, @Erro nvarchar(255)

	SET @Criacao = GETDATE()
	SET @Versao = GETDATE()


	-- INSERÇÃO DO REGISTO
	BEGIN TRY
		 
		-- INICIA CONTAGEM DE @@ROWCOUNT (para quando usado o ExecuteNonQuery())
		SET NOCOUNT OFF

		-- INSERIR REGISTO
		INSERT INTO [dbo].[Classes] ([Codigo], [Descricao], [CatalogoCodigo], [Margem], [MargemValorMinimo], [Notas], [Inativo], [Criacao], [Versao]) 
					VALUES (@Codigo, @Descricao, @CatalogoCodigo, @Margem, @MargemValorMinimo, @Notas, @Inativo, @Criacao, @Versao);
		
		SET @NumeroLinhasAfetadas = @@ROWCOUNT -- GUARDAR O NUMERO DE LINHAS AFETADAS

		-- ACABA CONTAGEM DE @@ROWCOUNT
		SET NOCOUNT ON

		-- RETORNAR O NUMERO DE LINHAS AFETADAS
		-- Quando usado o ExecuteNonQuery é o @@ROWCOUNT que é lido (SET NOCOUNT OFF/ON),  e não esta variável
		RETURN @NumeroLinhasAfetadas

	END TRY


	-- SE EXISTIRAM ERROS, DESFAZER TRANSACÇÃO
	BEGIN CATCH

		-- DISPARAR UM ERRO
		SET @Erro = '[WhereToBuy-I10] ' + ERROR_MESSAGE();
		RAISERROR (@Erro, 15, 1)
		RETURN 0

	END CATCH
GO
PRINT N'Creating [dbo].[ClassSelect]...';


GO
CREATE PROCEDURE [dbo].[ClassSelect]
	@WhereClause nvarchar(1024) = '',			-- ex1: Codigo IN ('001', '002'); ex2: Descricao LIKE '_este'; ex3: Descricao LIKE '%est%'
	@OrderByClause nvarchar(256) = ''			-- ex: Codigo desc
AS
	
	DECLARE @select nvarchar(2048), @where nvarchar(1024), @orderBy nvarchar(256), @sqlQuery nvarchar(4000)
	

	SET @select = 'SELECT classes.[Codigo], classes.[Descricao], classes.[CatalogoCodigo], catalogoDescricao.[Descricao] as CatalogoDescricao, 
					classes.[Margem], classes.[MargemValorMinimo], classes.[Notas], classes.[Inativo], classes.[Criacao], classes.[Versao]				
						FROM [dbo].[Classes] classes 
					INNER JOIN [dbo].[Catalogos] catalogos
						ON classes.[CatalogoCodigo] = catalogos.[Codigo]' 
	

	SET @where = LTRIM(RTRIM(@WhereClause))
	IF Len(@where) > 0
	BEGIN
		SET @where = ' WHERE ' + @where
	END


	SET @orderBy = LTRIM(RTRIM(@OrderByClause))
	IF LEN(@orderBy) > 0
	BEGIN
		SET @orderBy = ' ORDER BY ' + @orderBy
	END


	SET @sqlQuery = @select + @where + @orderBy  


	EXEC(@sqlQuery)


RETURN @@ROWCOUNT
GO
PRINT N'Creating [dbo].[ClassUpdate]...';


GO
CREATE PROCEDURE [dbo].[ClassUpdate]
	@Codigo nvarchar(5),
	@Descricao nvarchar(50),
	@CatalogoCodigo nvarchar(20),
	@Margem float,
	@MargemValorMinimo decimal(14,4),
	@Notas nvarchar(256),
	@Inativo bit,
	@Versao datetime
AS

	DECLARE @Erro nvarchar(255)


	-- VALIDAR SE O REGISTO EXISTE
	IF NOT EXISTS(SELECT [Codigo] FROM [dbo].[Classes] WHERE [Codigo] = @Codigo)
	BEGIN
		-- DISPARAR UM ERRO
		SET @Erro = '[WhereToBuy-U01] ' + 'O registo que pretende alterar não existe!';
		RAISERROR (@Erro, 15, 1)
		RETURN 0
	END

	-- VALIDAR SE A VERSÃO AINDA É A MESMA
	IF NOT EXISTS(SELECT [Codigo] FROM [dbo].[Classes] WHERE [Codigo] = @Codigo AND [Versao] = @Versao)
	BEGIN
		-- DISPARAR UM ERRO
		SET @Erro = '[WhereToBuy-U02] ' + 'O registo que pretende alterar, já foi alterado desde que o abriu!';
		RAISERROR (@Erro, 15, 1)
		RETURN 0
	END


	-- TUDO OK PARA SEGUIR EM FRENTE
	DECLARE @NovaVersao datetime, @NumeroLinhasAfetadas int

	SET @NovaVersao = GETDATE()


	-- ALTERAÇÃO DO REGISTO
	BEGIN TRY

		-- INICIA CONTAGEM DE @@ROWCOUNT (para quando usado o ExecuteNonQuery())
		SET NOCOUNT OFF

		-- ALTERAR REGISTO
		UPDATE [dbo].[Classes] SET [Descricao] = @Descricao,
									[CatalogoCodigo] = @CatalogoCodigo, 
									[Margem] = @Margem, 
									[MargemValorMinimo] = @MargemValorMinimo,
									[Notas] = @Notas,
									[Inativo] = @Inativo,
									[Versao] = @NovaVersao
								WHERE [Codigo] = @Codigo

		SET @NumeroLinhasAfetadas = @@ROWCOUNT -- GUARDAR O NUMERO DE LINHAS AFETADAS

		-- ACABA CONTAGEM DE @@ROWCOUNT
		SET NOCOUNT ON

		-- RETORNAR O NUMERO DE LINHAS AFETADAS
		-- Quando usado o ExecuteNonQuery é o @@ROWCOUNT que é lido (SET NOCOUNT OFF/ON), e não esta variável
		RETURN @NumeroLinhasAfetadas

	END TRY


	-- SE EXISTIRAM ERROS
	BEGIN CATCH

		-- DISPARAR UM ERRO
		SET @Erro = '[WhereToBuy-U10] ' + ERROR_MESSAGE();
		RAISERROR (@Erro, 15, 1)
		RETURN 0

	END CATCH
GO
PRINT N'Refreshing [dbo].[Step4a1_Preparation_Notifications]...';


GO
EXECUTE sp_refreshsqlmodule N'[dbo].[Step4a1_Preparation_Notifications]';


GO
PRINT N'Refreshing [dbo].[Step4a2_Preparation_OtherFieldsRefresh]...';


GO
EXECUTE sp_refreshsqlmodule N'[dbo].[Step4a2_Preparation_OtherFieldsRefresh]';


GO
PRINT N'Refreshing [dbo].[Step2d1_Normalization_OtherFieldsFulfillment]...';


GO
EXECUTE sp_refreshsqlmodule N'[dbo].[Step2d1_Normalization_OtherFieldsFulfillment]';


GO
PRINT N'Refreshing [dbo].[Step4a4_Finishing_ProductDescontinuation]...';


GO
EXECUTE sp_refreshsqlmodule N'[dbo].[Step4a4_Finishing_ProductDescontinuation]';


GO
PRINT N'Refreshing [dbo].[Step4b5_Cautions_IrregularAmplitude_Notifications]...';


GO
EXECUTE sp_refreshsqlmodule N'[dbo].[Step4b5_Cautions_IrregularAmplitude_Notifications]';


GO
PRINT N'Refreshing [dbo].[Step4b6_Cautions_IrregularAmplitude_Execution]...';


GO
EXECUTE sp_refreshsqlmodule N'[dbo].[Step4b6_Cautions_IrregularAmplitude_Execution]';


GO
PRINT N'Refreshing [dbo].[Step4b3_Cautions_OutOfInterval_Notifications]...';


GO
EXECUTE sp_refreshsqlmodule N'[dbo].[Step4b3_Cautions_OutOfInterval_Notifications]';


GO
PRINT N'Refreshing [dbo].[Step4b4_Cautions_OutOfInterval_Execution]...';


GO
EXECUTE sp_refreshsqlmodule N'[dbo].[Step4b4_Cautions_OutOfInterval_Execution]';


GO
PRINT N'Refreshing [dbo].[Step1a1_DeleteIncompleteAndNotIntegratedExistingQuotations]...';


GO
EXECUTE sp_refreshsqlmodule N'[dbo].[Step1a1_DeleteIncompleteAndNotIntegratedExistingQuotations]';


GO
PRINT N'Refreshing [dbo].[Step2b1c_Mappings_Addons_Notifications]...';


GO
EXECUTE sp_refreshsqlmodule N'[dbo].[Step2b1c_Mappings_Addons_Notifications]';


GO
PRINT N'Refreshing [dbo].[Step2b1c_Mappings_Brands_Notifications]...';


GO
EXECUTE sp_refreshsqlmodule N'[dbo].[Step2b1c_Mappings_Brands_Notifications]';


GO
PRINT N'Refreshing [dbo].[Step2b1c_Mappings_Categories_Notifications]...';


GO
EXECUTE sp_refreshsqlmodule N'[dbo].[Step2b1c_Mappings_Categories_Notifications]';


GO
PRINT N'Refreshing [dbo].[Step2b1c_Mappings_Statuses_Notifications]...';


GO
EXECUTE sp_refreshsqlmodule N'[dbo].[Step2b1c_Mappings_Statuses_Notifications]';


GO
PRINT N'Refreshing [dbo].[Step2b1c_Mappings_Stocks_Notifications]...';


GO
EXECUTE sp_refreshsqlmodule N'[dbo].[Step2b1c_Mappings_Stocks_Notifications]';


GO
PRINT N'Refreshing [dbo].[Step2b1c_Mappings_Taxes_Notifications]...';


GO
EXECUTE sp_refreshsqlmodule N'[dbo].[Step2b1c_Mappings_Taxes_Notifications]';


GO
PRINT N'Refreshing [dbo].[Step2b1z_QuotationRules_FeedNewRules]...';


GO
EXECUTE sp_refreshsqlmodule N'[dbo].[Step2b1z_QuotationRules_FeedNewRules]';


GO
PRINT N'Refreshing [dbo].[Step2d2_Normalization_SetComplete]...';


GO
EXECUTE sp_refreshsqlmodule N'[dbo].[Step2d2_Normalization_SetComplete]';


GO
PRINT N'Refreshing [dbo].[Step2c4_MappingProducts_Map]...';


GO
EXECUTE sp_refreshsqlmodule N'[dbo].[Step2c4_MappingProducts_Map]';


GO
PRINT N'Refreshing [dbo].[Step2c5_MappingProducts_Notifications2]...';


GO
EXECUTE sp_refreshsqlmodule N'[dbo].[Step2c5_MappingProducts_Notifications2]';


GO
PRINT N'Refreshing [dbo].[Step2c2_MappingProducts_InsertNewProducts]...';


GO
EXECUTE sp_refreshsqlmodule N'[dbo].[Step2c2_MappingProducts_InsertNewProducts]';


GO
PRINT N'Refreshing [dbo].[Step2c3_MappingProducts_FillMapTo]...';


GO
EXECUTE sp_refreshsqlmodule N'[dbo].[Step2c3_MappingProducts_FillMapTo]';


GO
/*
Post-Deployment Script Template							
--------------------------------------------------------------------------------------
 This file contains SQL statements that will be appended to the build script.		
 Use SQLCMD syntax to include a file in the post-deployment script.			
 Example:      :r .\myfile.sql								
 Use SQLCMD syntax to reference a variable in the post-deployment script.		
 Example:      :setvar TableName MyTable							
               SELECT * FROM [$(TableName)]					
--------------------------------------------------------------------------------------
*/


/* IMPOSTOS */
IF NOT EXISTS(SELECT [Codigo] FROM [dbo].[Impostos])
BEGIN	
	INSERT INTO [dbo].[Impostos] ([Codigo], [Descricao], [DesignacaoFiscal], [Taxa], [Inativo], [Criacao], [Versao])
		VALUES ('PT.23', 'IVA PT Continental - Taxa Normal de 23%', 'IVA PT.Continental 23%', 23.00, CAST('false' AS bit), GETDATE(), GETDATE())
END


/* COMPLEMENTOS */
IF NOT EXISTS(SELECT [Codigo] FROM [dbo].[Complementos])
BEGIN	
	INSERT INTO [dbo].[Complementos] ([Codigo], [Descricao], [TermoAcrescentar], [TermosRemover], [Inativo], [Criacao], [Versao])
		VALUES ('N/A', 'Não aplicável', NULL, NULL, CAST('false' AS bit), GETDATE(), GETDATE())
END


/* AVISOSTIPO */
IF NOT EXISTS(SELECT [Codigo] FROM [dbo].[AvisosTipo])
BEGIN	
	INSERT INTO [dbo].[AvisosTipo] ([Codigo], [Descricao], [Gravidade], [Notas], [Icon], [Inativo], [Criacao], [Versao])
		 VALUES ('PFS', 'Prevenção Falso Stock', 3, NULL, NULL, CAST('false' AS bit), GETDATE(), GETDATE()),
				('IAPD1', 'Inativação Administrativa (Prevenção Preço Desfazado - Preco fora do intervalo)', 7, NULL, NULL, CAST('false' AS bit), GETDATE(), GETDATE()),
				('IAPD2', 'Inativação Administrativa (Prevenção Preço Desfazado - Amplitude do preço excedida)', 7, NULL, NULL, CAST('false' AS bit), GETDATE(), GETDATE()),
				
				('CICM0', 'Cotação Incompleta [Complemento] (mapeamento incompleto, preenchimento manual necessário)', 6, NULL, NULL, CAST('false' AS bit), GETDATE(), GETDATE()),
				('CICM1', 'Cotação Incompleta [Complemento] (mapeamento inativo)', 2, NULL, NULL, CAST('false' AS bit), GETDATE(), GETDATE()),
				('CIMM0', 'Cotação Incompleta [Marca] (mapeamento incompleto, preenchimento manual necessário)', 6, NULL, NULL, CAST('false' AS bit), GETDATE(), GETDATE()),
				('CIMM1', 'Cotação Incompleta [Marca] (mapeamento inativo)', 2, NULL, NULL, CAST('false' AS bit), GETDATE(), GETDATE()),
				('CITM0', 'Cotação Incompleta [Categoria] (mapeamento incompleto, preenchimento manual necessário)', 6, NULL, NULL, CAST('false' AS bit), GETDATE(), GETDATE()),
				('CITM1', 'Cotação Incompleta [Categoria] (mapeamento inativo)', 2, NULL, NULL, CAST('false' AS bit), GETDATE(), GETDATE()),
				('CISM0', 'Cotação Incompleta [Stock] (mapeamento incompleto, preenchimento manual necessário)', 6, NULL, NULL, CAST('false' AS bit), GETDATE(), GETDATE()),
				('CISM1', 'Cotação Incompleta [Stock] (mapeamento inativo)', 6, NULL, NULL, CAST('false' AS bit), GETDATE(), GETDATE()),
				('CIIM0', 'Cotação Incompleta [Imposto] (mapeamento incompleto, preenchimento manual necessário)', 6, NULL, NULL, CAST('false' AS bit), GETDATE(), GETDATE()),
				('CIIM1', 'Cotação Incompleta [Imposto] (mapeamento inativo)', 2, NULL, NULL, CAST('false' AS bit), GETDATE(), GETDATE()),
				('CIDM0', 'Cotação Incompleta [Estado] (mapeamento incompleto, preenchimento manual necessário)', 6, NULL, NULL, CAST('false' AS bit), GETDATE(), GETDATE()),
				('CIDM1', 'Cotação Incompleta [Estado] (mapeamento inativo)', 2, NULL, NULL, CAST('false' AS bit), GETDATE(), GETDATE()),
				('CIPM0', 'Cotação Incompleta [Produto] (mapeamento incompleto, preenchimento manual necessário)', 6, NULL, NULL, CAST('false' AS bit), GETDATE(), GETDATE()),
				('CIPM1', 'Cotação Incompleta [Produto] (mapeamento inativo)', 2, NULL, NULL, CAST('false' AS bit), GETDATE(), GETDATE()),
				('CIPM2', 'Cotação Incompleta [Produto] (fornecedor configurado para não criar automaticamente fichas de produtos)', 6, NULL, NULL, CAST('false' AS bit), GETDATE(), GETDATE()),
				('CIPM3', 'Cotação Incompleta [Produto] (fornecedor configurado para não mapear automaticamente produtos)', 6, NULL, NULL, CAST('false' AS bit), GETDATE(), GETDATE()),
				('CIPM4', 'Cotação Incompleta [Produto] (produto inativo)', 2, NULL, NULL, CAST('false' AS bit), GETDATE(), GETDATE()),
				('CIPM9', 'Cotação Incompleta [Produto] (ambiguidade detetada com outro partnumber de outra marca)', 8, NULL, NULL, CAST('false' AS bit), GETDATE(), GETDATE()),

				('CAC01', 'Cotação Atuais, atualização de Preço de Custo (CotacoesRegras, ProdutosMatching)', 4, NULL, NULL, CAST('false' AS bit), GETDATE(), GETDATE()),
				('CAC02', 'Cotação Atuais, atualização da formula do Preço de Custo', 2, NULL, NULL, CAST('false' AS bit), GETDATE(), GETDATE()),
				('CAC03', 'Cotação Atuais, atualização de Validade (CotacoesRegras, ProdutosMatching)', 4, NULL, NULL, CAST('false' AS bit), GETDATE(), GETDATE()),
				('CAC04', 'Cotação Atuais, atualização da formula de calculo da Validade', 2, NULL, NULL, CAST('false' AS bit), GETDATE(), GETDATE()),
				('CAC05', 'Cotação Atuais, atualização da descrição do produto', 4, NULL, NULL, CAST('false' AS bit), GETDATE(), GETDATE()),
				('CAC06', 'Cotação Atuais, atualização das caracteristicas do produto', 4, NULL, NULL, CAST('false' AS bit), GETDATE(), GETDATE()),
				('CAC07', 'Cotação Atuais, atualização do link do produto', 4, NULL, NULL, CAST('false' AS bit), GETDATE(), GETDATE()),
				('CAC08', 'Cotação Atuais, atualização da imagem do produto', 4, NULL, NULL, CAST('false' AS bit), GETDATE(), GETDATE()),
				('CAC09', 'Cotação Atuais, atualização do código substituto de stock (CotacoesRegras, ProdutosMatching)', 4, NULL, NULL, CAST('false' AS bit), GETDATE(), GETDATE()),
				('CAC10', 'Cotação Atuais, atualização da justificação de alteração do código substituto', 2, NULL, NULL, CAST('false' AS bit), GETDATE(), GETDATE())

END



/* STOCKS */
IF NOT EXISTS(SELECT [Codigo] FROM [dbo].[Stocks])
BEGIN	
	INSERT INTO [dbo].[Stocks] ([Codigo], [Descricao], [DisponibilidadeNivel], [Notas], [Inativo], [Criacao], [Versao])
		 VALUES ('D-5','Indisponivel permanentemente', -5, NULL, CAST('false' AS bit), GETDATE(), GETDATE()),
				('D-4','Indisponivel sob encomenda (dias entrega: +40)', -4, NULL, CAST('false' AS bit), GETDATE(), GETDATE()),
				('D-3','Indisponivel sob encomenda (dias entrega: +25)', -3, NULL, CAST('false' AS bit), GETDATE(), GETDATE()),
				('D-2','Indisponivel sob encomenda (dias entrega: +10)', -2, NULL, CAST('false' AS bit), GETDATE(), GETDATE()),
				('D-1','Indisponivel sob encomenda (dias entrega: +6)', -1, NULL, CAST('false' AS bit), GETDATE(), GETDATE()),
				('D+0','Indisponivel momentaneamente (dias entrega: +2)', 0, NULL, CAST('false' AS bit), GETDATE(), GETDATE()),
				('D+1','Disponivel, stock reduzido', 1, NULL, CAST('false' AS bit), GETDATE(), GETDATE()),
				('D+2','Disponivel, stock limitado', 2, NULL, CAST('false' AS bit), GETDATE(), GETDATE()),
				('D+3','Disponivel, stock normal', 3, NULL, CAST('false' AS bit), GETDATE(), GETDATE()),
				('D+4','Disponivel, stock abundante', 4, NULL, CAST('false' AS bit), GETDATE(), GETDATE()),
				('D+5','Disponivel permanentemente', 5, NULL, CAST('false' AS bit), GETDATE(), GETDATE())
END




/* FORNECEDORES */
IF NOT EXISTS(SELECT [Codigo] FROM [dbo].[Fornecedores])
BEGIN	
	INSERT INTO [dbo].[Fornecedores]
			   ([Codigo], [Nome], [Morada], [CodigoPostal], [LocalidadePostal], [Contribuinte], 
				[Vendedor], [Telefone], [Telemovel], [SMS], [Email], [AcessoOnlineAtivo], [Username], [Password],
				[HorasValidadeSugestao], [ProdutosMatchingAutomatico], [ProdutosCriacaoAutomatica], [DisponibilizaInfoProdutoDetalhe],
				[DescricaoPontuacaoInicial], [CaracteristicasPontuacaoInicial], [LinkPontuacaoInicial], [ImagemPontuacaoInicial],
				[DescricaoSugereInativo], [CaracteristicasSugereInativo], [LinkSugereInativo], [ImagemSugereInativo],
				[AtualizacaoAutomaticaInativaSugestao], [ProdutosConfiancaPreco], [ProdutosConfiancaDisponibilidade],
				[Inativo], [Criacao], [Versao])
		 VALUES
			   ('00024', 'CPC - Companhia Portuguesa de Computadores..', 'Rua Monte dos Pipos, 649', '4460-059', 'Guifões', '999999990',
				'Susana', '222333444', '939949959', '969979989', 'susana@cpcdi.pt', CAST('false' AS bit), 'cpc001', 'cpcpass',
				24, CAST('true' AS bit), CAST('true' AS bit), CAST('true' AS bit),
				5, 5, 5, 5,
				CAST('false' AS bit), CAST('false' AS bit), CAST('false' AS bit), CAST('false' AS bit),
				CAST('false' AS bit), 90, 90,
				CAST('false' AS bit), GETDATE(), GETDATE())
END



/* ESTADOS */
IF NOT EXISTS(SELECT [Codigo] FROM [dbo].[Estados])
BEGIN	
	INSERT INTO [dbo].[Estados] ([Codigo], [Descricao], [Inativo], [Criacao], [Versao])
		VALUES ('NOVO', 'Produto novo (nunca usado)', CAST('false' AS bit), GETDATE(), GETDATE()),
			   ('PROMO', 'Produto em promoção', CAST('false' AS bit), GETDATE(), GETDATE()),
			   ('USADO', 'Produto usado', CAST('false' AS bit), GETDATE(), GETDATE()),
			   ('OPORT', 'Oportunidade', CAST('false' AS bit), GETDATE(), GETDATE()),
			   ('GOPOR', 'Grande oportunidade', CAST('false' AS bit), GETDATE(), GETDATE())
END




/* TERMOSPREOCUPANTES */
IF NOT EXISTS(SELECT [Termo] FROM [dbo].[TermosPreocupantes])
BEGIN	
	INSERT INTO [dbo].[TermosPreocupantes] ([Termo], [Indice] ,[Notas], [Inativo], [Criacao], [Versao])
		VALUES ('%[ ]saldo[ ]%', 6, '', CAST('false' AS bit), GETDATE(), GETDATE()),
			   ('%[ ]promo%', 6, '', CAST('false' AS bit), GETDATE(), GETDATE()),
			   ('%<a[ ]%', 7, '', CAST('false' AS bit), GETDATE(), GETDATE()),
			   ('%[< |<| ]script[ ]%', 9, '', CAST('false' AS bit), GETDATE(), GETDATE()),
			   ('%[ ]href[ =]%', 7, '', CAST('false' AS bit), GETDATE(), GETDATE()),
			   ('%<br%', 7, '', CAST('false' AS bit), GETDATE(), GETDATE())
			  
END
GO

GO
PRINT N'Update complete.';


GO
