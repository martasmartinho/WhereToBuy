/*
Deployment script for WhereToBuy

This code was generated by a tool.
Changes to this file may cause incorrect behavior and will be lost if
the code is regenerated.
*/

GO
SET ANSI_NULLS, ANSI_PADDING, ANSI_WARNINGS, ARITHABORT, CONCAT_NULL_YIELDS_NULL, QUOTED_IDENTIFIER ON;

SET NUMERIC_ROUNDABORT OFF;


GO
:setvar DatabaseName "WhereToBuy"
:setvar DefaultFilePrefix "WhereToBuy"
:setvar DefaultDataPath "C:\Program Files\Microsoft SQL Server\MSSQL12.MSSQLSERVER\MSSQL\DATA\"
:setvar DefaultLogPath "C:\Program Files\Microsoft SQL Server\MSSQL12.MSSQLSERVER\MSSQL\DATA\"

GO
:on error exit
GO
/*
Detect SQLCMD mode and disable script execution if SQLCMD mode is not supported.
To re-enable the script after enabling SQLCMD mode, execute the following:
SET NOEXEC OFF; 
*/
:setvar __IsSqlCmdEnabled "True"
GO
IF N'$(__IsSqlCmdEnabled)' NOT LIKE N'True'
    BEGIN
        PRINT N'SQLCMD mode must be enabled to successfully execute this script.';
        SET NOEXEC ON;
    END


GO
USE [master];


GO

IF (DB_ID(N'$(DatabaseName)') IS NOT NULL) 
BEGIN
    ALTER DATABASE [$(DatabaseName)]
    SET SINGLE_USER WITH ROLLBACK IMMEDIATE;
    DROP DATABASE [$(DatabaseName)];
END

GO
PRINT N'Creating $(DatabaseName)...'
GO
CREATE DATABASE [$(DatabaseName)]
    ON 
    PRIMARY(NAME = [$(DatabaseName)], FILENAME = N'$(DefaultDataPath)$(DefaultFilePrefix)_Primary.mdf')
    LOG ON (NAME = [$(DatabaseName)_log], FILENAME = N'$(DefaultLogPath)$(DefaultFilePrefix)_Primary.ldf') COLLATE SQL_Latin1_General_CP1_CI_AS
GO
IF EXISTS (SELECT 1
           FROM   [master].[dbo].[sysdatabases]
           WHERE  [name] = N'$(DatabaseName)')
    BEGIN
        ALTER DATABASE [$(DatabaseName)]
            SET ANSI_NULLS ON,
                ANSI_PADDING ON,
                ANSI_WARNINGS ON,
                ARITHABORT ON,
                CONCAT_NULL_YIELDS_NULL ON,
                NUMERIC_ROUNDABORT OFF,
                QUOTED_IDENTIFIER ON,
                ANSI_NULL_DEFAULT ON,
                CURSOR_DEFAULT LOCAL,
                RECOVERY FULL,
                CURSOR_CLOSE_ON_COMMIT OFF,
                AUTO_CREATE_STATISTICS ON,
                AUTO_SHRINK OFF,
                AUTO_UPDATE_STATISTICS ON,
                RECURSIVE_TRIGGERS OFF 
            WITH ROLLBACK IMMEDIATE;
        ALTER DATABASE [$(DatabaseName)]
            SET AUTO_CLOSE OFF 
            WITH ROLLBACK IMMEDIATE;
    END


GO
IF EXISTS (SELECT 1
           FROM   [master].[dbo].[sysdatabases]
           WHERE  [name] = N'$(DatabaseName)')
    BEGIN
        ALTER DATABASE [$(DatabaseName)]
            SET ALLOW_SNAPSHOT_ISOLATION OFF;
    END


GO
IF EXISTS (SELECT 1
           FROM   [master].[dbo].[sysdatabases]
           WHERE  [name] = N'$(DatabaseName)')
    BEGIN
        ALTER DATABASE [$(DatabaseName)]
            SET READ_COMMITTED_SNAPSHOT OFF 
            WITH ROLLBACK IMMEDIATE;
    END


GO
IF EXISTS (SELECT 1
           FROM   [master].[dbo].[sysdatabases]
           WHERE  [name] = N'$(DatabaseName)')
    BEGIN
        ALTER DATABASE [$(DatabaseName)]
            SET AUTO_UPDATE_STATISTICS_ASYNC OFF,
                PAGE_VERIFY NONE,
                DATE_CORRELATION_OPTIMIZATION OFF,
                DISABLE_BROKER,
                PARAMETERIZATION SIMPLE,
                SUPPLEMENTAL_LOGGING OFF 
            WITH ROLLBACK IMMEDIATE;
    END


GO
IF IS_SRVROLEMEMBER(N'sysadmin') = 1
    BEGIN
        IF EXISTS (SELECT 1
                   FROM   [master].[dbo].[sysdatabases]
                   WHERE  [name] = N'$(DatabaseName)')
            BEGIN
                EXECUTE sp_executesql N'ALTER DATABASE [$(DatabaseName)]
    SET TRUSTWORTHY OFF,
        DB_CHAINING OFF 
    WITH ROLLBACK IMMEDIATE';
            END
    END
ELSE
    BEGIN
        PRINT N'The database settings cannot be modified. You must be a SysAdmin to apply these settings.';
    END


GO
IF IS_SRVROLEMEMBER(N'sysadmin') = 1
    BEGIN
        IF EXISTS (SELECT 1
                   FROM   [master].[dbo].[sysdatabases]
                   WHERE  [name] = N'$(DatabaseName)')
            BEGIN
                EXECUTE sp_executesql N'ALTER DATABASE [$(DatabaseName)]
    SET HONOR_BROKER_PRIORITY OFF 
    WITH ROLLBACK IMMEDIATE';
            END
    END
ELSE
    BEGIN
        PRINT N'The database settings cannot be modified. You must be a SysAdmin to apply these settings.';
    END


GO
ALTER DATABASE [$(DatabaseName)]
    SET TARGET_RECOVERY_TIME = 0 SECONDS 
    WITH ROLLBACK IMMEDIATE;


GO
IF EXISTS (SELECT 1
           FROM   [master].[dbo].[sysdatabases]
           WHERE  [name] = N'$(DatabaseName)')
    BEGIN
        ALTER DATABASE [$(DatabaseName)]
            SET FILESTREAM(NON_TRANSACTED_ACCESS = OFF),
                CONTAINMENT = NONE 
            WITH ROLLBACK IMMEDIATE;
    END


GO
IF EXISTS (SELECT 1
           FROM   [master].[dbo].[sysdatabases]
           WHERE  [name] = N'$(DatabaseName)')
    BEGIN
        ALTER DATABASE [$(DatabaseName)]
            SET AUTO_CREATE_STATISTICS ON(INCREMENTAL = OFF),
                MEMORY_OPTIMIZED_ELEVATE_TO_SNAPSHOT = OFF,
                DELAYED_DURABILITY = DISABLED 
            WITH ROLLBACK IMMEDIATE;
    END


GO
USE [$(DatabaseName)];


GO
IF fulltextserviceproperty(N'IsFulltextInstalled') = 1
    EXECUTE sp_fulltext_database 'enable';


GO
/*
 Pre-Deployment Script Template							
--------------------------------------------------------------------------------------
 This file contains SQL statements that will be executed before the build script.	
 Use SQLCMD syntax to include a file in the pre-deployment script.			
 Example:      :r .\myfile.sql								
 Use SQLCMD syntax to reference a variable in the pre-deployment script.		
 Example:      :setvar TableName MyTable							
               SELECT * FROM [$(TableName)]					
--------------------------------------------------------------------------------------
*/
-- cria a base de dados se não exstir ainda
IF NOT EXISTS(SELECT [Name] FROM [SYS].[DATABASES] WHERE [Name] = 'WhereToBuy')
BEGIN
	CREATE DATABASE WhereToBuy COLLATE LATIN1_GENERAL_CI_AS	-- ATENÇÃO QUE TEM TAMBÉM QUE SE ALTERAR A COLLATION NAS PROPRIEDADES DESTE PROJETO
END		
GO

GO
PRINT N'Creating [dbo].[AvisosTipo]...';


GO
CREATE TABLE [dbo].[AvisosTipo] (
    [Codigo]    NVARCHAR (5)   NOT NULL,
    [Descricao] NVARCHAR (128) NOT NULL,
    [Gravidade] SMALLINT       NOT NULL,
    [Notas]     NVARCHAR (256) NULL,
    [Icon]      NVARCHAR (20)  NULL,
    [Inativo]   BIT            NOT NULL,
    [Criacao]   SMALLDATETIME  NOT NULL,
    [Versao]    DATETIME       NOT NULL,
    CONSTRAINT [PK_AvisosTipo] PRIMARY KEY CLUSTERED ([Codigo] ASC)
);


GO
PRINT N'Creating [dbo].[Catalogos]...';


GO
CREATE TABLE [dbo].[Catalogos] (
    [Codigo]    NVARCHAR (20)  NOT NULL,
    [Descricao] NVARCHAR (50)  NOT NULL,
    [Notas]     NVARCHAR (256) NULL,
    [Inativo]   BIT            NOT NULL,
    [Criacao]   SMALLDATETIME  NOT NULL,
    [Versao]    DATETIME       NOT NULL,
    CONSTRAINT [PK_Catalogos] PRIMARY KEY CLUSTERED ([Codigo] ASC)
);


GO
PRINT N'Creating [dbo].[Categorias]...';


GO
CREATE TABLE [dbo].[Categorias] (
    [Codigo]               NVARCHAR (20)   NOT NULL,
    [Descricao]            NVARCHAR (50)   NOT NULL,
    [PesoMedioUnidade]     FLOAT (53)      NOT NULL,
    [PrecoMinimoPermitido] DECIMAL (14, 4) NOT NULL,
    [PrecoMaximoPermitido] DECIMAL (14, 4) NOT NULL,
    [PrecoAmplitudeMax]    FLOAT (53)      NOT NULL,
    [Confianca]            FLOAT (53)      NOT NULL,
    [Inativo]              BIT             NOT NULL,
    [Criacao]              SMALLDATETIME   NOT NULL,
    [Versao]               DATETIME        NOT NULL,
    CONSTRAINT [PK_Categorias] PRIMARY KEY CLUSTERED ([Codigo] ASC)
);


GO
PRINT N'Creating [dbo].[CategoriasMatching]...';


GO
CREATE TABLE [dbo].[CategoriasMatching] (
    [FornecedorCodigo] NVARCHAR (5)   NOT NULL,
    [Codigo]           NVARCHAR (128) NOT NULL,
    [Descricao]        NVARCHAR (128) NOT NULL,
    [MapTo]            NVARCHAR (20)  NULL,
    [Inativo]          BIT            NOT NULL,
    [Criacao]          SMALLDATETIME  NOT NULL,
    [Versao]           DATETIME       NOT NULL,
    CONSTRAINT [PK_CategoriasMatching] PRIMARY KEY CLUSTERED ([FornecedorCodigo] ASC, [Codigo] ASC)
);


GO
PRINT N'Creating [dbo].[Classes]...';


GO
CREATE TABLE [dbo].[Classes] (
    [Codigo]            NVARCHAR (20)   NOT NULL,
    [Descricao]         NVARCHAR (50)   NOT NULL,
    [CatalogoCodigo]    NVARCHAR (20)   NOT NULL,
    [Margem]            FLOAT (53)      NOT NULL,
    [MargemValorMinimo] DECIMAL (14, 4) NOT NULL,
    [Notas]             NVARCHAR (256)  NULL,
    [Inativo]           BIT             NOT NULL,
    [Criacao]           SMALLDATETIME   NOT NULL,
    [Versao]            DATETIME        NOT NULL,
    CONSTRAINT [PK_Classes] PRIMARY KEY CLUSTERED ([Codigo] ASC)
);


GO
PRINT N'Creating [dbo].[ClassesCategorias]...';


GO
CREATE TABLE [dbo].[ClassesCategorias] (
    [ClasseCodigo]    NVARCHAR (20)  NOT NULL,
    [CategoriaCodigo] NVARCHAR (20)  NOT NULL,
    [Notas]           NVARCHAR (256) NULL,
    [Versao]          DATETIME       NOT NULL,
    CONSTRAINT [PK_ClassesCategorias] PRIMARY KEY CLUSTERED ([ClasseCodigo] ASC, [CategoriaCodigo] ASC)
);


GO
PRINT N'Creating [dbo].[Complementos]...';


GO
CREATE TABLE [dbo].[Complementos] (
    [Codigo]           NVARCHAR (5)   NOT NULL,
    [Descricao]        NVARCHAR (50)  NOT NULL,
    [TermoAcrescentar] NVARCHAR (50)  NULL,
    [TermosRemover]    NVARCHAR (100) NULL,
    [Inativo]          BIT            NOT NULL,
    [Criacao]          SMALLDATETIME  NOT NULL,
    [Versao]           DATETIME       NOT NULL,
    CONSTRAINT [PK_Complementos] PRIMARY KEY CLUSTERED ([Codigo] ASC)
);


GO
PRINT N'Creating [dbo].[ComplementosMatching]...';


GO
CREATE TABLE [dbo].[ComplementosMatching] (
    [FornecedorCodigo] NVARCHAR (5)   NOT NULL,
    [Codigo]           NVARCHAR (128) NOT NULL,
    [Descricao]        NVARCHAR (128) NOT NULL,
    [MapTo]            NVARCHAR (5)   NULL,
    [Inativo]          BIT            NOT NULL,
    [Criacao]          SMALLDATETIME  NOT NULL,
    [Versao]           DATETIME       NOT NULL,
    CONSTRAINT [PK_ComplementosMatching] PRIMARY KEY CLUSTERED ([FornecedorCodigo] ASC, [Codigo] ASC)
);


GO
PRINT N'Creating [dbo].[Cotacoes]...';


GO
CREATE TABLE [dbo].[Cotacoes] (
    [FornecedorCodigo]                  NVARCHAR (5)    NOT NULL,
    [Data]                              DATETIME        NOT NULL,
    [_ProdutoCodigo]                    NVARCHAR (256)  NOT NULL,
    [_ComplementoCodigo]                NVARCHAR (128)  NOT NULL,
    [_ComplementoDescricao]             NVARCHAR (128)  NOT NULL,
    [_Partnumber]                       NVARCHAR (25)   NOT NULL,
    [_MarcaCodigo]                      NVARCHAR (128)  NOT NULL,
    [_MarcaDescricao]                   NVARCHAR (128)  NOT NULL,
    [_CategoriaCodigo]                  NVARCHAR (128)  NOT NULL,
    [_CategoriaDescricao]               NVARCHAR (128)  NOT NULL,
    [_StockCodigo]                      NVARCHAR (128)  NOT NULL,
    [_StockDescricao]                   NVARCHAR (128)  NOT NULL,
    [_ImpostoCodigo]                    NVARCHAR (128)  NOT NULL,
    [_ImpostoDescricao]                 NVARCHAR (128)  NOT NULL,
    [_EstadoCodigo]                     NVARCHAR (128)  NOT NULL,
    [_EstadoDescricao]                  NVARCHAR (128)  NOT NULL,
    [_Descricao]                        NVARCHAR (256)  NOT NULL,
    [_Link]                             NVARCHAR (1024) NOT NULL,
    [_Caracteristicas]                  NVARCHAR (2048) NOT NULL,
    [_Imagem]                           NVARCHAR (1024) NOT NULL,
    [_Preco]                            DECIMAL (14, 4) NOT NULL,
    [_OutrosCustos]                     DECIMAL (14, 4) NOT NULL,
    [_OutrosCustosDescricao]            NVARCHAR (128)  NOT NULL,
    [_Validade]                         SMALLDATETIME   NOT NULL,
    [_ValidadeDescricao]                NVARCHAR (128)  NOT NULL,
    [ComplementoCodigo]                 NVARCHAR (5)    NULL,
    [Partnumber]                        NVARCHAR (25)   NULL,
    [MarcaCodigo]                       NVARCHAR (5)    NULL,
    [CategoriaCodigo]                   NVARCHAR (20)   NULL,
    [StockCodigo]                       NVARCHAR (5)    NULL,
    [StockCodigoSubstituto]             NVARCHAR (5)    NULL,
    [StockCodigoSubstitutoJustificacao] NVARCHAR (256)  NULL,
    [ImpostoCodigo]                     NVARCHAR (5)    NULL,
    [EstadoCodigo]                      NVARCHAR (5)    NULL,
    [Descricao]                         NVARCHAR (256)  NULL,
    [Link]                              NVARCHAR (1024) NULL,
    [Caracteristicas]                   NVARCHAR (2048) NULL,
    [Imagem]                            NVARCHAR (1024) NULL,
    [PrecoCusto]                        DECIMAL (14, 4) NULL,
    [PrecoCustoFormula]                 NVARCHAR (256)  NULL,
    [Validade]                          SMALLDATETIME   NULL,
    [ValidadeFormula]                   NVARCHAR (256)  NULL,
    [ProdutoCodigo]                     NVARCHAR (40)   NULL,
    [Completo]                          BIT             NOT NULL,
    [Integrado]                         BIT             NOT NULL,
    [Inativo]                           BIT             NOT NULL,
    [Versao]                            DATETIME        NOT NULL,
    CONSTRAINT [PK_Cotacoes] PRIMARY KEY CLUSTERED ([FornecedorCodigo] ASC, [Data] ASC, [_ProdutoCodigo] ASC, [_ComplementoCodigo] ASC)
);


GO
PRINT N'Creating [dbo].[CotacoesAvisos]...';


GO
CREATE TABLE [dbo].[CotacoesAvisos] (
    [Id]                 UNIQUEIDENTIFIER NOT NULL,
    [Data]               SMALLDATETIME    NOT NULL,
    [_ProdutoCodigo]     NVARCHAR (256)   NOT NULL,
    [_ComplementoCodigo] NVARCHAR (128)   NOT NULL,
    [FornecedorCodigo]   NVARCHAR (5)     NOT NULL,
    [AvisoTipoCodigo]    NVARCHAR (5)     NOT NULL,
    [Descricao]          NVARCHAR (2048)  NOT NULL,
    [Criacao]            SMALLDATETIME    NOT NULL,
    CONSTRAINT [PK_CotacoesAvisos] PRIMARY KEY CLUSTERED ([Id] ASC),
    CONSTRAINT [UC_CotacoesAvisos] UNIQUE NONCLUSTERED ([FornecedorCodigo] ASC, [Data] ASC, [_ProdutoCodigo] ASC, [_ComplementoCodigo] ASC, [AvisoTipoCodigo] ASC)
);


GO
PRINT N'Creating [dbo].[CotacoesRegras]...';


GO
CREATE TABLE [dbo].[CotacoesRegras] (
    [FornecedorCodigo]      NVARCHAR (5)   NOT NULL,
    [MarcaCodigo]           NVARCHAR (5)   NOT NULL,
    [CategoriaCodigo]       NVARCHAR (20)  NOT NULL,
    [StockCodigo]           NVARCHAR (5)   NOT NULL,
    [HorasValidade]         SMALLINT       NOT NULL,
    [StockCodigoSubstituto] NVARCHAR (5)   NULL,
    [DataReset]             SMALLDATETIME  NULL,
    [Notas]                 NVARCHAR (256) NULL,
    [Versao]                DATETIME       NOT NULL,
    CONSTRAINT [PK_CotacoesRegras] PRIMARY KEY CLUSTERED ([FornecedorCodigo] ASC, [MarcaCodigo] ASC, [CategoriaCodigo] ASC, [StockCodigo] ASC)
);


GO
PRINT N'Creating [dbo].[Estados]...';


GO
CREATE TABLE [dbo].[Estados] (
    [Codigo]    NVARCHAR (5)  NOT NULL,
    [Descricao] NVARCHAR (50) NOT NULL,
    [Inativo]   BIT           NOT NULL,
    [Criacao]   SMALLDATETIME NOT NULL,
    [Versao]    DATETIME      NOT NULL,
    CONSTRAINT [PK_Estados] PRIMARY KEY CLUSTERED ([Codigo] ASC)
);


GO
PRINT N'Creating [dbo].[EstadosMatching]...';


GO
CREATE TABLE [dbo].[EstadosMatching] (
    [FornecedorCodigo] NVARCHAR (5)   NOT NULL,
    [Codigo]           NVARCHAR (128) NOT NULL,
    [Descricao]        NVARCHAR (128) NOT NULL,
    [MapTo]            NVARCHAR (5)   NULL,
    [Inativo]          BIT            NOT NULL,
    [Criacao]          SMALLDATETIME  NOT NULL,
    [Versao]           DATETIME       NOT NULL,
    CONSTRAINT [PK_EstadosMatching] PRIMARY KEY CLUSTERED ([FornecedorCodigo] ASC, [Codigo] ASC)
);


GO
PRINT N'Creating [dbo].[Fornecedores]...';


GO
CREATE TABLE [dbo].[Fornecedores] (
    [Codigo]                               NVARCHAR (5)   NOT NULL,
    [Nome]                                 NVARCHAR (50)  NOT NULL,
    [Morada]                               NVARCHAR (200) NOT NULL,
    [CodigoPostal]                         NVARCHAR (15)  NOT NULL,
    [LocalidadePostal]                     NVARCHAR (50)  NOT NULL,
    [Contribuinte]                         NVARCHAR (20)  NOT NULL,
    [Vendedor]                             NVARCHAR (50)  NULL,
    [Telefone]                             NVARCHAR (20)  NULL,
    [Telemovel]                            NVARCHAR (15)  NOT NULL,
    [SMS]                                  NVARCHAR (15)  NOT NULL,
    [Email]                                NVARCHAR (100) NOT NULL,
    [AcessoOnlineAtivo]                    BIT            NOT NULL,
    [Username]                             NVARCHAR (20)  NOT NULL,
    [Password]                             NVARCHAR (20)  NOT NULL,
    [HorasValidadeSugestao]                SMALLINT       NOT NULL,
    [ProdutosMatchingAutomatico]           BIT            NOT NULL,
    [ProdutosCriacaoAutomatica]            BIT            NOT NULL,
    [DisponibilizaInfoProdutoDetalhe]      BIT            NOT NULL,
    [DescricaoPontuacaoInicial]            SMALLINT       NOT NULL,
    [CaracteristicasPontuacaoInicial]      SMALLINT       NOT NULL,
    [LinkPontuacaoInicial]                 SMALLINT       NOT NULL,
    [ImagemPontuacaoInicial]               SMALLINT       NOT NULL,
    [DescricaoSugereInativo]               BIT            NOT NULL,
    [CaracteristicasSugereInativo]         BIT            NOT NULL,
    [LinkSugereInativo]                    BIT            NOT NULL,
    [ImagemSugereInativo]                  BIT            NOT NULL,
    [AtualizacaoAutomaticaInativaSugestao] BIT            NOT NULL,
    [ProdutosConfiancaPreco]               FLOAT (53)     NOT NULL,
    [ProdutosConfiancaDisponibilidade]     FLOAT (53)     NOT NULL,
    [Inativo]                              BIT            NOT NULL,
    [Criacao]                              SMALLDATETIME  NOT NULL,
    [Versao]                               DATETIME       NOT NULL,
    CONSTRAINT [PK_Fornecedores] PRIMARY KEY CLUSTERED ([Codigo] ASC)
);


GO
PRINT N'Creating [dbo].[FornecedoresMarcas]...';


GO
CREATE TABLE [dbo].[FornecedoresMarcas] (
    [FornecedorCodigo] NVARCHAR (5)   NOT NULL,
    [MarcaCodigo]      NVARCHAR (5)   NOT NULL,
    [Confianca]        FLOAT (53)     NOT NULL,
    [Notas]            NVARCHAR (260) NULL,
    [Versao]           DATETIME       NOT NULL,
    CONSTRAINT [PK_FornecedoresMarcas] PRIMARY KEY CLUSTERED ([FornecedorCodigo] ASC, [MarcaCodigo] ASC)
);


GO
PRINT N'Creating [dbo].[Grupos]...';


GO
CREATE TABLE [dbo].[Grupos] (
    [Codigo]    NVARCHAR (20) NOT NULL,
    [Descricao] NVARCHAR (50) NOT NULL,
    [Inativo]   BIT           NOT NULL,
    [Criacao]   SMALLDATETIME NOT NULL,
    [Versao]    DATETIME      NOT NULL,
    CONSTRAINT [PK_Grupos] PRIMARY KEY CLUSTERED ([Codigo] ASC)
);


GO
PRINT N'Creating [dbo].[Idiomas]...';


GO
CREATE TABLE [dbo].[Idiomas] (
    [Codigo]    NVARCHAR (5)  NOT NULL,
    [Descricao] NVARCHAR (50) NOT NULL,
    [Inativo]   BIT           NOT NULL,
    [Criacao]   SMALLDATETIME NOT NULL,
    [Versao]    DATETIME      NOT NULL,
    CONSTRAINT [PK_Idiomas] PRIMARY KEY CLUSTERED ([Codigo] ASC)
);


GO
PRINT N'Creating [dbo].[Impostos]...';


GO
CREATE TABLE [dbo].[Impostos] (
    [Codigo]           NVARCHAR (5)  NOT NULL,
    [Descricao]        NVARCHAR (50) NOT NULL,
    [DesignacaoFiscal] NVARCHAR (50) NOT NULL,
    [Taxa]             FLOAT (53)    NOT NULL,
    [Inativo]          BIT           NOT NULL,
    [Criacao]          SMALLDATETIME NOT NULL,
    [Versao]           DATETIME      NOT NULL,
    CONSTRAINT [PK_Impostos] PRIMARY KEY CLUSTERED ([Codigo] ASC)
);


GO
PRINT N'Creating [dbo].[ImpostosMatching]...';


GO
CREATE TABLE [dbo].[ImpostosMatching] (
    [FornecedorCodigo] NVARCHAR (5)   NOT NULL,
    [Codigo]           NVARCHAR (128) NOT NULL,
    [Descricao]        NVARCHAR (128) NOT NULL,
    [MapTo]            NVARCHAR (5)   NULL,
    [Inativo]          BIT            NOT NULL,
    [Criacao]          SMALLDATETIME  NOT NULL,
    [Versao]           DATETIME       NOT NULL,
    CONSTRAINT [PK_ImpostosMatching] PRIMARY KEY CLUSTERED ([FornecedorCodigo] ASC, [Codigo] ASC)
);


GO
PRINT N'Creating [dbo].[IndicesConfiancaMarcaFornecedor]...';


GO
CREATE TABLE [dbo].[IndicesConfiancaMarcaFornecedor] (
    [FornecedorCodigo] NVARCHAR (5)   NOT NULL,
    [MarcaCodigo]      NVARCHAR (5)   NOT NULL,
    [Notas]            NVARCHAR (256) NULL,
    [Versao]           DATETIME       NOT NULL,
    CONSTRAINT [PK_IndicesConfiancaMarcaFornecedor] PRIMARY KEY CLUSTERED ([FornecedorCodigo] ASC, [MarcaCodigo] ASC)
);


GO
PRINT N'Creating [dbo].[Marcas]...';


GO
CREATE TABLE [dbo].[Marcas] (
    [Codigo]    NVARCHAR (5)  NOT NULL,
    [Descricao] NVARCHAR (50) NOT NULL,
    [Inativo]   BIT           NOT NULL,
    [Criacao]   SMALLDATETIME NOT NULL,
    [Versao]    DATETIME      NOT NULL,
    CONSTRAINT [PK_Marcas] PRIMARY KEY CLUSTERED ([Codigo] ASC)
);


GO
PRINT N'Creating [dbo].[MarcasMatching]...';


GO
CREATE TABLE [dbo].[MarcasMatching] (
    [FornecedorCodigo] NVARCHAR (5)   NOT NULL,
    [Codigo]           NVARCHAR (128) NOT NULL,
    [Descricao]        NVARCHAR (128) NOT NULL,
    [MapTo]            NVARCHAR (5)   NULL,
    [Inativo]          BIT            NOT NULL,
    [Criacao]          SMALLDATETIME  NOT NULL,
    [Versao]           DATETIME       NOT NULL,
    CONSTRAINT [PK_MarcasMatching] PRIMARY KEY CLUSTERED ([FornecedorCodigo] ASC, [Codigo] ASC)
);


GO
PRINT N'Creating [dbo].[Produtos]...';


GO
CREATE TABLE [dbo].[Produtos] (
    [Codigo]             NVARCHAR (40)   NOT NULL,
    [Descricao]          NVARCHAR (256)  NOT NULL,
    [Partnumber]         NVARCHAR (25)   NOT NULL,
    [CategoriaCodigo]    NVARCHAR (20)   NOT NULL,
    [MarcaCodigo]        NVARCHAR (5)    NOT NULL,
    [ImpostoCodigo]      NVARCHAR (5)    NOT NULL,
    [FornecedorCodigo]   NVARCHAR (5)    NOT NULL,
    [PrecoCusto]         DECIMAL (14, 4) NULL,
    [PrecoCusto_Data]    SMALLDATETIME   NULL,
    [PrecoCusto_U1]      DECIMAL (14, 4) NULL,
    [PrecoCusto_U1Data]  SMALLDATETIME   NULL,
    [PrecoCusto_U2]      DECIMAL (14, 4) NULL,
    [PrecoCusto_U2Data]  SMALLDATETIME   NULL,
    [PrecoCusto_U3]      DECIMAL (14, 4) NULL,
    [PrecoCusto_U3Data]  SMALLDATETIME   NULL,
    [StockCodigo]        NVARCHAR (5)    NULL,
    [StockCodigo_Data]   SMALLDATETIME   NULL,
    [StockCodigo_U1]     NVARCHAR (5)    NULL,
    [StockCodigo_U1Data] SMALLDATETIME   NULL,
    [StockCodigo_U2]     NVARCHAR (5)    NULL,
    [StockCodigo_U2Data] SMALLDATETIME   NULL,
    [StockCodigo_U3]     NVARCHAR (5)    NULL,
    [StockCodigo_U3Data] SMALLDATETIME   NULL,
    [Descontinuado]      BIT             NOT NULL,
    [Inativo]            BIT             NOT NULL,
    [Criacao]            SMALLDATETIME   NOT NULL,
    [Versao]             DATETIME        NOT NULL,
    CONSTRAINT [PK_Produtos] PRIMARY KEY CLUSTERED ([Codigo] ASC)
);


GO
PRINT N'Creating [dbo].[ProdutosDetalhe]...';


GO
CREATE TABLE [dbo].[ProdutosDetalhe] (
    [ProdutoCodigo]                NVARCHAR (40)   NOT NULL,
    [FornecedorCodigo]             NVARCHAR (5)    NOT NULL,
    [Descricao]                    NVARCHAR (256)  NOT NULL,
    [DescricaoPontuacao]           SMALLINT        NOT NULL,
    [DescricaoInativa]             BIT             NOT NULL,
    [Caracteristicas]              NVARCHAR (2048) NOT NULL,
    [CaracteristicasPontuacao]     SMALLINT        NOT NULL,
    [CaracteristicasInativas]      BIT             NOT NULL,
    [Link]                         NVARCHAR (1024) NOT NULL,
    [LinkPontuacao]                SMALLINT        NOT NULL,
    [LinkInativo]                  BIT             NOT NULL,
    [Imagem]                       NVARCHAR (1024) NOT NULL,
    [ImagemPontuacao]              SMALLINT        NOT NULL,
    [ImagemInativa]                BIT             NOT NULL,
    [AtualizacaoAutomaticaInativa] BIT             NOT NULL,
    [AtualizacaoManualNecessaria]  BIT             NOT NULL,
    [IndicePreocupacaoConteudo]    TINYINT         NOT NULL,
    [Criacao]                      SMALLDATETIME   NOT NULL,
    [Versao]                       DATETIME        NOT NULL,
    CONSTRAINT [PK_ProdutosDetalhe] PRIMARY KEY CLUSTERED ([ProdutoCodigo] ASC, [FornecedorCodigo] ASC)
);


GO
PRINT N'Creating [dbo].[ProdutosMatching]...';


GO
CREATE TABLE [dbo].[ProdutosMatching] (
    [FornecedorCodigo]                  NVARCHAR (5)   NOT NULL,
    [ComplementoCodigo]                 NVARCHAR (128) NOT NULL,
    [Codigo]                            NVARCHAR (256) NOT NULL,
    [Descricao]                         NVARCHAR (256) NOT NULL,
    [MapTo]                             NVARCHAR (40)  NULL,
    [HorasValidadeCotacao]              SMALLINT       NULL,
    [StockCodigoSubstituto]             NVARCHAR (5)   NULL,
    [DispensaPrevencaoPrecosDesfasados] BIT            NOT NULL,
    [DispensaPrevencaoFalsoStock]       BIT            NOT NULL,
    [DataReset]                         SMALLDATETIME  NULL,
    [Notas]                             NVARCHAR (256) NULL,
    [Inativo]                           BIT            NOT NULL,
    [Criacao]                           SMALLDATETIME  NOT NULL,
    [Versao]                            DATETIME       NOT NULL,
    CONSTRAINT [PK_ProdutosMatching] PRIMARY KEY CLUSTERED ([FornecedorCodigo] ASC, [ComplementoCodigo] ASC, [Codigo] ASC)
);


GO
PRINT N'Creating [dbo].[Stocks]...';


GO
CREATE TABLE [dbo].[Stocks] (
    [Codigo]                  NVARCHAR (5)   NOT NULL,
    [Descricao]               NVARCHAR (50)  NOT NULL,
    [DisponibilidadeNivel]    SMALLINT       NOT NULL,
    [ValidadeP50_StockCodigo] NVARCHAR (5)   NULL,
    [ValidadeP60_StockCodigo] NVARCHAR (5)   NULL,
    [ValidadeP70_StockCodigo] NVARCHAR (5)   NULL,
    [ValidadeP80_StockCodigo] NVARCHAR (5)   NULL,
    [ValidadeP90_StockCodigo] NVARCHAR (5)   NULL,
    [Notas]                   NVARCHAR (256) NULL,
    [Inativo]                 BIT            NOT NULL,
    [Criacao]                 SMALLDATETIME  NOT NULL,
    [Versao]                  DATETIME       NOT NULL,
    CONSTRAINT [PK_Stocks] PRIMARY KEY CLUSTERED ([Codigo] ASC)
);


GO
PRINT N'Creating [dbo].[StocksMatching]...';


GO
CREATE TABLE [dbo].[StocksMatching] (
    [FornecedorCodigo] NVARCHAR (5)   NOT NULL,
    [Codigo]           NVARCHAR (128) NOT NULL,
    [Descricao]        NVARCHAR (128) NOT NULL,
    [MapTo]            NVARCHAR (5)   NULL,
    [Inativo]          BIT            NOT NULL,
    [Criacao]          SMALLDATETIME  NOT NULL,
    [Versao]           DATETIME       NOT NULL,
    CONSTRAINT [PK_StocksMatching] PRIMARY KEY CLUSTERED ([FornecedorCodigo] ASC, [Codigo] ASC)
);


GO
PRINT N'Creating [dbo].[Subgrupos]...';


GO
CREATE TABLE [dbo].[Subgrupos] (
    [Codigo]      NVARCHAR (20) NOT NULL,
    [Descricao]   NVARCHAR (50) NOT NULL,
    [GrupoCodigo] NVARCHAR (20) NOT NULL,
    [Inativo]     BIT           NOT NULL,
    [Criacao]     SMALLDATETIME NOT NULL,
    [Versao]      DATETIME      NOT NULL,
    CONSTRAINT [PK_Subgrupos] PRIMARY KEY CLUSTERED ([Codigo] ASC)
);


GO
PRINT N'Creating [dbo].[SubgruposClasses]...';


GO
CREATE TABLE [dbo].[SubgruposClasses] (
    [SubgrupoCodigo] NVARCHAR (20)  NOT NULL,
    [ClasseCodigo]   NVARCHAR (20)  NOT NULL,
    [Notas]          NVARCHAR (256) NULL,
    [Versao]         DATETIME       NOT NULL,
    CONSTRAINT [PK_SubgruposClasses] PRIMARY KEY CLUSTERED ([SubgrupoCodigo] ASC, [ClasseCodigo] ASC)
);


GO
PRINT N'Creating [dbo].[TermosPreocupantes]...';


GO
CREATE TABLE [dbo].[TermosPreocupantes] (
    [Termo]   NVARCHAR (50)  NOT NULL,
    [Indice]  TINYINT        NOT NULL,
    [Notas]   NVARCHAR (256) NULL,
    [Inativo] BIT            NOT NULL,
    [Criacao] SMALLDATETIME  NOT NULL,
    [Versao]  DATETIME       NOT NULL,
    CONSTRAINT [PK_TermosPreocupantes] PRIMARY KEY CLUSTERED ([Termo] ASC)
);


GO
PRINT N'Creating [dbo].[Utilizadores]...';


GO
CREATE TABLE [dbo].[Utilizadores] (
    [Username]      NVARCHAR (20)  NOT NULL,
    [Password]      VARBINARY (64) NOT NULL,
    [Nome]          NVARCHAR (50)  NOT NULL,
    [Email]         NVARCHAR (100) NOT NULL,
    [Mobile]        NVARCHAR (15)  NOT NULL,
    [Sms]           NVARCHAR (15)  NOT NULL,
    [Administrador] BIT            NOT NULL,
    [Inativo]       BIT            NOT NULL,
    [Criacao]       SMALLDATETIME  NOT NULL,
    [Versao]        DATETIME       NOT NULL,
    CONSTRAINT [PK_Utilizadores] PRIMARY KEY CLUSTERED ([Username] ASC)
);


GO
PRINT N'Creating [dbo].[FK_CategoriasMatching_Fornecedor]...';


GO
ALTER TABLE [dbo].[CategoriasMatching]
    ADD CONSTRAINT [FK_CategoriasMatching_Fornecedor] FOREIGN KEY ([FornecedorCodigo]) REFERENCES [dbo].[Fornecedores] ([Codigo]);


GO
PRINT N'Creating [dbo].[FK_CategoriasMatching_MapTo]...';


GO
ALTER TABLE [dbo].[CategoriasMatching]
    ADD CONSTRAINT [FK_CategoriasMatching_MapTo] FOREIGN KEY ([MapTo]) REFERENCES [dbo].[Categorias] ([Codigo]);


GO
PRINT N'Creating [dbo].[FK_Classes_Catalogo]...';


GO
ALTER TABLE [dbo].[Classes]
    ADD CONSTRAINT [FK_Classes_Catalogo] FOREIGN KEY ([CatalogoCodigo]) REFERENCES [dbo].[Catalogos] ([Codigo]);


GO
PRINT N'Creating [dbo].[FK_ClassesCategorias_Classe]...';


GO
ALTER TABLE [dbo].[ClassesCategorias]
    ADD CONSTRAINT [FK_ClassesCategorias_Classe] FOREIGN KEY ([ClasseCodigo]) REFERENCES [dbo].[Classes] ([Codigo]);


GO
PRINT N'Creating [dbo].[FK_ClassesCategorias_Categoria]...';


GO
ALTER TABLE [dbo].[ClassesCategorias]
    ADD CONSTRAINT [FK_ClassesCategorias_Categoria] FOREIGN KEY ([CategoriaCodigo]) REFERENCES [dbo].[Categorias] ([Codigo]);


GO
PRINT N'Creating [dbo].[FK_ComplementosMatching_Fornecedor]...';


GO
ALTER TABLE [dbo].[ComplementosMatching]
    ADD CONSTRAINT [FK_ComplementosMatching_Fornecedor] FOREIGN KEY ([FornecedorCodigo]) REFERENCES [dbo].[Fornecedores] ([Codigo]);


GO
PRINT N'Creating [dbo].[FK_ComplementosMatching_MapTo]...';


GO
ALTER TABLE [dbo].[ComplementosMatching]
    ADD CONSTRAINT [FK_ComplementosMatching_MapTo] FOREIGN KEY ([MapTo]) REFERENCES [dbo].[Complementos] ([Codigo]);


GO
PRINT N'Creating [dbo].[FK_Cotacoes_Fornecedor]...';


GO
ALTER TABLE [dbo].[Cotacoes]
    ADD CONSTRAINT [FK_Cotacoes_Fornecedor] FOREIGN KEY ([FornecedorCodigo]) REFERENCES [dbo].[Fornecedores] ([Codigo]);


GO
PRINT N'Creating [dbo].[FK_Cotacoes_Complemento]...';


GO
ALTER TABLE [dbo].[Cotacoes]
    ADD CONSTRAINT [FK_Cotacoes_Complemento] FOREIGN KEY ([ComplementoCodigo]) REFERENCES [dbo].[Complementos] ([Codigo]);


GO
PRINT N'Creating [dbo].[FK_Cotacoes_Marca]...';


GO
ALTER TABLE [dbo].[Cotacoes]
    ADD CONSTRAINT [FK_Cotacoes_Marca] FOREIGN KEY ([MarcaCodigo]) REFERENCES [dbo].[Marcas] ([Codigo]);


GO
PRINT N'Creating [dbo].[FK_Cotacoes_Categoria]...';


GO
ALTER TABLE [dbo].[Cotacoes]
    ADD CONSTRAINT [FK_Cotacoes_Categoria] FOREIGN KEY ([CategoriaCodigo]) REFERENCES [dbo].[Categorias] ([Codigo]);


GO
PRINT N'Creating [dbo].[FK_Cotacoes_Stock]...';


GO
ALTER TABLE [dbo].[Cotacoes]
    ADD CONSTRAINT [FK_Cotacoes_Stock] FOREIGN KEY ([StockCodigo]) REFERENCES [dbo].[Stocks] ([Codigo]);


GO
PRINT N'Creating [dbo].[FK_Cotacoes_StockSubstituto]...';


GO
ALTER TABLE [dbo].[Cotacoes]
    ADD CONSTRAINT [FK_Cotacoes_StockSubstituto] FOREIGN KEY ([StockCodigoSubstituto]) REFERENCES [dbo].[Stocks] ([Codigo]);


GO
PRINT N'Creating [dbo].[FK_Cotacoes_Imposto]...';


GO
ALTER TABLE [dbo].[Cotacoes]
    ADD CONSTRAINT [FK_Cotacoes_Imposto] FOREIGN KEY ([ImpostoCodigo]) REFERENCES [dbo].[Impostos] ([Codigo]);


GO
PRINT N'Creating [dbo].[FK_Cotacoes_Estado]...';


GO
ALTER TABLE [dbo].[Cotacoes]
    ADD CONSTRAINT [FK_Cotacoes_Estado] FOREIGN KEY ([EstadoCodigo]) REFERENCES [dbo].[Estados] ([Codigo]);


GO
PRINT N'Creating [dbo].[FK_Cotacoes_Produto]...';


GO
ALTER TABLE [dbo].[Cotacoes]
    ADD CONSTRAINT [FK_Cotacoes_Produto] FOREIGN KEY ([ProdutoCodigo]) REFERENCES [dbo].[Produtos] ([Codigo]);


GO
PRINT N'Creating [dbo].[FK_CotacoesAvisos_Fornecedor]...';


GO
ALTER TABLE [dbo].[CotacoesAvisos]
    ADD CONSTRAINT [FK_CotacoesAvisos_Fornecedor] FOREIGN KEY ([FornecedorCodigo]) REFERENCES [dbo].[Fornecedores] ([Codigo]);


GO
PRINT N'Creating [dbo].[FK_CotacoesAvisos_AvisoTipo]...';


GO
ALTER TABLE [dbo].[CotacoesAvisos]
    ADD CONSTRAINT [FK_CotacoesAvisos_AvisoTipo] FOREIGN KEY ([AvisoTipoCodigo]) REFERENCES [dbo].[AvisosTipo] ([Codigo]);


GO
PRINT N'Creating [dbo].[FK_CotacoesRegras_Fornecedor]...';


GO
ALTER TABLE [dbo].[CotacoesRegras]
    ADD CONSTRAINT [FK_CotacoesRegras_Fornecedor] FOREIGN KEY ([FornecedorCodigo]) REFERENCES [dbo].[Fornecedores] ([Codigo]);


GO
PRINT N'Creating [dbo].[FK_CotacoesRegras_Marca]...';


GO
ALTER TABLE [dbo].[CotacoesRegras]
    ADD CONSTRAINT [FK_CotacoesRegras_Marca] FOREIGN KEY ([MarcaCodigo]) REFERENCES [dbo].[Marcas] ([Codigo]);


GO
PRINT N'Creating [dbo].[FK_CotacoesRegras_Categoria]...';


GO
ALTER TABLE [dbo].[CotacoesRegras]
    ADD CONSTRAINT [FK_CotacoesRegras_Categoria] FOREIGN KEY ([CategoriaCodigo]) REFERENCES [dbo].[Categorias] ([Codigo]);


GO
PRINT N'Creating [dbo].[FK_CotacoesRegras_Stock]...';


GO
ALTER TABLE [dbo].[CotacoesRegras]
    ADD CONSTRAINT [FK_CotacoesRegras_Stock] FOREIGN KEY ([StockCodigo]) REFERENCES [dbo].[Stocks] ([Codigo]);


GO
PRINT N'Creating [dbo].[FK_CotacoesRegras_StockSubstituto]...';


GO
ALTER TABLE [dbo].[CotacoesRegras]
    ADD CONSTRAINT [FK_CotacoesRegras_StockSubstituto] FOREIGN KEY ([StockCodigoSubstituto]) REFERENCES [dbo].[Stocks] ([Codigo]);


GO
PRINT N'Creating [dbo].[FK_EstadosMatching_Fornecedor]...';


GO
ALTER TABLE [dbo].[EstadosMatching]
    ADD CONSTRAINT [FK_EstadosMatching_Fornecedor] FOREIGN KEY ([FornecedorCodigo]) REFERENCES [dbo].[Fornecedores] ([Codigo]);


GO
PRINT N'Creating [dbo].[FK_EstadosMatching_MapTo]...';


GO
ALTER TABLE [dbo].[EstadosMatching]
    ADD CONSTRAINT [FK_EstadosMatching_MapTo] FOREIGN KEY ([MapTo]) REFERENCES [dbo].[Estados] ([Codigo]);


GO
PRINT N'Creating [dbo].[FK_FornecedoresMarcas_Fornecedor]...';


GO
ALTER TABLE [dbo].[FornecedoresMarcas]
    ADD CONSTRAINT [FK_FornecedoresMarcas_Fornecedor] FOREIGN KEY ([FornecedorCodigo]) REFERENCES [dbo].[Fornecedores] ([Codigo]);


GO
PRINT N'Creating [dbo].[FK_FornecedoresMarcas_marca]...';


GO
ALTER TABLE [dbo].[FornecedoresMarcas]
    ADD CONSTRAINT [FK_FornecedoresMarcas_marca] FOREIGN KEY ([MarcaCodigo]) REFERENCES [dbo].[Marcas] ([Codigo]);


GO
PRINT N'Creating [dbo].[FK_ImpostosMatching_Fornecedor]...';


GO
ALTER TABLE [dbo].[ImpostosMatching]
    ADD CONSTRAINT [FK_ImpostosMatching_Fornecedor] FOREIGN KEY ([FornecedorCodigo]) REFERENCES [dbo].[Fornecedores] ([Codigo]);


GO
PRINT N'Creating [dbo].[FK_ImpostosMatching_MapTo]...';


GO
ALTER TABLE [dbo].[ImpostosMatching]
    ADD CONSTRAINT [FK_ImpostosMatching_MapTo] FOREIGN KEY ([MapTo]) REFERENCES [dbo].[Impostos] ([Codigo]);


GO
PRINT N'Creating [dbo].[FK_IndicesConfiancaMarcaFornecedor_Fornecedor]...';


GO
ALTER TABLE [dbo].[IndicesConfiancaMarcaFornecedor]
    ADD CONSTRAINT [FK_IndicesConfiancaMarcaFornecedor_Fornecedor] FOREIGN KEY ([FornecedorCodigo]) REFERENCES [dbo].[Fornecedores] ([Codigo]);


GO
PRINT N'Creating [dbo].[FK_IndicesConfiancaMarcaFornecedor_Marca]...';


GO
ALTER TABLE [dbo].[IndicesConfiancaMarcaFornecedor]
    ADD CONSTRAINT [FK_IndicesConfiancaMarcaFornecedor_Marca] FOREIGN KEY ([MarcaCodigo]) REFERENCES [dbo].[Marcas] ([Codigo]);


GO
PRINT N'Creating [dbo].[FK_MarcasMatching_Fornecedor]...';


GO
ALTER TABLE [dbo].[MarcasMatching]
    ADD CONSTRAINT [FK_MarcasMatching_Fornecedor] FOREIGN KEY ([FornecedorCodigo]) REFERENCES [dbo].[Fornecedores] ([Codigo]);


GO
PRINT N'Creating [dbo].[FK_MarcasMatching_MapTo]...';


GO
ALTER TABLE [dbo].[MarcasMatching]
    ADD CONSTRAINT [FK_MarcasMatching_MapTo] FOREIGN KEY ([MapTo]) REFERENCES [dbo].[Marcas] ([Codigo]);


GO
PRINT N'Creating [dbo].[FK_Produtos_Categoria]...';


GO
ALTER TABLE [dbo].[Produtos]
    ADD CONSTRAINT [FK_Produtos_Categoria] FOREIGN KEY ([CategoriaCodigo]) REFERENCES [dbo].[Categorias] ([Codigo]);


GO
PRINT N'Creating [dbo].[FK_Produtos_Marca]...';


GO
ALTER TABLE [dbo].[Produtos]
    ADD CONSTRAINT [FK_Produtos_Marca] FOREIGN KEY ([MarcaCodigo]) REFERENCES [dbo].[Marcas] ([Codigo]);


GO
PRINT N'Creating [dbo].[FK_Produtos_Imposto]...';


GO
ALTER TABLE [dbo].[Produtos]
    ADD CONSTRAINT [FK_Produtos_Imposto] FOREIGN KEY ([ImpostoCodigo]) REFERENCES [dbo].[Impostos] ([Codigo]);


GO
PRINT N'Creating [dbo].[FK_Produtos_Fornecedor]...';


GO
ALTER TABLE [dbo].[Produtos]
    ADD CONSTRAINT [FK_Produtos_Fornecedor] FOREIGN KEY ([FornecedorCodigo]) REFERENCES [dbo].[Fornecedores] ([Codigo]);


GO
PRINT N'Creating [dbo].[FK_Produtos_Stock]...';


GO
ALTER TABLE [dbo].[Produtos]
    ADD CONSTRAINT [FK_Produtos_Stock] FOREIGN KEY ([StockCodigo]) REFERENCES [dbo].[Stocks] ([Codigo]);


GO
PRINT N'Creating [dbo].[FK_Produtos_Stock_U1]...';


GO
ALTER TABLE [dbo].[Produtos]
    ADD CONSTRAINT [FK_Produtos_Stock_U1] FOREIGN KEY ([StockCodigo_U1]) REFERENCES [dbo].[Stocks] ([Codigo]);


GO
PRINT N'Creating [dbo].[FK_Produtos_Stock_U2]...';


GO
ALTER TABLE [dbo].[Produtos]
    ADD CONSTRAINT [FK_Produtos_Stock_U2] FOREIGN KEY ([StockCodigo_U2]) REFERENCES [dbo].[Stocks] ([Codigo]);


GO
PRINT N'Creating [dbo].[FK_Produtos_Stock_U3]...';


GO
ALTER TABLE [dbo].[Produtos]
    ADD CONSTRAINT [FK_Produtos_Stock_U3] FOREIGN KEY ([StockCodigo_U3]) REFERENCES [dbo].[Stocks] ([Codigo]);


GO
PRINT N'Creating [dbo].[FK_ProdutosDetalhe_Produto]...';


GO
ALTER TABLE [dbo].[ProdutosDetalhe]
    ADD CONSTRAINT [FK_ProdutosDetalhe_Produto] FOREIGN KEY ([ProdutoCodigo]) REFERENCES [dbo].[Produtos] ([Codigo]);


GO
PRINT N'Creating [dbo].[FK_ProdutosDetalhe_Fornecedor]...';


GO
ALTER TABLE [dbo].[ProdutosDetalhe]
    ADD CONSTRAINT [FK_ProdutosDetalhe_Fornecedor] FOREIGN KEY ([FornecedorCodigo]) REFERENCES [dbo].[Fornecedores] ([Codigo]);


GO
PRINT N'Creating [dbo].[FK_ProdutosMatching_Fornecedor]...';


GO
ALTER TABLE [dbo].[ProdutosMatching]
    ADD CONSTRAINT [FK_ProdutosMatching_Fornecedor] FOREIGN KEY ([FornecedorCodigo]) REFERENCES [dbo].[Fornecedores] ([Codigo]);


GO
PRINT N'Creating [dbo].[FK_ProdutosMatching_MapTo]...';


GO
ALTER TABLE [dbo].[ProdutosMatching]
    ADD CONSTRAINT [FK_ProdutosMatching_MapTo] FOREIGN KEY ([MapTo]) REFERENCES [dbo].[Produtos] ([Codigo]);


GO
PRINT N'Creating [dbo].[FK_ProdutosMatching_StockSubstituto]...';


GO
ALTER TABLE [dbo].[ProdutosMatching]
    ADD CONSTRAINT [FK_ProdutosMatching_StockSubstituto] FOREIGN KEY ([StockCodigoSubstituto]) REFERENCES [dbo].[Stocks] ([Codigo]);


GO
PRINT N'Creating [dbo].[FK_Stocks_ValidadeP50]...';


GO
ALTER TABLE [dbo].[Stocks]
    ADD CONSTRAINT [FK_Stocks_ValidadeP50] FOREIGN KEY ([ValidadeP50_StockCodigo]) REFERENCES [dbo].[Stocks] ([Codigo]);


GO
PRINT N'Creating [dbo].[FK_Stocks_ValidadeP60]...';


GO
ALTER TABLE [dbo].[Stocks]
    ADD CONSTRAINT [FK_Stocks_ValidadeP60] FOREIGN KEY ([ValidadeP60_StockCodigo]) REFERENCES [dbo].[Stocks] ([Codigo]);


GO
PRINT N'Creating [dbo].[FK_Stocks_ValidadeP70]...';


GO
ALTER TABLE [dbo].[Stocks]
    ADD CONSTRAINT [FK_Stocks_ValidadeP70] FOREIGN KEY ([ValidadeP70_StockCodigo]) REFERENCES [dbo].[Stocks] ([Codigo]);


GO
PRINT N'Creating [dbo].[FK_Stocks_ValidadeP80]...';


GO
ALTER TABLE [dbo].[Stocks]
    ADD CONSTRAINT [FK_Stocks_ValidadeP80] FOREIGN KEY ([ValidadeP80_StockCodigo]) REFERENCES [dbo].[Stocks] ([Codigo]);


GO
PRINT N'Creating [dbo].[FK_Stocks_ValidadeP90]...';


GO
ALTER TABLE [dbo].[Stocks]
    ADD CONSTRAINT [FK_Stocks_ValidadeP90] FOREIGN KEY ([ValidadeP90_StockCodigo]) REFERENCES [dbo].[Stocks] ([Codigo]);


GO
PRINT N'Creating [dbo].[FK_StocksMatching_Fornecedor]...';


GO
ALTER TABLE [dbo].[StocksMatching]
    ADD CONSTRAINT [FK_StocksMatching_Fornecedor] FOREIGN KEY ([FornecedorCodigo]) REFERENCES [dbo].[Fornecedores] ([Codigo]);


GO
PRINT N'Creating [dbo].[FK_StocksMatching_MapTo]...';


GO
ALTER TABLE [dbo].[StocksMatching]
    ADD CONSTRAINT [FK_StocksMatching_MapTo] FOREIGN KEY ([MapTo]) REFERENCES [dbo].[Stocks] ([Codigo]);


GO
PRINT N'Creating [dbo].[FK_Subgrupos_Grupo]...';


GO
ALTER TABLE [dbo].[Subgrupos]
    ADD CONSTRAINT [FK_Subgrupos_Grupo] FOREIGN KEY ([GrupoCodigo]) REFERENCES [dbo].[Grupos] ([Codigo]);


GO
PRINT N'Creating [dbo].[FK_SubgruposClasses_Subgrupo]...';


GO
ALTER TABLE [dbo].[SubgruposClasses]
    ADD CONSTRAINT [FK_SubgruposClasses_Subgrupo] FOREIGN KEY ([SubgrupoCodigo]) REFERENCES [dbo].[Subgrupos] ([Codigo]);


GO
PRINT N'Creating [dbo].[FK_SubgruposClasses_Classe]...';


GO
ALTER TABLE [dbo].[SubgruposClasses]
    ADD CONSTRAINT [FK_SubgruposClasses_Classe] FOREIGN KEY ([ClasseCodigo]) REFERENCES [dbo].[Classes] ([Codigo]);


GO
PRINT N'Creating [dbo].[CleanBadCharsFunction]...';


GO
/*
	O objetivo desta função é limpar uma string com caracteres lixo e espaço em excesso, por exemplo.
*/

CREATE FUNCTION [dbo].CleanBadCharsFunction
(
	@texto nvarchar(256)
)
RETURNS nvarchar(256)
AS
BEGIN

	-- remove trim spaces (left and right)
	SET @texto = LTRIM(RTRIM(@texto));

	-- remove bad chars (unexpected chars)
	SET @texto = REPLACE(@texto, '´', ' ');
	SET @texto = REPLACE(@texto, '`', ' ');
	SET @texto = REPLACE(@texto, '"', ' ');
	SET @texto = REPLACE(@texto, '~', ' ');
	SET @texto = REPLACE(@texto, '^', ' ');
	SET @texto = REPLACE(@texto, '''', ' ');
	SET @texto = REPLACE(@texto, '¨', ' ');

	-- remove extra wrong spaces (leave only one space)
	SET @texto = REPLACE(@texto, '       ', ' ');
	SET @texto = REPLACE(@texto, '      ', ' ');
	SET @texto = REPLACE(@texto, '     ', ' ');
	SET @texto = REPLACE(@texto, '    ', ' ');
	SET @texto = REPLACE(@texto, '   ', ' ');
	SET @texto = REPLACE(@texto, '  ', ' ');

	-- return cleaned text
	RETURN @texto;
END
GO
PRINT N'Creating [dbo].[GetCotacaoImagemFunction]...';


GO
/*
	This function receives the original Product Image URL and normalize it.
*/


CREATE FUNCTION [dbo].[GetCotacaoImagemFunction]
(
	@_Imagem nvarchar(1024)
)
RETURNS nvarchar(1024)
AS
BEGIN

	-- variables
	DECLARE @image nvarchar(1024);

	-- force lowercase
	SET @image = LOWER(@_Imagem);

	-- clean newline chars
	SET @image = REPLACE(@image, CHAR(10) + CHAR(13), '');
	SET @image = REPLACE(@image, CHAR(10), '');
	SET @image = REPLACE(@image, CHAR(13), '');
	SET @image = REPLACE(@image, CHAR(9), '');

	-- send back the normalized link
	RETURN @image;
END
GO
PRINT N'Creating [dbo].[GetCotacaoLinkFunction]...';


GO
/*
	This function receives the original Product Link and normalize it.
*/


CREATE FUNCTION [dbo].[GetCotacaoLinkFunction]
(
	@_Link nvarchar(1024)
)
RETURNS nvarchar(1024)
AS
BEGIN

	-- variables
	DECLARE @link nvarchar(1024), @pos integer;

	-- force lowercase
	SET @link = LOWER(@_Link);

	-- get position of :// to analyse used protocol
	SELECT @pos = PATINDEX('%://%', @link);

	-- test if a authorized protocol it used
	-- if :// exists in the string, mean's that there is a protocol defined
	-- and if protocol is not in list, then @link is forbidden
	IF @pos > 1 AND (LOWER(LEFT(@link, @pos-1)) NOT IN ('http', 'https', 'ftp'))
	BEGIN
		-- ilegal protocol
		SET @link = '';
	END
	ELSE IF @pos < 1 AND @link <> '(vazio)'				-- :// it's not present in the string
	BEGIN
		-- add default protocol to link
		SET @link = 'http://' + @link;
	END
	ELSE
	BEGIN
		-- else
		SET @link = '(vazio)';
	END

	-- clean newline chars
	SET @link = REPLACE(@link, CHAR(10) + CHAR(13), '');
	SET @link = REPLACE(@link, CHAR(10), '');
	SET @link = REPLACE(@link, CHAR(13), '');
	SET @link = REPLACE(@link, CHAR(9), '');

	-- send back the normalized link
	RETURN @link;
END
GO
PRINT N'Creating [dbo].[GetIndicePreocupacaoFunction]...';


GO
/*
	This function receives some text and, after analyse it, send back a value [0:9] representing the danger of terms...
	Zero (0) represents a no preocupation at all and nine (9) represents text with extremely danger terms.
*/


CREATE FUNCTION [dbo].[GetIndicePreocupacaoFunction]
(
	@texto nvarchar(MAX)
)
RETURNS tinyint
AS
BEGIN
	
	-- variables
	DECLARE @indice tinyint = 0;

	-- search for the greather preocupation index present in @texto
	SELECT TOP 1 @indice = Indice
	FROM [dbo].[TermosPreocupantes]
	WHERE LOWER(@texto) LIKE LOWER(Termo)
	ORDER BY Indice DESC;

	-- send back preocupation index
	return @indice;

END
GO
PRINT N'Creating [dbo].[GetProdutoDetalheIndicePreocupacaoFunction]...';


GO
/*
	This function receives description and features fields from a ProdutoDetalhe and returns it's content preocupation index.
*/


CREATE FUNCTION [dbo].[GetProdutoDetalheIndicePreocupacaoFunction]
(
	@descricao nvarchar(256),
	@caracteristicas nvarchar(2048)
)
RETURNS tinyint
AS
BEGIN
	
	-- variables
	DECLARE @indice tinyint = 0;

	-- search for the greather preocupation index present either in @description and features
	SELECT @indice = MAX(Indice)
	FROM
		(

			-- get content preocupation index from description
			SELECT [dbo].GetIndicePreocupacaoFunction(@descricao) as Indice

			UNION

			-- get content preocupation index from features
			SELECT [dbo].GetIndicePreocupacaoFunction(@caracteristicas) as Indice

		) indices;


	-- send back preocupation index
	return @indice;

END
GO
PRINT N'Creating [dbo].[GetTextoOnlyAllowedCharsFunction]...';


GO
/*
	This function receives two arguments. The first one it's the text to be stripped off and the second
	is the pattern of allowed chars.

	All chars not allowed by pattern are excluded from the text and, the result string, is sended
	back to calling point.

	Example of use:
	SELECT [dbo].GetTextoOnlyAllowedCharsFunction('Th.-is is the t-es+t num$ber 93!','[A-Za-z0-9 ]');
*/

CREATE FUNCTION [dbo].GetTextoOnlyAllowedCharsFunction
(
	@texto nvarchar(256),
	@allowedPattern nvarchar(256)
)
RETURNS nvarchar(256)
AS
BEGIN

	-- variaveis
	DECLARE @i AS INTEGER = 1, @n AS INTEGER = LEN(@texto), @result nvarchar(256) = '';

	-- percorrer cada caracter e concatenar apenas os caracteres permitidos
	WHILE @i <= @n
	BEGIN
		
		-- avalia o caracter atual (em processamento)
		IF SUBSTRING(@texto, @i, 1) LIKE @allowedPattern
		BEGIN
			-- se o caracter é válido na expressão regular, adiciona-o à expressão resultante
			SET @result += SUBSTRING(@texto, @i, 1);
		END

		-- incrementar contador
		SET @i += 1;

	END

	-- devolver texto stripped
	RETURN @result;
END
GO
PRINT N'Creating [dbo].[GetValidadePercentilFunction]...';


GO
/*
	This function receives a date interval and calculates the date correspondent to percentil received too.

	k = (percentil / 100) * n

*/


CREATE FUNCTION [dbo].[GetValidadePercentilFunction]
(
	@Data datetime,
	@Validade smalldatetime,
	@Percentil integer
)
RETURNS datetime
AS
BEGIN
	
	-- variables
	DECLARE @n integer, @k integer;

	-- interval calculation in days
	SET @n = DATEDIFF(DAY, @Data, @Validade); 

	-- percentil calculation
	SET @k = (@Percentil / 100.0) * @n;

	-- send back the date that belongs to interval that matches the percentil received as argument
	RETURN DATEADD(DAY, @k, @Data); 
END
GO
PRINT N'Creating [dbo].[RemoveAccentuationFunction]...';


GO
/*
	O objetivo desta função é limpar uma string com caracteres lixo e espaço em excesso, por exemplo.
*/

CREATE FUNCTION [dbo].RemoveAccentuationFunction
(
	@texto nvarchar(256)
)
RETURNS nvarchar(256)
AS
BEGIN

	-- remove accents
	SET @texto = REPLACE(@texto, 'À' COLLATE Latin1_General_CS_AS, 'A'); -- CS -> Case Sensitive
	SET @texto = REPLACE(@texto, 'Á' COLLATE Latin1_General_CS_AS, 'A');
	SET @texto = REPLACE(@texto, 'Ã' COLLATE Latin1_General_CS_AS, 'A');
	SET @texto = REPLACE(@texto, 'Â' COLLATE Latin1_General_CS_AS, 'A');
	SET @texto = REPLACE(@texto, 'Ä' COLLATE Latin1_General_CS_AS, 'A');
	SET @texto = REPLACE(@texto, 'È' COLLATE Latin1_General_CS_AS, 'E');
	SET @texto = REPLACE(@texto, 'É' COLLATE Latin1_General_CS_AS, 'E');
	SET @texto = REPLACE(@texto, 'Ê' COLLATE Latin1_General_CS_AS, 'E');
	SET @texto = REPLACE(@texto, 'Ë' COLLATE Latin1_General_CS_AS, 'E');
	SET @texto = REPLACE(@texto, 'Ì' COLLATE Latin1_General_CS_AS, 'I');
	SET @texto = REPLACE(@texto, 'Í' COLLATE Latin1_General_CS_AS, 'I');
	SET @texto = REPLACE(@texto, 'Î' COLLATE Latin1_General_CS_AS, 'I');
	SET @texto = REPLACE(@texto, 'Ï' COLLATE Latin1_General_CS_AS, 'I');
	SET @texto = REPLACE(@texto, 'Ò' COLLATE Latin1_General_CS_AS, 'O');
	SET @texto = REPLACE(@texto, 'Ó' COLLATE Latin1_General_CS_AS, 'O');
	SET @texto = REPLACE(@texto, 'Õ' COLLATE Latin1_General_CS_AS, 'O');
	SET @texto = REPLACE(@texto, 'Ô' COLLATE Latin1_General_CS_AS, 'O');
	SET @texto = REPLACE(@texto, 'Ö' COLLATE Latin1_General_CS_AS, 'O');
	SET @texto = REPLACE(@texto, 'Ù' COLLATE Latin1_General_CS_AS, 'U');
	SET @texto = REPLACE(@texto, 'Ú' COLLATE Latin1_General_CS_AS, 'U');
	SET @texto = REPLACE(@texto, 'Û' COLLATE Latin1_General_CS_AS, 'U');
	SET @texto = REPLACE(@texto, 'Ü' COLLATE Latin1_General_CS_AS, 'U');
	SET @texto = REPLACE(@texto, 'Ç' COLLATE Latin1_General_CS_AS, 'C');

	SET @texto = REPLACE(@texto, 'à' COLLATE Latin1_General_CS_AS, 'a');
	SET @texto = REPLACE(@texto, 'á' COLLATE Latin1_General_CS_AS, 'a');
	SET @texto = REPLACE(@texto, 'ã' COLLATE Latin1_General_CS_AS, 'a');
	SET @texto = REPLACE(@texto, 'â' COLLATE Latin1_General_CS_AS, 'a');
	SET @texto = REPLACE(@texto, 'ä' COLLATE Latin1_General_CS_AS, 'a');
	SET @texto = REPLACE(@texto, 'è' COLLATE Latin1_General_CS_AS, 'e');
	SET @texto = REPLACE(@texto, 'é' COLLATE Latin1_General_CS_AS, 'e');
	SET @texto = REPLACE(@texto, 'ê' COLLATE Latin1_General_CS_AS, 'e');
	SET @texto = REPLACE(@texto, 'ë' COLLATE Latin1_General_CS_AS, 'e');
	SET @texto = REPLACE(@texto, 'ì' COLLATE Latin1_General_CS_AS, 'i');
	SET @texto = REPLACE(@texto, 'í' COLLATE Latin1_General_CS_AS, 'i');
	SET @texto = REPLACE(@texto, 'î' COLLATE Latin1_General_CS_AS, 'i');
	SET @texto = REPLACE(@texto, 'ï' COLLATE Latin1_General_CS_AS, 'i');
	SET @texto = REPLACE(@texto, 'ò' COLLATE Latin1_General_CS_AS, 'o');
	SET @texto = REPLACE(@texto, 'ó' COLLATE Latin1_General_CS_AS, 'o');
	SET @texto = REPLACE(@texto, 'õ' COLLATE Latin1_General_CS_AS, 'o');
	SET @texto = REPLACE(@texto, 'ô' COLLATE Latin1_General_CS_AS, 'o');
	SET @texto = REPLACE(@texto, 'ö' COLLATE Latin1_General_CS_AS, 'o');
	SET @texto = REPLACE(@texto, 'ù' COLLATE Latin1_General_CS_AS, 'u');
	SET @texto = REPLACE(@texto, 'ú' COLLATE Latin1_General_CS_AS, 'u');
	SET @texto = REPLACE(@texto, 'û' COLLATE Latin1_General_CS_AS, 'u');
	SET @texto = REPLACE(@texto, 'ü' COLLATE Latin1_General_CS_AS, 'u');
	SET @texto = REPLACE(@texto, 'ç' COLLATE Latin1_General_CS_AS, 'c');

	-- return text cleaned
	RETURN @texto;
END
GO
PRINT N'Creating [dbo].[StripHtmlTagsFunction]...';


GO
/*
	This function strips all http tags from string
*/

CREATE FUNCTION [dbo].StripHtmlTagsFunction
(
	@text nvarchar(MAX)
)
RETURNS nvarchar(MAX)
AS
BEGIN

	-- variables
	DECLARE @start integer, @end integer, @length integer;

	-- set initial values
	SET @start = CHARINDEX('<', @text);			-- get position of first occurrence of <
	SET @end = CHARINDEX('>', @text, @start);	-- get position of first occurrence of > after @start
	SET @length = (@end - @start) + 1;

	-- iterate while there is at least one > and <
	WHILE @start > 0 AND @end > 0 AND @length > 0
	BEGIN
		
		-- replace set of text inside @text
		SET @text = STUFF(@text, @start, @length, '');
		
		-- prepare a new iteration
		SET @start = CHARINDEX('<', @text);
		SET @end = CHARINDEX('>', @text, @start);
		SET @length = (@end - @start) + 1;

	END

	-- remove extra long line feeding
	SET @text = REPLACE(@text, CHAR(10) + CHAR(13) + CHAR(10) + CHAR(13) + CHAR(10) + CHAR(13) + CHAR(10) + CHAR(13) + CHAR(10) + CHAR(13), CHAR(10) + CHAR(13));
	SET @text = REPLACE(@text, CHAR(10) + CHAR(13) + CHAR(10) + CHAR(13) + CHAR(10) + CHAR(13) + CHAR(10) + CHAR(13), CHAR(10) + CHAR(13));
	SET @text = REPLACE(@text, CHAR(10) + CHAR(13) + CHAR(10) + CHAR(13) + CHAR(10) + CHAR(13), CHAR(10) + CHAR(13));
	SET @text = REPLACE(@text, CHAR(10) + CHAR(13) + CHAR(10) + CHAR(13), CHAR(10) + CHAR(13));

	-- remove other html stuff
	SET @text = REPLACE(@text, '&nbsp;', '');
	SET @text = REPLACE(@text, '&tab;', '');
	SET @text = REPLACE(@text, '&newline;', '');
	SET @text = REPLACE(@text, '&quot;', '');
	SET @text = REPLACE(@text, '&num;', '');
	SET @text = REPLACE(@text, '&percnt;', '%');
	SET @text = REPLACE(@text, '&amp;', '&');
	SET @text = REPLACE(@text, '&apos;', '');
	SET @text = REPLACE(@text, '&comma;', ',');
	SET @text = REPLACE(@text, '&period;', '.');
	SET @text = REPLACE(@text, '&sol;', '/');
	SET @text = REPLACE(@text, '&colon;', ':');
	SET @text = REPLACE(@text, '&semi;', ';');
	SET @text = REPLACE(@text, '&plus;', '+');
	SET @text = REPLACE(@text, '&lt;', '<');
	SET @text = REPLACE(@text, '&equals;', '=');
	SET @text = REPLACE(@text, '&gt;', '>');
	SET @text = REPLACE(@text, '&quest;', '?');
	SET @text = REPLACE(@text, '&commat;', '@');
	SET @text = REPLACE(@text, '&bsol;', '\');
	SET @text = REPLACE(@text, '&reg;', '(R)');
	SET @text = REPLACE(@text, '&copy;', '(C)');
	SET @text = REPLACE(@text, '&deg;', 'º');

	-- clean leading spaces
	SET @text = LTRIM(RTRIM(@text));

	-- return stripped text
	RETURN @text;

END
GO
PRINT N'Creating [dbo].[GetCodigoExternoNormalizadoFunction]...';


GO
/*
	This function exist to normalize external coding system.
	The function receives an external code na normalize it to obey allways to the same internal rules of external codification.
	All external codes are normalized with this function when they are inserted on Quotations table.
	We want to prevent little externa changes on code strategy and so minimize not fake not matched situations. As an example, imagine some code that
	leaves lowercase and becomes uppercase.. or the code is improved removing an extra space...
*/



CREATE FUNCTION [dbo].[GetCodigoExternoNormalizadoFunction]
(
	@codigo nvarchar(256)
)
RETURNS nvarchar(256)
AS
BEGIN

	-- change received separator chars by a space char. later will be changed again to underscore
	SET @codigo = REPLACE(@codigo, '-', ' ');
	SET @codigo = REPLACE(@codigo, '+', ' ');
	SET @codigo = REPLACE(@codigo, '*', ' ');
	SET @codigo = REPLACE(@codigo, '.', ' ');
	SET @codigo = REPLACE(@codigo, ':', ' ');
	SET @codigo = REPLACE(@codigo, ';', ' ');
	SET @codigo = REPLACE(@codigo, '#', ' ');
	SET @codigo = REPLACE(@codigo, '?', ' ');
	SET @codigo = REPLACE(@codigo, '!', ' ');
	SET @codigo = REPLACE(@codigo, 'º', ' ');
	SET @codigo = REPLACE(@codigo, 'ª', ' ');

	-- normalize external code
	SET @codigo = REPLACE(@codigo, '\', '/');
	SET @codigo = REPLACE(@codigo, '|', '/');
	
	-- remove accentuation
	SET @codigo = [dbo].[RemoveAccentuationFunction](@codigo);

	-- remove bad chars
	SET @codigo = [dbo].[CleanBadCharsFunction](@codigo);

	-- external codes will allways lowercase
	SET @codigo = LOWER(@codigo);

	-- change space chars to underscore (wrong multiple spaces were normalized behind)
	SET @codigo = REPLACE(@codigo, ' ', '_');

	-- devolver o codigo normalizado e limpo
	RETURN @codigo;
END
GO
PRINT N'Creating [dbo].[GetCotacaoCaracteristicasFunction]...';


GO
/*
	This function receives the original features and deal with it to clean and normalize it.
*/


CREATE FUNCTION [dbo].[GetCotacaoCaracteristicasFunction]
(
	@_Caracteristicas nvarchar(2048)
)
RETURNS nvarchar(2048)
AS
BEGIN

	-- variables
	DECLARE @caracteristicas nvarchar(2048);

	-- force lowercase
	SET @caracteristicas = LOWER(@_Caracteristicas);

	-- strip html tags
	SET @caracteristicas = [dbo].[StripHtmlTagsFunction](@caracteristicas);

	-- correct some chars
	SET @caracteristicas = REPLACE(@caracteristicas, '\', '/');
	SET @caracteristicas = REPLACE(@caracteristicas, '|', '/');

	-- force some linguistic rules (if extra bad spaces generated, they will be removed in CleanBadCharsFunction...
	SET @caracteristicas = REPLACE(@caracteristicas, '.', '. ');
	SET @caracteristicas = REPLACE(@caracteristicas, ',', ', ');
	SET @caracteristicas = REPLACE(@caracteristicas, ':', ': ');
	SET @caracteristicas = REPLACE(@caracteristicas, ';', '; ');
	SET @caracteristicas = REPLACE(@caracteristicas, '!', '! ');
	SET @caracteristicas = REPLACE(@caracteristicas, '?', '? ');

	-- clean bad chars
	SET @caracteristicas = [dbo].[CleanBadCharsFunction](@caracteristicas);

	-- send back the normalized features
	RETURN @caracteristicas;
END
GO
PRINT N'Creating [dbo].[GetCotacaoPartnumberFunction]...';


GO
/*
	This function, also used on step 1 of wheretobuy processing, it's used to clean received Partnumber of incorrect spaces 
	(imagine that instead of one space inside the partnumber, external user put two or more spaces wrongly), and prevents too
	from wrong accented chars... etc.

	We want to best normalize the Partnumber to make it more cross comun between several suppliers.

	We decid too that all Partnumbers will be in uppercase.
*/



CREATE FUNCTION [dbo].[GetCotacaoPartnumberFunction]
(
	@_Partnumber nvarchar(25)
)
RETURNS nvarchar(25)
AS
BEGIN

	-- variables
	DECLARE @partnumber nvarchar(25);

	-- partnumber will be allways stored on uppercase
	SET @partnumber = UPPER(@_Partnumber);

	-- remove accentuation
	SET @partnumber = [dbo].[RemoveAccentuationFunction](@partnumber);

	-- remove bad chars
	SET @partnumber = [dbo].[CleanBadCharsFunction](@partnumber);

	-- correct chars
	SET @partnumber = REPLACE(@partnumber, '\', '/');
	SET @partnumber = REPLACE(@partnumber, ',', '.');
	SET @partnumber = REPLACE(@partnumber, 'º', '');
	SET @partnumber = REPLACE(@partnumber, 'ª', '');

	-- remove all sepaces inside partnumber
	SET @partnumber = REPLACE(@partnumber, ' ','');

	-- devolver o partnumber limpo e normalizado
	RETURN @partnumber;
END
GO
PRINT N'Creating [dbo].[GetCotacaoPartnumberSimplificadoFunction]...';


GO
/*
	This function receives the original Partnumber sended by the supplier and minimize it to only keep the essencials chars (alpha-numeric chars).

	The goal of this processing task, is to improve the chances of matching the partnumber between diferent suppliers (external systems)

	Be aware that, the received Partnumber have already been object of cleaning on Quotations Insert process. However, while in the cleaning
	process only undesirable chars were cleaned, now, with this function, the already cleaned partnumber is reduced to the minimum of representative chars
	to improve chances of matching between several external systems...
*/


CREATE FUNCTION [dbo].[GetCotacaoPartnumberSimplificadoFunction]
(
	@Partnumber nvarchar(25)
)
RETURNS nvarchar(25)
AS
BEGIN

	-- variables
	DECLARE @minimizedPartnumber nvarchar(25);

	-- minimize received Partnumber to the minimum of representative chars
	SET @minimizedPartnumber = [dbo].GetTextoOnlyAllowedCharsFunction(@Partnumber, '[A-Za-z0-9]');

	-- send back the minimized Partnumber version
	RETURN @minimizedPartnumber;
END
GO
PRINT N'Creating [dbo].[GetProdutoCodigoFunction]...';


GO
/*
	This function calculates the Product Code for each Quotation.
	It receives the Brand Code, Addon Code and Partnumber and, after minimize the Partnumber, 
	generates a Product Code concatenating the Brand Code with the Partnumber and with Addon Code as shown below
		
		Product Code = Brand Code + Minimized Partnumber + '[' + Addon Code + ']'

	With this function, we can have access to the Product Code, even before the Product record has been created.

	This function reuses the GetCotacaoPartnumberSimplificado function too minimize the Partnumber, thereby improving
	the chances of matching product codes between different suppliers..
	
	This function receives the Addon Code. Addons are the way to differenciate the same product when a supplier offers
	with some specific add like delivery or extra warranty.
*/


CREATE FUNCTION [dbo].[GetProdutoCodigoFunction]
(
	@Partnumber nvarchar(25),
	@MarcaCodigo nvarchar(5),
	@ComplementoCodigo nvarchar(5)
)
RETURNS nvarchar(40)
AS
BEGIN

	-- variables
	DECLARE @complemento nvarchar(7) = ''; -- ComplementoCodigo + Parenteses = 5 + 2 = 7
	DECLARE @partnumberSimplificado nvarchar(25);

	-- simplify partnumber to be used as part of product code
	SET @partnumberSimplificado = [dbo].[GetCotacaoPartnumberSimplificadoFunction](@Partnumber)

	-- define addon part to be concatenated
	IF UPPER(@ComplementoCodigo) <> 'N/A' AND LEN(RTRIM(@ComplementoCodigo)) > 0
	BEGIN
		SET @complemento = '[' + RTRIM(UPPER(@ComplementoCodigo)) + ']';
	END

	-- return the product code to be used
	RETURN RTRIM(@MarcaCodigo) + @partnumberSimplificado + @complemento;
END
GO
PRINT N'Creating [dbo].[GetCotacaoPrecoFunction]...';


GO
/*
	This function pretends to calculate final price of quotation.
	Formula will permit to know later how the final price was calculated.
*/


CREATE FUNCTION [dbo].[GetCotacaoPrecoFunction]
(
	@_Preco decimal(14,4),
	@_OutrosCustos decimal(14,4),
	@_OutrosCustosDescricao nvarchar(128)
)
RETURNS @results TABLE
(
	__id integer PRIMARY KEY NOT NULL IDENTITY(1,1),
	PrecoCusto decimal(14,4) NOT NULL,
	Formula nvarchar(256) NOT NULL
)
AS
BEGIN

	-- variables
	DECLARE @precoCusto decimal(14,4), @formula nvarchar(256);


	-- final cost price is calculated as the sum of Preco with OutrosCustos
	SET @precoCusto = @_Preco + @_OutrosCustos;


	-- now, if @_OutrosCustosDescricao has text inside it, that text it is the justification of existing adicional costs (@_OutrosCustos)
	-- however, if @_OutrosCustos = 0, that description justifies the @_Preco (maybe more expensive because....)
	IF COALESCE(@_OutrosCustosDescricao, '(vazio)') = '(vazio)'
	BEGIN
		SET @formula = 'PrecoCusto = Preco';
	END
	ELSE
	BEGIN
		
		IF @_OutrosCustos <> 0
		BEGIN
			
			-- formula must show that the PrecoCusto is the sum of Preço and OutrosCustos
			SET @formula = 'PrecoCusto = Preco + @OutrosCustos';
			SET @formula = @formula + ' = ';
			SET @formula = @formula + CONVERT(varchar, @_Preco);
			SET @formula = @formula + ' + ';
			SET @formula = @formula + ' (';
			SET @formula = @formula + LOWER(RTRIM(@_OutrosCustosDescricao));
			SET @formula = @formula + ': ';
			SET @formula = @formula + CONVERT(varchar, @_OutrosCustos);;
			SET @formula = @formula + ') ';
			SET @formula = @formula + ' = ';
			SET @formula = @formula + CONVERT(varchar, @precoCusto);

		END
		ELSE
		BEGIN

			-- formula must show that the price itself include other associated costs
			SET @formula = 'PrecoCusto = Preco + @OutrosCustos';
			SET @formula = @formula + ' <=> ';
			SET @formula = @formula + CONVERT(varchar, @precoCusto);
			SET @formula = @formula + ' = ';
			SET @formula = @formula + ' Preco + (';
			SET @formula = @formula + LOWER(RTRIM(@_OutrosCustosDescricao));
			SET @formula = @formula + ': ';
			SET @formula = @formula + CONVERT(varchar, @_OutrosCustos);
			SET @formula = @formula + ')';

		END
	END


	-- prepare data to be send back
	INSERT INTO @results
	SELECT @precoCusto, @formula;


	-- terminate
	RETURN;
END
GO
PRINT N'Creating [dbo].[GetCotacaoStockSubstitutoFunction]...';


GO
/*
	This function pretends to show what will be the substitute StockCodigo, if applicable.
	Formula will show wy there is a substitute StockCodigo
*/


CREATE FUNCTION [dbo].[GetCotacaoStockSubstitutoFunction]
(
	@StockCodigo nvarchar(5),
	@CotacoesRegras_StockCodigo nvarchar(5),
	@ProdutosMatching_StockCodigo nvarchar(5)
)
RETURNS @results TABLE
(
	__id integer PRIMARY KEY NOT NULL IDENTITY(1,1),
	StockCodigo nvarchar(5) NULL,
	Justificacao nvarchar(256) NULL
)
AS
BEGIN

	-- variables
	DECLARE @stockCodigoNovo nvarchar(5), @justificacao nvarchar(256);


	-- if there is a custom define StockCodigo for the product, use it
	SELECT 
			@stockCodigoNovo =
				CASE WHEN @ProdutosMatching_StockCodigo IS NOT NULL THEN @ProdutosMatching_StockCodigo
					 WHEN @CotacoesRegras_StockCodigo IS NOT NULL THEN @CotacoesRegras_StockCodigo
					 ELSE NULL
				END,

			@justificacao =
				CASE WHEN @ProdutosMatching_StockCodigo IS NOT NULL THEN '!ProdutosMatching - regra de utilizador'
					 WHEN @CotacoesRegras_StockCodigo IS NOT NULL THEN '!CotacoesRegras - regra de utilizador'
					 ELSE NULL
				END


	-- prepare data to be send back
	INSERT INTO @results
	SELECT @stockCodigoNovo, @justificacao;


	-- terminate
	RETURN;
END
GO
PRINT N'Creating [dbo].[GetCotacaoValidadeFunction]...';


GO
/*
	This function pretends to set with more accuracy the expiration date of received quotation.
	It returns a table with two fields: first the expiration date and the second with a formula that demonstrates the calculation of that date.
*/


CREATE FUNCTION [dbo].[GetCotacaoValidadeFunction]
(
	@Data datetime,
	@_Validade smalldatetime,
	@_ValidadeDescricao nvarchar(128),
	@CotacoesRegras_HorasValidade smallint,
	@ProdutosMatching_HorasValidade smallint
)
RETURNS @results TABLE
(
	__id integer PRIMARY KEY NOT NULL IDENTITY(1,1),
	Validade smalldatetime NOT NULL,
	Formula nvarchar(256) NOT NULL
)
AS
BEGIN

	-- variables
	DECLARE @horasValidade integer, @validade smalldatetime, @formula nvarchar(256);


	-- if some expiration date has come from supplier then use it
	IF @_Validade <> CAST('01-01-2000' as smalldatetime)
	BEGIN
		
		-- expiration will be the received date
		SET @validade = @_Validade;
		SET @formula = 'validade definida pelo fornecedor: ';
		SET @formula = @formula + LOWER(RTRIM(@_ValidadeDescricao));

		-- prepare data to be send back
		INSERT INTO @results
		SELECT @validade, @formula;

		-- terminate
		RETURN;

	END


	-- the most mandatory rule is when it is defined a specific rule for the product itself.
	-- so, if there is a value defined for the product this rules prevails, but if not, the definition used on
	-- CotacoesRegras table.
	IF @ProdutosMatching_HorasValidade <> 0
	BEGIN
		SET @horasValidade = @ProdutosMatching_HorasValidade;
	END
	ELSE
	BEGIN
		SET @horasValidade = @CotacoesRegras_HorasValidade;
	END


	-- expiration date calculation
	SET @validade = DATEADD(HOUR, @horasValidade, @Data);


	-- set the formula to documentate in future this calculation
	IF @ProdutosMatching_HorasValidade <> 0
	BEGIN
		-- set the formula to future documentation
		SET @formula = 'validade = data + pmhv';
		SET @formula = @formula + ' = ';
		SET @formula = @formula + CONVERT(varchar, @Data, 120);
		SET @formula = @formula + ' + ';
		SET @formula = @formula + CONVERT(varchar, @ProdutosMatching_HorasValidade) + 'horas';
		SET @formula = @formula + ' = ';
		SET @formula = @formula + CONVERT(varchar, @validade, 120);
	END
	ELSE
	BEGIN
		-- set the formula to future documentation
		SET @formula = 'validade = data + crhv';
		SET @formula = @formula + ' = ';
		SET @formula = @formula + CONVERT(varchar, @Data, 120);
		SET @formula = @formula + ' + ';
		SET @formula = @formula + CONVERT(varchar, @CotacoesRegras_HorasValidade) + 'horas';
		SET @formula = @formula + ' = ';
		SET @formula = @formula + CONVERT(varchar, @validade, 120);
	END


	-- prepare data to be send back
	INSERT INTO @results
	SELECT @validade, @formula;


	-- terminate
	RETURN;
END
GO
PRINT N'Creating [dbo].[GetProdutoMedidasDisponibilidadeFunction]...';


GO
/*
	This function generates product statistics:

		> U1VD - last availability variation (x = 1 not changed, x > 1 means availability level was rise and x < 1 means the availability level was dropped
		> U2VD - penultimate...
		> U3VD - antepenultimate...

		> EED (Estatistica de Estabilidade da Disponibilidade) means Statistic of Stability of Availability.
	          Represents a estimation in days of the stability of actual Stock Availability level.
			  How much days will the current level of availability stay actual.

		> ICD (Indice de Confiança na Disponibilidade) means Availability Trust Index.
		      Thats a value between [0:1] that represents the current level of availability trust.

			  ICD = 0.5CE + 0.2CT + 0.3CF

		> CE  (Componente Estabilidade) Estability Component
		      Is the availability level trust in prespective to EED. 
		
		> CT  (Componente Tendencia) Trend Component
			  Is the availability trust in prespective of last evolution of stock availability.

		> CF  (Confiança Fornecedor) Trust on the Supplier
			  Is the trust that exists on the supplier (supplier table record)

*/

CREATE FUNCTION [dbo].GetProdutoMedidasDisponibilidadeFunction
(
	@U3Disponivel smallint,
	@U3Data smalldatetime,
	@U2Disponivel smallint,
	@U2Data smalldatetime,
	@U1Disponivel smallint,
	@U1Data smalldatetime,
	@UDisponivel smallint,
	@UData smalldatetime,
	@ConfiancaFornecedor float
)
RETURNS @results TABLE
(
	__idMedidaDisponibilidade integer PRIMARY KEY NOT NULL IDENTITY(1,1),
	U3VD float NULL,
	U2VD float NULL,
	U1VD float NULL,
	EED float NOT NULL,
	ICD float NOT NULL,
	EEDFormula nvarchar(256),
	ICDCEFormula nvarchar(256),
	ICDCTFormula nvarchar(256),
	ICDCFFormula nvarchar(256),
	ICDFormula nvarchar(256)
)
AS
BEGIN

	-- variables
	DECLARE @eedFormula nvarchar(256), @icdFormula nvarchar(256), @ceFormula nvarchar(256), @ctFormula nvarchar(256), @cfFormula nvarchar(256),
	        @u3vd float, @u2vd float, @u1vd float, @eed float, @icd float, @ce float, @ct float, @cf float;


	-- initialize variables
	SET @eedFormula = '';
	SET @icdFormula = '';
	SET @ceFormula = '';
	SET @ctFormula = '';
	SET @cfFormula = '';
	SET @u3vd = NULL;
	SET @u2vd = NULL;
	SET @u1vd = NULL;
	SET @eed = 1;	-- minimum stability: 1 day
	SET @icd = 0;
	SET @ce = 0;
	SET @ct = 0;
	SET @cf = 0



	-- trend calculation
	IF @U3Disponivel IS NOT NULL	-- if this level it is not null, then we have the guarantee that @U2Disponivel it isn't too.
	BEGIN
		SET @u3vd = CAST(@U2Disponivel as float) - @U3Disponivel;
	END

	IF @U2Disponivel IS NOT NULL	-- if this level it is not null, then we have the guarantee that @U1Disponivel it isn't too.
	BEGIN
		SET @u2vd = CAST(@U1Disponivel as float) - @U2Disponivel;
	END

	IF @U1Disponivel IS NOT NULL	-- if this level it is not null, then we have the guarantee that @UDisponivel it isn't too.
	BEGIN
		SET @u1vd = CAST(@UDisponivel as float) - @U1Disponivel;
	END



	-- EED and EEDFormula calculation
	SELECT @eed =
				CASE WHEN @U3Data IS NOT NULL THEN 
													0.1 * DATEDIFF(DAY, @U3Data, @U2Data) +
													0.2 * DATEDIFF(DAY, @U2Data, @U1Data) +
													0.7 * DATEDIFF(DAY, @U1Data, @UData)

					 WHEN @U2Data IS NOT NULL THEN	
													0.2 * DATEDIFF(DAY, @U2Data, @U1Data) +
													0.7 * DATEDIFF(DAY, @U1Data, @UData)

					 WHEN @U1Data IS NOT NULL THEN	
													0.7 * DATEDIFF(DAY, @U1Data, @UData)

					 ELSE 1
				END,

			@eedFormula = 
				CASE WHEN @U3Data IS NOT NULL THEN 
													'EED = 0.1(U3Data - U2Data) + ' +
														  '0.2(U2Data - U1Data) + ' +
													      '0.7(U1Data - UData) <=> ' +
													'EED = 0.1(' + CONVERT(varchar, @U3Data, 103) + ' - ' + CONVERT(varchar, @U2Data, 103)  + ') + ' +
													      '0.2(' + CONVERT(varchar, @U2Data, 103) + ' - ' + CONVERT(varchar, @U1Data, 103)  + ') + ' +
														  '0.7(' + CONVERT(varchar, @U1Data, 103) + ' - ' + CONVERT(varchar, @UData, 103)  + ') <=> ' +
													'EED = ' + CAST(@eed as varchar)

					 WHEN @U2Data IS NOT NULL THEN	
													'EED = 0.2(U2Data - U1Data) + ' +
													      '0.7(U1Data - UData) <=> ' +
													'EED = 0.2(' + CONVERT(varchar, @U2Data, 103) + ' - ' + CONVERT(varchar, @U1Data, 103)  + ') + ' +
														  '0.7(' + CONVERT(varchar, @U1Data, 103) + ' - ' + CONVERT(varchar, @UData, 103)  + ') <=> ' +
													'EED = ' + CAST(@eed as varchar)

					 WHEN @U1Data IS NOT NULL THEN	
													'EED = 0.7(U1Data - UData) <=> ' +
													'EED = 0.7(' + CONVERT(varchar, @U1Data, 103) + ' - ' + CONVERT(varchar, @UData, 103)  + ') <=> ' +
													'EED = ' + CAST(@eed as varchar)

					 ELSE 'EED = 1 (default)'
			    END



	
	-- CE (ICD component calculation)
	IF @UData IS NOT NULL
	BEGIN
		
		-- CE calculation
		SELECT @ce = (1 - (DATEDIFF(DAY, @UData, GETDATE()) / @eed));

		-- CE formula calculation
		SELECT @ceFormula = 'CE = (1 - ((Hoje - UData) / EEP)) <=> ' +
							'CE = (1 - ((' + CONVERT(varchar, GETDATE(), 103) + ' - ' + CONVERT(varchar, @UData, 103) + ') / ' + CAST(@eed as varchar)  + ')) <=> ' +
							'CE = ' + CAST(@ce as varchar);
	END
	ELSE
	BEGIN
		-- default
		SELECT @ce = 0, 
			   @ceFormula = 'CE = 0 (default)';
	END




	-- CT (ICD component calculation)
	IF @U1Disponivel IS NOT NULL -- we have sure that @UDisponivel is not null too
	BEGIN

		-- CT calculation
		SELECT @ct = 
				   CASE WHEN @UDisponivel < @U1Disponivel THEN (1 - ABS(((CAST(@UDisponivel as float) - @U1Disponivel) / 11) * 5))
						ELSE (1 - ABS((CAST(@UDisponivel as float) - @U1Disponivel) / 11))
				   END;

		-- CT formula calculation
		SELECT @ctFormula = 
				   CASE WHEN @UDisponivel < @U1Disponivel THEN 
														'CT = (1 - |((UDisponivel - U1Disponivel) / 11) * 5|) <=> ' + 
														'CT = (1 - |(((' + CONVERT(varchar, @UDisponivel) + ') - (' + CONVERT(varchar, @U1Disponivel) + ')) / 11) * 5|) <=> ' +
														'CT = ' + CAST(@ct as varchar)
						ELSE 
							  'CT = (1 - |(UDisponivel - U1Disponivel) / 11|) <=> ' + 
							  'CT = (1 - |((' + CONVERT(varchar, @UDisponivel) + ') - (' + CONVERT(varchar, @U1Disponivel) + ')) / 11|) <=> ' +
							  'CT = ' + CAST(@ct as varchar)
				   END;
	END
	ELSE
	BEGIN
		-- default
		SELECT @ct = 0, 
			   @ctFormula = 'CT = 0 (default)';
	END




	-- CF (ICP component calculation)
	IF @ConfiancaFornecedor IS NOT NULL
	BEGIN
		
		-- CF calculation
		SELECT @cf = @ConfiancaFornecedor / 100;

		-- CF formula calculation
		SELECT @cfFormula = 'CF = (ConfiancaFornecedor / 100) <=> ' +
							'CF = (' + CAST(@ConfiancaFornecedor as varchar) + ' / 100) <=> ' +
							'CF = ' + CAST(@cf as varchar);

	END
	ELSE
	BEGIN
		-- default
		SELECT @cf = 0, 
			   @cfFormula = 'CF = 0 (default)';
	END




	-- ICD calculation
	SELECT @icd = (0.5 * @ce) + (0.2 * @ct) + (0.3 * @cf);

	-- ICD Formula calculation
	SELECT @icdFormula = 'ICD = 0.5CE + 0.2CT + 0.3CF <=> ' + 
						 'ICD = (0.5 * ' + CAST(@ce as varchar) + ') + (0.2 * ' + CAST(@ct as varchar) + ') + (0.3 * ' + CAST(@cf as varchar) + ') <=> ' +
						 'ICD = ' + CAST(@icd as varchar);

	-- ICD must be inside [0:1] interval
	SELECT @icdFormula =
					CASE WHEN @icd < 0 THEN @icdFormula + ', !E [0:1] => ICP = 0'
					     WHEN @icd > 1 THEN @icdFormula + ', !E [0:1] => ICP = 1'
						 ELSE @icdFormula
					END,
			@icd =
					CASE WHEN @icd < 0 THEN 0
					     WHEN @icd > 1 THEN 1
						 ELSE @icd
					END;
		  


	-- send back results
	INSERT INTO @results
	SELECT @u3vd, @u2vd, @u1vd, @eed, @icd, @eedFormula, @ceFormula, @ctFormula, @cfFormula, @icdFormula;


	-- the end
	RETURN;
END
GO
PRINT N'Creating [dbo].[GetProdutoMedidasPrecoFunction]...';


GO
/*
	This function generates product statistics:

		> U1VP - last price variation (x = 1 not changed, x > 1 means price was rise and x < 1 means the price was dropped
		> U2VP - penultimate...
		> U3VP - antepenultimate...

		> EEP (Estatistica de Estabilidade de Preço) means Price Stability Statistic.
	          Represents a estimation in days of the stability of actual price.

		> ICP (Indice de Confiança no Preço) means Price Trust Index.
		      Thats a value between [0:1] that represents the current price trust.

			  ICP = 0.5CE + 0.2CT + 0.3CF

		> CE  (Componente Estabilidade) Estability Component
		      Is the price trust in prespective to EEP. 
		
		> CT  (Componente Tendencia) Trend Component
			  Is the price trust in prespective of last evolution of the price.

		> CF  (Confiança Fornecedor) Trust on the Supplier
			  Is the trust that exists on the supplier (supplier table record)

*/

CREATE FUNCTION [dbo].GetProdutoMedidasPrecoFunction
(
	@U3Preco decimal(14,4),
	@U3Data smalldatetime,
	@U2Preco decimal(14,4),
	@U2Data smalldatetime,
	@U1Preco decimal(14,4),
	@U1Data smalldatetime,
	@UPreco decimal(14,4),
	@UData smalldatetime,
	@ConfiancaFornecedor float
)
RETURNS @results TABLE
(
	__idMedidaPreco integer PRIMARY KEY NOT NULL IDENTITY(1,1),
	U3VP decimal(14,4) NULL,
	U2VP decimal(14,4) NULL,
	U1VP decimal(14,4) NULL,
	EEP float NOT NULL,
	ICP float NOT NULL,
	EEPFormula nvarchar(256),
	ICPCEFormula nvarchar(256),
	ICPCTFormula nvarchar(256),
	ICPCFFormula nvarchar(256),
	ICPFormula nvarchar(256)
)
AS
BEGIN

	-- variables
	DECLARE @eepFormula NVARCHAR(256), @icpFormula nvarchar(256), @ceFormula nvarchar(256), @ctFormula nvarchar(256), @cfFormula nvarchar(256),
	        @u3vp float, @u2vp float, @u1vp float, @eep float, @icp float, @ce float, @ct float, @cf float;


	-- initialize variables
	SET @eepFormula = '';
	SET @icpFormula = '';
	SET @ceFormula = '';
	SET @ctFormula = '';
	SET @cfFormula = '';
	SET @u3vp = NULL;
	SET @u2vp = NULL;
	SET @u1vp = NULL;
	SET @eep = 1;	-- minimum stability: 1 day
	SET @icp = 0;
	SET @ce = 0;
	SET @ct = 0;
	SET @cf = 0



	-- trend calculation
	IF @U3Preco IS NOT NULL	-- if this price it is not null, then we have the guarantee that @U2Preco it isn't too.
	BEGIN
		SET @u3vp = @U2Preco / @U3Preco;
	END

	IF @U2Preco IS NOT NULL -- if this price it is not null, then we have the guarantee that @U1Preco it isn't too.
	BEGIN
		SET @u2vp = @U1Preco / @U2Preco;
	END

	IF @U1Preco IS NOT NULL -- if this price it is not null, then we have the guarantee that @UPreco it isn't too.
	BEGIN
		SET @u1vp = @UPreco / @U1Preco;
	END



	-- EEP and EEPFormula calculation
	SELECT @eep =
				CASE WHEN @U3Data IS NOT NULL THEN 
													0.1 * DATEDIFF(DAY, @U3Data, @U2Data) +
													0.4 * DATEDIFF(DAY, @U2Data, @U1Data) +
													0.5 * DATEDIFF(DAY, @U1Data, @UData)

					 WHEN @U2Data IS NOT NULL THEN	
													0.4 * DATEDIFF(DAY, @U2Data, @U1Data) +
													0.5 * DATEDIFF(DAY, @U1Data, @UData)

					 WHEN @U1Data IS NOT NULL THEN	
													0.5 * DATEDIFF(DAY, @U1Data, @UData)

					 ELSE 1
				END,

			@eepFormula = 
				CASE WHEN @U3Data IS NOT NULL THEN 
													'EEP = 0.1(U3Data - U2Data) + ' +
														  '0.4(U2Data - U1Data) + ' +
													      '0.5(U1Data - UData) <=> ' +
													'EEP = 0.1(' + CONVERT(varchar, @U3Data, 103) + ' - ' + CONVERT(varchar, @U2Data, 103)  + ') + ' +
													      '0.4(' + CONVERT(varchar, @U2Data, 103) + ' - ' + CONVERT(varchar, @U1Data, 103)  + ') + ' +
														  '0.5(' + CONVERT(varchar, @U1Data, 103) + ' - ' + CONVERT(varchar, @UData, 103)  + ') <=> ' +
													'EEP = ' + CAST(@eep as varchar)

					 WHEN @U2Data IS NOT NULL THEN	
													'EEP = 0.4(U2Data - U1Data) + ' +
													      '0.5(U1Data - UData) <=> ' +
													'EEP = 0.4(' + CONVERT(varchar, @U2Data, 103) + ' - ' + CONVERT(varchar, @U1Data, 103)  + ') + ' +
														  '0.5(' + CONVERT(varchar, @U1Data, 103) + ' - ' + CONVERT(varchar, @UData, 103)  + ') <=> ' +
													'EEP = ' + CAST(@eep as varchar)

					 WHEN @U1Data IS NOT NULL THEN	
													'EEP = 0.5(U1Data - UData) <=> ' +
													'EEP = 0.5(' + CONVERT(varchar, @U1Data, 103) + ' - ' + CONVERT(varchar, @UData, 103)  + ') <=> ' +
													'EEP = ' + CAST(@eep as varchar)

					 ELSE 'EEP = 1 (default)'
			    END



	
	-- CE (ICP component calculation)
	IF @UData IS NOT NULL
	BEGIN
		
		-- CE calculation
		SELECT @ce = (1 - (DATEDIFF(DAY, @UData, GETDATE()) / @eep));

		-- CE formula calculation
		SELECT @ceFormula = 'CE = (1 - ((Hoje - UData) / EEP)) <=> ' +
							'CE = (1 - ((' + CONVERT(varchar, GETDATE(), 103) + ' - ' + CONVERT(varchar, @UData, 103) + ') / ' + CAST(@eep as varchar)  + ')) <=> ' +
							'CE = ' + CAST(@ce as varchar);
	END
	ELSE
	BEGIN
		-- default
		SELECT @ce = 0, 
			   @ceFormula = 'CE = 0 (default)';
	END




	-- CT (ICP component calculation)
	IF @U1Preco IS NOT NULL -- we have sure that @UPreco is not null too
	BEGIN

		-- CT calculation
		SELECT @ct = 
				   CASE WHEN @UPreco > @U1Preco THEN (@U1Preco / @UPreco) - (50 * (1 - (@U1Preco / @UPreco)))
						ELSE (@UPreco / @U1Preco)
				   END;

		-- CT formula calculation
		SELECT @ctFormula = 
				   CASE WHEN @UPreco > @U1Preco THEN 
														'CT = (U1Preco / UPreco) - ' + 
																	'(50 * (1 - (@U1Preco / @UPreco))) <=> ' +
														'CT = (' + CONVERT(varchar, @U1Preco) + ' / ' + CONVERT(varchar, @UPreco) + ') - ' +
																	'(50 * (1 - (' + CONVERT(varchar, @U1Preco) + ' / ' + CONVERT(varchar, @UPreco) + '))) <=> ' +
														'CT = ' + CAST(@ct as varchar)
						ELSE 
							  'CT = (UPreco / U1Preco) <=> ' +
							  'CT = (' + CONVERT(varchar, @UPreco) + ' / ' + CONVERT(varchar, @U1Preco) + ') <=> ' +
							  'CT = ' + CAST(@ct as varchar)
				   END;
	END
	ELSE
	BEGIN
		-- default
		SELECT @ct = 0, 
			   @ctFormula = 'CT = 0 (default)';
	END




	-- CF (ICP component calculation)
	IF @ConfiancaFornecedor IS NOT NULL
	BEGIN
		
		-- CF calculation
		SELECT @cf = @ConfiancaFornecedor / 100;

		-- CF formula calculation
		SELECT @cfFormula = 'CF = (ConfiancaFornecedor / 100) <=> ' +
							'CF = (' + CAST(@ConfiancaFornecedor as varchar) + ' / 100) <=> ' +
							'CF = ' + CAST(@cf as varchar);

	END
	ELSE
	BEGIN
		-- default
		SELECT @cf = 0, 
			   @cfFormula = 'CF = 0 (default)';
	END




	-- ICP calculation
	SELECT @icp = (0.5 * @ce) + (0.2 * @ct) + (0.3 * @cf);

	-- ICP Formula calculation
	SELECT @icpFormula = 'ICP = 0.5CE + 0.2CT + 0.3CF <=> ' + 
						 'ICP = (0.5 * ' + CAST(@ce as varchar) + ') + (0.2 * ' + CAST(@ct as varchar) + ') + (0.3 * ' + CAST(@cf as varchar) + ') <=> ' +
						 'ICP = ' + CAST(@icp as varchar);

	-- ICP must be inside [0:1] interval
	SELECT @icpFormula =
					CASE WHEN @icp < 0 THEN @icpFormula + ', !E [0:1] => ICP = 0'
					     WHEN @icp > 1 THEN @icpFormula + ', !E [0:1] => ICP = 1'
						 ELSE @icpFormula
					END,
			@icp =
					CASE WHEN @icp < 0 THEN 0
					     WHEN @icp > 1 THEN 1
						 ELSE @icp
					END;
		  



	-- send back results
	INSERT INTO @results
	SELECT @u3vp, @u2vp, @u1vp, @eep, @icp, @eepFormula, @ceFormula, @ctFormula, @cfFormula, @icpFormula;


	-- the end
	RETURN;
END
GO
PRINT N'Creating [dbo].[SplitStringFunction]...';


GO
/*
	this function receives a string and returns a table with all splitted terms.
*/

CREATE FUNCTION [dbo].[SplitStringFunction]
(
	@stringToSplit nvarchar(256),
	@splitChar char(1)
)
RETURNS @list TABLE 
(
	[Element] nvarchar(256)
)
BEGIN
	
	-- variables
	DECLARE @name nvarchar(256), @pos integer;

	-- build list of splitted terms
	WHILE CHARINDEX(@splitChar, @stringToSplit) > 0
	BEGIN

		-- keep term and current position
		SELECT @pos = CHARINDEX(@splitChar, @stringToSplit);
		SELECT @name = SUBSTRING(@stringToSplit, 1, @pos-1);

		-- insert extracted term into @list
		INSERT INTO @list
		SELECT @name;

		-- new stringToSplit is reduced
		SELECT @stringToSplit = SUBSTRING(@stringToSplit, @pos+1, LEN(@stringToSplit)-@pos);

	END

	-- finally
	INSERT INTO @list
	SELECT @stringToSplit;

	-- get out
	RETURN
END
GO
PRINT N'Creating [dbo].[GetCotacaoDescricaoFunction]...';


GO
/*
	This function receives the original description, brand name, partnumber, text to add and text to remove,
	and build a uniformed complete final product description
*/


CREATE FUNCTION [dbo].[GetCotacaoDescricaoFunction]
(
	@_Descricao nvarchar(256),
	@MarcaDescricao nvarchar(50),
	@Partnumber nvarchar(25),
	@TermoAcrescentar nvarchar(50),
	@TermosRemover nvarchar(100)
)
RETURNS nvarchar(256)
AS
BEGIN
	
	-- variables
	DECLARE @descricao nvarchar(256);


	-- evaluate pré-requisits
	IF (@TermoAcrescentar IS NULL)
	BEGIN
		SET @TermoAcrescentar = '';
	END

	IF (@TermosRemover IS NULL)
	BEGIN
		SET @TermosRemover = '';
	END


	-- force lowercase to description
	SET @descricao = LOWER(@_Descricao);


	-- ensure that brand name is there
	IF CHARINDEX(RTRIM(LOWER(@MarcaDescricao)), @descricao) = 0
	BEGIN
		SET @descricao = RTRIM(@descricao) + ' ' + RTRIM(LOWER(@MarcaDescricao));
	END


	-- ensure that partnumber is there
	IF CHARINDEX(RTRIM(LOWER(@Partnumber)), @descricao) = 0
	BEGIN
		SET @descricao = RTRIM(@descricao) + ' ' + RTRIM(LOWER(@Partnumber));
	END


	-- remove undesirable terms (if the received string has chars)
	IF LEN(RTRIM(@TermosRemover)) > 0
	BEGIN
		
		-- local variables
		DECLARE @termo as nvarchar(256);
		DECLARE termosCursor CURSOR FOR
			SELECT DISTINCT Element
			FROM [dbo].[SplitStringFunction](LOWER(@TermosRemover),',');

		-- load cursor
		OPEN termosCursor;

		-- first fetch
		FETCH NEXT FROM termosCursor INTO @termo;

		-- iterate all records in cursor
		WHILE @@FETCH_STATUS = 0
		BEGIN

			-- remove term
			SET @descricao = REPLACE(@descricao, RTRIM(LTRIM(@termo)), '');

			-- next fetch
			FETCH NEXT FROM termosCursor INTO @termo;

		END

		-- close cursor
		CLOSE termosCursor;
		DEALLOCATE termosCursor;

	END



	-- concatenate term to add
	IF LEN(@TermoAcrescentar) > 0 
	BEGIN
		SET @descricao = @descricao + ' ' + @TermoAcrescentar;
	END



	-- final bad chars cleaning
	SET @descricao = [dbo].[CleanBadCharsFunction](@descricao);
		
	-- send back the normalized description
	RETURN @descricao;
END
GO
PRINT N'Creating [dbo].[CotacoesAtivasView]...';


GO
/*
	NOTA:
	Esta view materializada, representa todas as cotações inativas = 'false'
		> Incompletas
		> Completas
		> Integradas

	- A view é materializada atendendo ao facto de poder representar um enorme volume de informação
*/


CREATE VIEW [dbo].[CotacoesAtivasView] WITH SchemaBinding -- todos os campos têm que ser especificados pelo facto de ser uma view materializada
	AS 
	SELECT [FornecedorCodigo], [Data], [_ProdutoCodigo], [_ComplementoCodigo], [_ComplementoDescricao],
	       [_Partnumber], [_MarcaCodigo], [_MarcaDescricao], [_CategoriaCodigo], [_CategoriaDescricao], [_StockCodigo], [_StockDescricao],
		   [_ImpostoCodigo], [_ImpostoDescricao], [_EstadoCodigo], [_EstadoDescricao], [_Descricao], [_Link], [_Caracteristicas], [_Imagem], 
		   [_Preco], [_OutrosCustos], [_OutrosCustosDescricao], [_Validade], [_ValidadeDescricao],
		   [ComplementoCodigo], [Partnumber], [MarcaCodigo], [CategoriaCodigo], 
		   [StockCodigo], [StockCodigoSubstituto], [StockCodigoSubstitutoJustificacao], 
		   CASE WHEN [StockCodigoSubstituto] IS NULL THEN [StockCodigo] ELSE [StockCodigoSubstituto] END AS [StockCodigoEfetivo],
		   [ImpostoCodigo], [EstadoCodigo], [Descricao], [Link], [Caracteristicas], [Imagem], 
		   [PrecoCusto], [PrecoCustoFormula], [Validade], [ValidadeFormula], 
		   [ProdutoCodigo], 
		   [Completo], [Integrado],
		   [Inativo], [Versao]
	
	FROM [dbo].[Cotacoes]
	WHERE [Inativo] = CAST('false' as bit);


-- O indice que torna esta view materializada chama-se IDX_CotacoesAtivas.
GO
PRINT N'Creating [dbo].[CotacoesAtivasView].[CotacoesAtivasViewIndex]...';


GO
CREATE UNIQUE CLUSTERED INDEX [CotacoesAtivasViewIndex]
    ON [dbo].[CotacoesAtivasView]([FornecedorCodigo] ASC, [Data] ASC, [_ProdutoCodigo] ASC, [_ComplementoCodigo] ASC);


GO
PRINT N'Creating [dbo].[CotacoesAtuaisView]...';


GO
/*
	Esta View facilita a vista sobre as cotações já integradas (ativas). O conjunto de CotacoesAtuais representa o conjunto de cotações
	atualmente válidas de cada fornecedor para cada produto.
	(Uma cotação atual está completa e integrada e significad que pode ser usada como base para o algoritmo de eleição da melhor cotação)
*/

CREATE VIEW [dbo].[CotacoesAtuaisView]
	AS 
	SELECT *
	FROM [dbo].[CotacoesAtivasView]
	WHERE [Integrado] = CAST('true' as bit)
GO
PRINT N'Creating [dbo].[CotacoesIncompletasView]...';


GO
/*
	Esta View facilita a vista sobre as cotações incompletas e, lógicamente, não integradas (já que uma cotação só pode ser integrada depois de estar completa)
	(Uma cotação incompleta é aquela que falta informação, por exemplo, mapeamentos...)
	(Uma cotação incompleta é uma cotação que ainda falta sofrer processamento para poder ser integrada!)
*/

CREATE VIEW [dbo].[CotacoesIncompletasView]
	AS 
	SELECT *
	FROM [dbo].[CotacoesAtivasView]
	WHERE [Completo] = CAST('false' as bit)
GO
PRINT N'Creating [dbo].[CotacoesNaoIntegradasView]...';


GO
/*
	Esta View facilita a vista sobre as cotações completas mas ainda não integradas 
	(candidatas a integrar ou seja candidatas a CotacoesAtuais)
*/

CREATE VIEW [dbo].[CotacoesNaoIntegradasView]
	AS 
	SELECT *
	FROM [dbo].[CotacoesAtivasView]
	WHERE [Completo] = CAST('true' as bit)
		  AND [Integrado] = CAST('false' as bit)
GO
PRINT N'Creating [dbo].[CotacoesVencedorasView]...';


GO
/*
	This view shows all winner quotations. 
	Winner Quotations are all Actual Quotations (one by ProdutoCodigo) that it is the best offer (stock + price).
	It's based on winner quotations that is made the update of price on product record.
*/

CREATE VIEW [dbo].[CotacoesVencedorasView]
	AS 
		
	SELECT *
	FROM
		(

			SELECT cc1.*, ROW_NUMBER() OVER (PARTITION BY cc1.ProdutoCodigo 
													   ORDER BY s3.DisponibilidadeNivel DESC
											) AS Classificacao2
			FROM
				(

					-- subset of Actual Quotations with stock availability
					SELECT c1.*,
						   ROW_NUMBER() OVER (PARTITION BY c1.ProdutoCodigo 
														ORDER BY c1.PrecoCusto ASC,
																 ((f1.ProdutosConfiancaPreco + f1.ProdutosConfiancaDisponibilidade) / 2) DESC
											 ) AS Classificacao1

					FROM [dbo].[CotacoesAtuaisView] c1
						 INNER JOIN [dbo].[Fornecedores] f1
							   ON c1.FornecedorCodigo = f1.Codigo
						 INNER JOIN [dbo].[Stocks] s1
							   ON c1.StockCodigoEfetivo = s1.Codigo

					-- filter only quotations which has availability of stock
					WHERE s1.DisponibilidadeNivel > 0


					UNION


					-- subset of Actual Quotations with no stock availability
					SELECT c2.*,
						   ROW_NUMBER() OVER (PARTITION BY c2.ProdutoCodigo 
														ORDER BY c2.PrecoCusto ASC,
																 ((f2.ProdutosConfiancaPreco + f2.ProdutosConfiancaDisponibilidade) / 2) DESC
											 ) AS Classificacao1

					FROM [dbo].[CotacoesAtuaisView] c2
						 INNER JOIN [dbo].[Fornecedores] f2
							   ON c2.FornecedorCodigo = f2.Codigo
						 INNER JOIN [dbo].[Stocks] s2
							   ON c2.StockCodigoEfetivo = s2.Codigo

					-- filter only quotations which has availability of stock
					WHERE s2.DisponibilidadeNivel <= 0
	
				) cc1
					 INNER JOIN [dbo].[Stocks] s3
						   ON cc1.StockCodigoEfetivo = s3.Codigo
	
			-- filter only
			WHERE cc1.Classificacao1 = 1

		) cc2

	-- only the first quotation of each partition
	WHERE cc2.Classificacao2 = 1
GO
PRINT N'Creating [dbo].[ProdutosAtivosView]...';


GO
/*
	This view shows only active produts (Inativo='false') and not descontinued products (Descontinuado='false')
*/


CREATE VIEW [dbo].[ProdutosAtivosView] WITH SchemaBinding -- all fields must be specified because we want a materialized view
	AS 
	SELECT [Codigo], [Descricao], [Partnumber], [CategoriaCodigo], [MarcaCodigo], [ImpostoCodigo], [FornecedorCodigo],
		   [PrecoCusto], [PrecoCusto_Data], [PrecoCusto_U1], [PrecoCusto_U1Data], [PrecoCusto_U2], [PrecoCusto_U2Data], [PrecoCusto_U3], [PrecoCusto_U3Data],
           [StockCodigo], [StockCodigo_Data], [StockCodigo_U1], [StockCodigo_U1Data], [StockCodigo_U2], [StockCodigo_U2Data], [StockCodigo_U3], [StockCodigo_U3Data],
           [Descontinuado], [Inativo], [Criacao], [Versao]
	FROM [dbo].[Produtos]
	WHERE Inativo = CAST('false' as bit)
		  AND Descontinuado = CAST('false' as bit);


-- index that transforms this view a mateirialized view calls IDX_ProdutosAtivos
GO
PRINT N'Creating [dbo].[ProdutosAtivosView].[ProdutosAtivosViewIndex]...';


GO
CREATE UNIQUE CLUSTERED INDEX [ProdutosAtivosViewIndex]
    ON [dbo].[ProdutosAtivosView]([Codigo] ASC);


GO
PRINT N'Creating [dbo].[ProdutosAtuaisView]...';


GO
/*
	This view shows active not descontinued products with adicional fields

	IPC - (Indice Preocupação Conteudo) means Content Concern Index, and it is a value that represents problematic text that can 
	      exist on each product detail.
*/


CREATE VIEW [dbo].[ProdutosAtuaisView]
	AS 
	SELECT p.*, 
		   mp.*,
		   md.*,
		   COALESCE
			   (
					(
						SELECT MAX(pd.IndicePreocupacaoConteudo)
						FROM [dbo].[ProdutosDetalhe] pd
						WHERE pd.ProdutoCodigo = p.Codigo
					)
			   , 0) IPC


	FROM [dbo].[ProdutosAtivosView] p
		 INNER JOIN [dbo].[Fornecedores] f
			   ON p.FornecedorCodigo = f.Codigo
		 LEFT JOIN [dbo].[Stocks] s3
			  ON p.StockCodigo_U3 = s3.Codigo
		 LEFT JOIN [dbo].[Stocks] s2
			  ON p.StockCodigo_U2 = s2.Codigo
		 LEFT JOIN [dbo].[Stocks] s1
			  ON p.StockCodigo_U1 = s1.Codigo
		 LEFT JOIN [dbo].[Stocks] s
			  ON p.StockCodigo = s.Codigo

		 CROSS APPLY [dbo].GetProdutoMedidasPrecoFunction( 
															p.PrecoCusto_U3, p.PrecoCusto_U3Data,
															p.PrecoCusto_U2, p.PrecoCusto_U2Data,
															p.PrecoCusto_U1, p.PrecoCusto_U1Data,
															p.PrecoCusto, p.PrecoCusto_Data,
															f.ProdutosConfiancaPreco
														 ) mp

		 CROSS APPLY [dbo].GetProdutoMedidasDisponibilidadeFunction(
																			s3.DisponibilidadeNivel, p.StockCodigo_U3Data,
																			s2.DisponibilidadeNivel, p.StockCodigo_U2Data,
																			s1.DisponibilidadeNivel, p.StockCodigo_U1Data,
																			s.DisponibilidadeNivel, p.StockCodigo_Data,
																			f.ProdutosConfiancaDisponibilidade
																   ) md
GO
PRINT N'Creating [dbo].[CotacoesAtuaisAmplitudeExcedidaView]...';


GO
/*
	This view simplifies the process of determining what quotations do not respect the amplitude defined on it's category.
	The set of quotations represented by this view, are the quotations that have problems with amplitude defined on each category.
*/

CREATE VIEW [dbo].[CotacoesAtuaisAmplitudeExcedidaView]
	AS 

	SELECT c.ProdutoCodigo,


		   -- price amplitude of this product
		   MIN(c.PrecoCusto) / MAX(c.PrecoCusto) AS AmplitudePercentual,
		   
		   
		   -- how the deviation of the amplitude has been calculated (formula)
		   '(min/max) < A  <=>  ' +
		   '(' + CAST(MIN(c.PrecoCusto) as nvarchar) + '/' + CAST(MAX(c.PrecoCusto) as nvarchar) + ')  <  ' + CAST(t.PrecoAmplitudeMax as nvarchar) + '  <=>  ' +
		    CAST(ROUND(MIN(c.PrecoCusto) / MAX(c.PrecoCusto), 2) as nvarchar) + '  <  ' + CAST(t.PrecoAmplitudeMax as nvarchar) 
			AS AmplitudeFormulaDetecaoDesfasamento,


			-- calculate which price (min or max) is offset when compared with the average
			CASE 
				 -- if diference between min and avg is greater then the avg to the max
				 WHEN ABS(MIN(c.PrecoCusto) - AVG(c.PrecoCusto)) > (MAX(c.PrecoCusto) - AVG(c.PrecoCusto)) 
							THEN MIN(c.PrecoCusto)

				 -- if diference between min and avg is less then the avg to the max
				 WHEN ABS(MIN(c.PrecoCusto) - AVG(c.PrecoCusto)) < (MAX(c.PrecoCusto) - AVG(c.PrecoCusto)) 
							THEN MAX(c.PrecoCusto)

				 -- if min and max are the same that means that, probably, there are only 2 quotations causing the average to be the same.
				 -- if that happens, we consider that the wrong price is the lowest (min), because it is the most problematic with customers.
				 ELSE 
					MIN(c.PrecoCusto)
			END AS PrecoDesfasado,

			
			-- detecting the offset price (it is min or max the most distant from the average)
			CASE 
				 -- if diference between min and avg is greater then the avg to the max
				 WHEN ABS(MIN(c.PrecoCusto) - AVG(c.PrecoCusto)) > (MAX(c.PrecoCusto) - AVG(c.PrecoCusto)) 
							THEN '| min-avg | > (max-avg)  <=>  ' +
							     '| ' + CAST(MIN(c.PrecoCusto) as nvarchar) + '-' + CAST(AVG(c.PrecoCusto) as nvarchar) + ' | > (' + CAST(MAX(c.PrecoCusto) as nvarchar) + '-' + CAST(AVG(c.PrecoCusto) as nvarchar) + ')  <=>  ' +
								 CAST(ABS(MIN(c.PrecoCusto) - AVG(c.PrecoCusto)) as nvarchar) +' > ' + CAST((MAX(c.PrecoCusto) - AVG(c.PrecoCusto)) as nvarchar) + ' **preço mais barato é o mais afastado da média!'
								 
				 -- if diference between min and avg is less then the avg to the max
				 WHEN ABS(MIN(c.PrecoCusto) - AVG(c.PrecoCusto)) < (MAX(c.PrecoCusto) - AVG(c.PrecoCusto)) 
							THEN '| min-avg | < (max-avg)  <=>  ' +
							     '| ' + CAST(MIN(c.PrecoCusto) as nvarchar) + '-' + CAST(AVG(c.PrecoCusto) as nvarchar) + ' | < (' + CAST(MAX(c.PrecoCusto) as nvarchar) + '-' + CAST(AVG(c.PrecoCusto) as nvarchar) + ')  <=>  ' +
								 CAST(ABS(MIN(c.PrecoCusto) - AVG(c.PrecoCusto)) as nvarchar) +' < ' + CAST((MAX(c.PrecoCusto) - AVG(c.PrecoCusto)) as nvarchar) + ' **preço mais caro é o mais afastado da média!'
					
				 -- if min and max are the same that means that, probably, there are only 2 quotations causing the average to be the same.
				 -- if that happens, we consider that the wrong price is the lowest (min), because it is the most problematic with customers.
				 ELSE 
					  '| min-avg | = (max-avg) <=> probably there are only 2 quotations => consider the lowest price wrong because it is the most dangerous!'
				 
			END AS PrecoDesfasadoFormulaDecisao
			

	FROM [dbo].[CotacoesAtuaisView] c
		 INNER JOIN [dbo].[Categorias] t
			   ON c.CategoriaCodigo = t.Codigo
		 INNER JOIN [dbo].[ProdutosMatching] m
			   ON c.FornecedorCodigo = m.FornecedorCodigo
			      AND c.ComplementoCodigo = m.ComplementoCodigo
				  AND c._ProdutoCodigo = m.Codigo


	-- we want filter only quotations which ProductMatching rules are defined to not prevent PreçosDesfazados
	WHERE m.DispensaPrevencaoPrecosDesfasados = CAST('false' as bit)


	-- preform a group by each ProdutoCodigo
	GROUP BY c.ProdutoCodigo, t.PrecoAmplitudeMax


	-- filter only groups with irregular amplitude 
	-- and the product has more than one quotations to be compared
	HAVING (MIN(c.PrecoCusto) / MAX(c.PrecoCusto)) < t.PrecoAmplitudeMax
		   AND COUNT('-') >= 2
GO
PRINT N'Creating [dbo].[CotacoesAtuaisAmplitudeIrregularView]...';


GO
/*
	Quotations of this view will be configured as disabled because it's offset price...
*/

CREATE VIEW [dbo].[CotacoesAtuaisAmplitudeIrregularView]
	AS 

	SELECT c.*,
		   ca.AmplitudePercentual, ca.AmplitudeFormulaDetecaoDesfasamento, ca.PrecoDesfasado, ca.PrecoDesfasadoFormulaDecisao

	FROM [dbo].[CotacoesAtuaisAmplitudeExcedidaView] ca
		 INNER JOIN [dbo].[CotacoesAtuaisView] c
			   ON ca.ProdutoCodigo = c.ProdutoCodigo
				  AND ca.PrecoDesfasado = c.PrecoCusto
GO
PRINT N'Creating [dbo].[CotacoesAtuaisFalsoStockView]...';


GO
/*
	This view simplifies the process of determining fake stock. Creates a view that calculates percentil dates of quotation life,
	to analise which StockCodigo must be used on Stock Substitution. 

	This view uses the GetValidadePercentilFunction to calculate the date inside de specified interval, correspondent to the given percentil
*/

CREATE VIEW [dbo].[CotacoesAtuaisFalsoStockView]
	AS 

	SELECT 

		   -- all fields from atual quotations
		   c.*,
		   
		   -- necessary fields from stocks table
		   s.ValidadeP50_StockCodigo, s.ValidadeP60_StockCodigo, s.ValidadeP70_StockCodigo, s.ValidadeP80_StockCodigo, s.ValidadeP90_StockCodigo,

		   -- percentil data calculations
		   [dbo].[GetValidadePercentilFunction](c.Data, c.Validade, 50) AS P50,
		   [dbo].[GetValidadePercentilFunction](c.Data, c.Validade, 60) AS P60,
		   [dbo].[GetValidadePercentilFunction](c.Data, c.Validade, 70) AS P70,
		   [dbo].[GetValidadePercentilFunction](c.Data, c.Validade, 80) AS P80,
		   [dbo].[GetValidadePercentilFunction](c.Data, c.Validade, 90) AS P90

	FROM [dbo].[CotacoesAtuaisView] c
		 INNER JOIN [dbo].[Stocks] s
			   ON c.StockCodigoEfetivo = s.Codigo
		 INNER JOIN [dbo].[ProdutosMatching] m
			   ON c.FornecedorCodigo = m.FornecedorCodigo
				  AND c.ComplementoCodigo = m.ComplementoCodigo
			      AND c._ProdutoCodigo = m.Codigo

	-- apply to all actual quotations unless it's productmatching rule set it's dispensing
	WHERE m.DispensaPrevencaoFalsoStock = CAST('false' as bit)
		  AND (
				((GETDATE() >= [dbo].[GetValidadePercentilFunction](c.Data, c.Validade, 90)) AND (s.ValidadeP90_StockCodigo IS NOT NULL))
					OR ((GETDATE() >= [dbo].[GetValidadePercentilFunction](c.Data, c.Validade, 80)) AND (s.ValidadeP80_StockCodigo IS NOT NULL))
					OR ((GETDATE() >= [dbo].[GetValidadePercentilFunction](c.Data, c.Validade, 70)) AND (s.ValidadeP70_StockCodigo IS NOT NULL))
					OR ((GETDATE() >= [dbo].[GetValidadePercentilFunction](c.Data, c.Validade, 60)) AND (s.ValidadeP60_StockCodigo IS NOT NULL))
					OR ((GETDATE() >= [dbo].[GetValidadePercentilFunction](c.Data, c.Validade, 50)) AND (s.ValidadeP50_StockCodigo IS NOT NULL))
			  )
GO
PRINT N'Creating [dbo].[CotacoesAtuaisPrecosForaIntervaloView]...';


GO
/*
	This view simplifies the process of determining what quotations have price out of the category interval...
*/

CREATE VIEW [dbo].[CotacoesAtuaisPrecosForaIntervaloView]
	AS 

	SELECT c.*,
		   t.PrecoMinimoPermitido, t.PrecoMaximoPermitido

	FROM [dbo].[CotacoesAtuaisView] c
		 INNER JOIN [dbo].[Categorias] t
			   ON c.CategoriaCodigo = t.Codigo
		 INNER JOIN [dbo].[ProdutosMatching] m
			   ON c.FornecedorCodigo = m.FornecedorCodigo
				  AND c.ComplementoCodigo = m.ComplementoCodigo
				  AND c._ProdutoCodigo = m.Codigo

	-- filter all Actual Quotations that the price is out of the interval defined on category,
	-- considering only ProductMatching rules that are configured with DispensaPrevencaoPrecosDesfazados = 'false'
	WHERE (c.PrecoCusto < t.PrecoMinimoPermitido OR c.PrecoCusto > t.PrecoMaximoPermitido)
		  AND m.DispensaPrevencaoPrecosDesfasados = CAST('false' as bit)
GO
PRINT N'Creating [dbo].[CotacoesAtuaisRecalcularView]...';


GO
/*
	On this step, we must be sure that all fields in Actual Quotations (CotacoesAtuais) are correctly fulfilled regarding to actual
	ProdutosMatching and CotacoesRegras rules...

	This view reuses functions implemented to step 2 - normalization..
*/

CREATE VIEW [dbo].[CotacoesAtuaisRecalcularView]
	AS 

	SELECT -- original values from CotacoesAtuaisView
		   c.*,

		   -- calculated values of price
		   cp.PrecoCusto AS [PrecoCustoCalculado],
		   cp.Formula AS [FormulaPrecoCustoCalculado],

		   -- calculated values of expiration date
		   cv.Validade AS [ValidadeCalculada],
		   cv.Formula AS [FormulaValidadeCalculada],

		   -- calculated values of surrogate stock code
		   cs.StockCodigo AS [StockCodigoSubstitutoCalculado],
		   cs.Justificacao AS [JustificacaoStockCodigoSubstitutoCalculado],

		   -- get text fields uniformed
		   [dbo].[GetCotacaoDescricaoFunction](c._Descricao, m.Descricao, c.Partnumber, p.TermoAcrescentar, p.TermosRemover) AS [DescricaoUniformizada],
		   [dbo].[GetCotacaoCaracteristicasFunction](c._Caracteristicas) AS [CaracteristicasUniformizadas],
		   [dbo].[GetCotacaoLinkFunction](c._Link) AS [LinkUniformizado],
		   [dbo].[GetCotacaoImagemFunction](c._Imagem) AS [ImagemUniformizada]

	-- link tables and user functions as needed
	FROM [dbo].[CotacoesAtuaisView] c
		 INNER JOIN [dbo].[CotacoesRegras] cr
			   ON c.FornecedorCodigo = cr.FornecedorCodigo
				  AND c.MarcaCodigo = cr.MarcaCodigo
				  AND c.CategoriaCodigo = cr.CategoriaCodigo
				  AND c.StockCodigo = cr.StockCodigo
		 INNER JOIN [dbo].[ProdutosMatching] pm
			   ON c.FornecedorCodigo = pm.FornecedorCodigo
				  AND c.ComplementoCodigo = pm.ComplementoCodigo
				  AND c._ProdutoCodigo = pm.Codigo
		 INNER JOIN [dbo].[Marcas] m
			   ON c.MarcaCodigo = m.Codigo
		 INNER JOIN [dbo].[Complementos] p
			   ON c.ComplementoCodigo = p.Codigo
		 CROSS APPLY [dbo].[GetCotacaoPrecoFunction](c._Preco, c._OutrosCustos, c._OutrosCustosDescricao) cp
		 CROSS APPLY [dbo].[GetCotacaoValidadeFunction](c.Data, c._Validade, c._ValidadeDescricao, cr.HorasValidade, pm.HorasValidadeCotacao) cv
		 CROSS APPLY [dbo].[GetCotacaoStockSubstitutoFunction](c.StockCodigo, cr.StockCodigoSubstituto, pm.StockCodigoSubstituto) cs

	-- we want to filter only quotations that have data to be updated
	WHERE c.PrecoCusto <> cp.PrecoCusto
		  OR c.PrecoCustoFormula <> cp.Formula
		  OR c.Validade <> cv.Validade
		  OR c.ValidadeFormula <> cv.Formula
		  OR c.Descricao <> [dbo].[GetCotacaoDescricaoFunction](c._Descricao, m.Descricao, c.Partnumber, p.TermoAcrescentar, p.TermosRemover)
		  OR c.Caracteristicas <> [dbo].[GetCotacaoCaracteristicasFunction](c._Caracteristicas)
		  OR COALESCE(c.StockCodigoSubstituto, '') <> cs.StockCodigo				-- comparation of null with something else is always false
		  OR COALESCE(c.StockCodigoSubstitutoJustificacao, '') <> cs.Justificacao	-- " " "
GO
PRINT N'Creating [dbo].[CotacoesIncompletasFinalizacaoView]...';


GO
/*
	This view represents all Incomplete Quotations that are ready to be configured as completed (Completo = True)
*/

CREATE VIEW [dbo].[CotacoesIncompletasFinalizacaoView]
	AS 

	SELECT *
	FROM [dbo].[CotacoesIncompletasView] ci

	-- we want to filter only quotations that are fully mapped
	WHERE ci.MarcaCodigo IS NOT NULL
		  AND ci.CategoriaCodigo IS NOT NULL
		  AND ci.StockCodigo IS NOT NULL
		  AND ci.ImpostoCodigo IS NOT NULL
		  AND ci.ComplementoCodigo IS NOT NULL
		  AND ci.EstadoCodigo IS NOT NULL
		  AND ci.ProdutoCodigo IS NOT NULL
		  AND ci.Descricao IS NOT NULL
		  AND ci.Caracteristicas IS NOT NULL
		  AND ci.Link IS NOT NULL
		  AND ci.Imagem IS NOT NULL
		  AND ci.PrecoCusto IS NOT NULL
		  AND ci.PrecoCustoFormula IS NOT NULL
		  AND ci.Validade IS NOT NULL
		  AND ci.ValidadeFormula IS NOT NULL
GO
PRINT N'Creating [dbo].[CotacoesIncompletasMapeamentoProdutoView]...';


GO
/*
	This view represents all Incomplete Quotations that the only map missing it is Produtocodigo.

	This view add Referencia field to CotacoesIncompletasView. 
	This new field represents the Product Code correspondent to Quotations row.
*/

CREATE VIEW [dbo].[CotacoesIncompletasMapeamentoProdutoView]
	AS 
	SELECT *, [dbo].[GetProdutoCodigoFunction](Partnumber, MarcaCodigo, ComplementoCodigo) AS [Referencia]
	FROM [dbo].[CotacoesIncompletasView]
	WHERE MarcaCodigo IS NOT NULL
		  AND CategoriaCodigo IS NOT NULL
		  AND StockCodigo IS NOT NULL
		  AND ImpostoCodigo IS NOT NULL
		  AND ComplementoCodigo IS NOT NULL
		  AND EstadoCodigo IS NOT NULL
		  AND ProdutoCodigo IS NULL
GO
PRINT N'Creating [dbo].[CotacoesIncompletasNormalizacaoView]...';


GO
/*
	This view represents all Incomplete Quotations that are ready to last step of fulfillment - Normalization
	This view consumes SQL User Functions to calculate values to be updated on quotations records.
*/

CREATE VIEW [dbo].[CotacoesIncompletasNormalizacaoView]
	AS 

	SELECT -- original values from CotacoesIncompletasView
		   ci.*,

		   -- calculated values of price
		   cp.PrecoCusto AS [PrecoCustoCalculado],
		   cp.Formula AS [FormulaPrecoCustoCalculado],

		   -- calculated values of expiration date
		   cv.Validade AS [ValidadeCalculada],
		   cv.Formula AS [FormulaValidadeCalculada],

		   -- calculated values of surrogate stock code
		   cs.StockCodigo AS [StockCodigoSubstitutoCalculado],
		   cs.Justificacao AS [JustificacaoStockCodigoSubstitutoCalculado],

		   -- get text fields uniformed
		   [dbo].[GetCotacaoDescricaoFunction](ci._Descricao, m.Descricao, ci.Partnumber, p.TermoAcrescentar, p.TermosRemover) AS [DescricaoUniformizada],
		   [dbo].[GetCotacaoCaracteristicasFunction](ci._Caracteristicas) AS [CaracteristicasUniformizadas],
		   [dbo].[GetCotacaoLinkFunction](ci._Link) AS [LinkUniformizado],
		   [dbo].[GetCotacaoImagemFunction](ci._Imagem) AS [ImagemUniformizada]

	-- link tables and user functions as needed
	FROM [dbo].[CotacoesIncompletasView] ci
		 INNER JOIN [dbo].[CotacoesRegras] cr
			   ON ci.FornecedorCodigo = cr.FornecedorCodigo
				  AND ci.MarcaCodigo = cr.MarcaCodigo
				  AND ci.CategoriaCodigo = cr.CategoriaCodigo
				  AND ci.StockCodigo = cr.StockCodigo
		 INNER JOIN [dbo].[ProdutosMatching] pm
			   ON ci.FornecedorCodigo = pm.FornecedorCodigo
				  AND ci.ComplementoCodigo = pm.ComplementoCodigo
				  AND ci._ProdutoCodigo = pm.Codigo
		 INNER JOIN [dbo].[Marcas] m
			   ON ci.MarcaCodigo = m.Codigo
		 INNER JOIN [dbo].[Complementos] p
			   ON ci.ComplementoCodigo = p.Codigo
		 CROSS APPLY [dbo].[GetCotacaoPrecoFunction](ci._Preco, ci._OutrosCustos, ci._OutrosCustosDescricao) cp
		 CROSS APPLY [dbo].[GetCotacaoValidadeFunction](ci.Data, ci._Validade, ci._ValidadeDescricao, cr.HorasValidade, pm.HorasValidadeCotacao) cv
		 CROSS APPLY [dbo].[GetCotacaoStockSubstitutoFunction](ci.StockCodigo, cr.StockCodigoSubstituto, pm.StockCodigoSubstituto) cs

	-- we want to filter only quotations that are fully mapped
	WHERE ci.MarcaCodigo IS NOT NULL
		  AND ci.CategoriaCodigo IS NOT NULL
		  AND ci.StockCodigo IS NOT NULL
		  AND ci.ImpostoCodigo IS NOT NULL
		  AND ci.ComplementoCodigo IS NOT NULL
		  AND ci.EstadoCodigo IS NOT NULL
		  AND ci.ProdutoCodigo IS NOT NULL
GO
PRINT N'Creating [dbo].[CotacoesMatrizPreenchimentoMapToView]...';


GO
/*
	Shows in a single only row per correspondence FornecedorCodigo, ComplementoCodigo, _ProdutoCodigo,
	quotations that does exist in Product table (Product already exists).

	We want to Map all Product Matching rules that correspondent ProdutoCodigo already exists on Product table.
*/


CREATE VIEW [dbo].[CotacoesMatrizPreenchimentoMapToView]
	AS 

	SELECT *
	FROM
		(
				-- Get all quotations coming from suppliers autorized to automatic match rules of Product Matchings.
				-- Add a last field with a numerator that resets every time that change the sequence FornecedorCodigo / ComplementoCodigo / _ProdutoCodigo
				-- The numerator works as a counter of rows with the same FornecedorCodigo / ComplementoCodigo / _ProdutoCodigo
				SELECT c.*, ROW_NUMBER() OVER (
												PARTITION BY c.FornecedorCodigo, c.ComplementoCodigo, c._ProdutoCodigo 
												ORDER BY c.FornecedorCodigo, c.ComplementoCodigo, c._ProdutoCodigo 
											  ) AS [Classificacao]
				FROM [dbo].[CotacoesIncompletasMapeamentoProdutoView] c
					 INNER JOIN [dbo].[Fornecedores] f
						ON c.FornecedorCodigo = f.Codigo
				WHERE f.ProdutosMatchingAutomatico = CAST('true' as bit)
		) cm1

	-- filter only the first occurrence of FornecedorCodigo / ComplementoCodigo / _ProdutoCodigo
	WHERE cm1.Classificacao = 1
		  -- and make sure that only get quotations of already created products
		  AND cm1.Referencia IN
			  (
				   SELECT Codigo FROM [dbo].[Produtos]
			  )
GO
PRINT N'Creating [dbo].[PartnumbersAmbiguosView]...';


GO
/*
	This view compares the deducted Product Codes from Incomplete Quotations and Product Codes already created. Then, when
	they have a match and the entites (quotation vs product) have different brands, it assumes a Partnumber conflit..

	The view shows ambiguous partnumbers, in other words, all partnumbers that on quotations side belongs to a brand 1 and in product table
	belongs to brand 2...

	If that prevention was a fake negative, user must create the product manually and map it manually too.
*/


CREATE VIEW [dbo].[PartnumbersAmbiguosView]
	AS 
	
	SELECT DISTINCT c.Partnumber

	-- link Products to Quotations via Simplified Partnumber on both sides
	FROM [dbo].[Produtos] p
		 INNER JOIN [dbo].[CotacoesIncompletasMapeamentoProdutoView] c
				ON [dbo].[GetCotacaoPartnumberSimplificadoFunction](p.Partnumber) = [dbo].GetCotacaoPartnumberSimplificadoFunction(c.Partnumber)

	-- filter only not existing products and the ones that brand does not fit on the two sides (quotations - products)
	WHERE c.Referencia NOT IN
		(
			SELECT Codigo FROM [dbo].[Produtos]
		)
		AND p.MarcaCodigo <> c.MarcaCodigo
GO
PRINT N'Creating [dbo].[ProdutosCodigosInexistentesView]...';


GO
/*
	This view represents all Product Codes (ProdutoCodigo) that does not exist and must be created.
*/

CREATE VIEW [dbo].[ProdutosCodigosInexistentesView]
	AS 
	
	-- set of Product Codes (ProdutoCodigo) deducted from Incomplete Quotations (missing only ProdutoCodigo mapping)
	SELECT DISTINCT Referencia
	FROM [dbo].[CotacoesIncompletasMapeamentoProdutoView]

	EXCEPT

	-- set of all existing (already) created Product Codes (ProdutoCodigo)
	SELECT Codigo
	FROM Produtos
GO
PRINT N'Creating [dbo].[CotacoesMatrizCriacaoProdutosView]...';


GO
/*
	With this view we want to create a mechanism to simplify product creating (rows creation on Product table)

	This view is a set of quotations, ensuring only 1 row by Referencia.

	Only Quotations belonging to suppliers that are configured to automatic product creation are considered on this set.

*/


CREATE VIEW [dbo].[CotacoesMatrizCriacaoProdutosView]
	AS 

	SELECT *
	FROM
		(
			-- Get all quotations coming from suppliers autorized for automatic product creation, adding a last field with
			-- a numerator that resets every time that Referencia change. (It works like a counter of rows that have the same Referencia)
			SELECT c.*, ROW_NUMBER() OVER (PARTITION BY c.Referencia ORDER BY Referencia ASC) AS Classificacao
			FROM [dbo].[CotacoesIncompletasMapeamentoProdutoView] c
				 INNER JOIN [dbo].Fornecedores f
					   ON c.FornecedorCodigo = f.Codigo
			WHERE f.ProdutosCriacaoAutomatica = CAST('true' as bit)

		) cm1

	-- filter only the first row of each Referencia present in incomplete quotations view
	WHERE cm1.Classificacao = 1
		  -- and make sure that, that Referencia belongs to the group of not existing products 
		  -- (meaning that this Referencia is not a Product already created)
		  AND cm1.Referencia IN 
					(
						SELECT Referencia FROM [dbo].[ProdutosCodigosInexistentesView]
					)
		  -- make sure too, that the Partnumber does not belong to the ambiguous partnumbers set
		  AND cm1.Partnumber NOT IN
					(
						SELECT Partnumber FROM [dbo].[PartnumbersAmbiguosView]
					)
GO
PRINT N'Creating [dbo].[BrandCount]...';


GO
CREATE PROCEDURE [dbo].[BrandCount]
	@WhereClause nvarchar(512) = ''			-- ex1: Codigo IN ('001', '002'); ex2: Descricao LIKE '_este'; ex3: Descricao LIKE '%est%'
AS

	DECLARE @select nvarchar(1024), @where nvarchar(512), @sqlQuery nvarchar(2048)

	SET @select = 'SELECT Count([Codigo]) FROM [dbo].[Marcas]' 

	SET @where = LTRIM(RTRIM(@WhereClause))
	IF Len(@where) > 0
	BEGIN
		SET @where = ' WHERE ' + @where
	END


	SET @sqlQuery = @select + @where


	EXEC(@sqlQuery)

RETURN  -- This SP must be used with ExecuteScalar
GO
PRINT N'Creating [dbo].[BrandDelete]...';


GO
CREATE PROCEDURE [dbo].[BrandDelete]
	@Codigo nvarchar(5),
	@Versao datetime
AS
	DECLARE @Erro nvarchar(255)


	-- VALIDAR SE O CODIGO EXISTE
	IF NOT EXISTS(SELECT [Codigo] FROM [dbo].[Marcas] WHERE [Codigo] = @Codigo)
	BEGIN
		-- DISPARAR UM ERRO
		SET @Erro = '[WhereToBuy-D01] ' + 'O registo que pretende eliminar não existe!';
		RAISERROR (@Erro, 15, 1)
		RETURN 0
	END

	-- VALIDAR SE A VERSÃO AINDA É A MESMA
	IF NOT EXISTS(SELECT [Codigo] FROM [dbo].[Marcas] WHERE [Codigo] = @Codigo AND [Versao] = @Versao)
	BEGIN
		-- DISPARAR UM ERRO
		SET @Erro = '[WhereToBuy-D02] ' + 'O registo que pretende eliminar, já foi alterado desde que o abriu!';
		RAISERROR (@Erro, 15, 1)
		RETURN 0
	END


	-- TUDO OK PARA SEGUIR EM FRENTE
	DECLARE @NumeroLinhasAfetadas int


	-- ELIMINAR O REGISTO
	BEGIN TRY

		-- INICIA CONTAGEM DE @@ROWCOUNT (para quando usado o ExecuteNonQuery())
		SET NOCOUNT OFF
		 
		-- ELIMINAR REGISTO
		DELETE FROM [dbo].[Marcas] Where [Codigo] = @Codigo

		SET @NumeroLinhasAfetadas = @@ROWCOUNT -- GUARDAR O NUMERO DE LINHAS AFETADAS

		-- ACABA CONTAGEM DE @@ROWCOUNT
		SET NOCOUNT ON

		-- RETORNAR O NUMERO DE LINHAS AFETADAS
		-- Quando usado o ExecuteNonQuery é o @@ROWCOUNT que é lido (SET NOCOUNT OFF/ON), e não esta variável
		RETURN @NumeroLinhasAfetadas

	END TRY


	-- SE EXISTIRAM ERROS
	BEGIN CATCH
		
		-- DISPARAR UM ERRO
		SET @Erro = '[WhereToBuy-D10] ' + ERROR_MESSAGE();
		RAISERROR (@Erro, 15, 1)
		RETURN 0

	END CATCH
GO
PRINT N'Creating [dbo].[BrandInsert]...';


GO
CREATE PROCEDURE [dbo].[BrandInsert]
	@Codigo nvarchar(5),
	@Descricao nvarchar(50),
	@Inativo bit
AS
	
	DECLARE @Criacao smalldatetime, @Versao datetime, @NumeroLinhasAfetadas int, @Erro nvarchar(255)

	SET @Criacao = GETDATE()
	SET @Versao = GETDATE()


	-- INSERÇÃO DO REGISTO
	BEGIN TRY
		 
		-- INICIA CONTAGEM DE @@ROWCOUNT (para quando usado o ExecuteNonQuery())
		SET NOCOUNT OFF

		-- INSERIR REGISTO
		INSERT INTO [dbo].[Marcas] ([Codigo], [Descricao], [Inativo], [Criacao], [Versao]) 
					VALUES (@Codigo, @Descricao, @Inativo, @Criacao, @Versao);
		
		SET @NumeroLinhasAfetadas = @@ROWCOUNT -- GUARDAR O NUMERO DE LINHAS AFETADAS

		-- ACABA CONTAGEM DE @@ROWCOUNT
		SET NOCOUNT ON

		-- RETORNAR O NUMERO DE LINHAS AFETADAS
		-- Quando usado o ExecuteNonQuery é o @@ROWCOUNT que é lido (SET NOCOUNT OFF/ON),  e não esta variável
		RETURN @NumeroLinhasAfetadas

	END TRY


	-- SE EXISTIRAM ERROS, DESFAZER TRANSACÇÃO
	BEGIN CATCH

		-- DISPARAR UM ERRO
		SET @Erro = 'WhereToBuy-I10] ' + ERROR_MESSAGE();
		RAISERROR (@Erro, 15, 1)
		RETURN 0

	END CATCH
GO
PRINT N'Creating [dbo].[BrandSelect]...';


GO
CREATE PROCEDURE [dbo].[BrandSelect]
	@WhereClause nvarchar(1024) = '',			-- ex1: Codigo IN ('001', '002'); ex2: Descricao LIKE '_este'; ex3: Descricao LIKE '%est%'
	@OrderByClause nvarchar(256) = ''			-- ex: Codigo desc
AS
	
	DECLARE @select nvarchar(2048), @where nvarchar(1024), @orderBy nvarchar(256), @sqlQuery nvarchar(4000)
	

	SET @select = 'SELECT marcas.[Codigo], marcas.[Descricao], marcas.[Inativo], marcas.[Criacao], marcas.[Versao]				
						FROM [dbo].[Marcas] marcas' 
	

	SET @where = LTRIM(RTRIM(@WhereClause))
	IF Len(@where) > 0
	BEGIN
		SET @where = ' WHERE ' + @where
	END


	SET @orderBy = LTRIM(RTRIM(@OrderByClause))
	IF LEN(@orderBy) > 0
	BEGIN
		SET @orderBy = ' ORDER BY ' + @orderBy
	END


	SET @sqlQuery = @select + @where + @orderBy  


	EXEC(@sqlQuery)


RETURN @@ROWCOUNT
GO
PRINT N'Creating [dbo].[BrandUpdate]...';


GO
CREATE PROCEDURE [dbo].[BrandUpdate]
	@Codigo nvarchar(5),
	@Descricao nvarchar(50),
	@Inativo bit,
	@Versao datetime
AS

	DECLARE @Erro nvarchar(255)


	-- VALIDAR SE O REGISTO EXISTE
	IF NOT EXISTS(SELECT [Codigo] FROM [dbo].[Marcas] WHERE [Codigo] = @Codigo)
	BEGIN
		-- DISPARAR UM ERRO
		SET @Erro = '[WhereToBuy-U01] ' + 'O registo que pretende alterar não existe!';
		RAISERROR (@Erro, 15, 1)
		RETURN 0
	END

	-- VALIDAR SE A VERSÃO AINDA É A MESMA
	IF NOT EXISTS(SELECT [Codigo] FROM [dbo].[Marcas] WHERE [Codigo] = @Codigo AND [Versao] = @Versao)
	BEGIN
		-- DISPARAR UM ERRO
		SET @Erro = '[WhereToBuy-U02] ' + 'O registo que pretende alterar, já foi alterado desde que o abriu!';
		RAISERROR (@Erro, 15, 1)
		RETURN 0
	END


	-- TUDO OK PARA SEGUIR EM FRENTE
	DECLARE @NovaVersao datetime, @NumeroLinhasAfetadas int

	SET @NovaVersao = GETDATE()


	-- ALTERAÇÃO DO REGISTO
	BEGIN TRY

		-- INICIA CONTAGEM DE @@ROWCOUNT (para quando usado o ExecuteNonQuery())
		SET NOCOUNT OFF

		-- ALTERAR REGISTO
		UPDATE [dbo].[Marcas] SET [Descricao] = @Descricao,
									[Versao] = @NovaVersao
								WHERE [Codigo] = @Codigo

		SET @NumeroLinhasAfetadas = @@ROWCOUNT -- GUARDAR O NUMERO DE LINHAS AFETADAS

		-- ACABA CONTAGEM DE @@ROWCOUNT
		SET NOCOUNT ON

		-- RETORNAR O NUMERO DE LINHAS AFETADAS
		-- Quando usado o ExecuteNonQuery é o @@ROWCOUNT que é lido (SET NOCOUNT OFF/ON), e não esta variável
		RETURN @NumeroLinhasAfetadas

	END TRY


	-- SE EXISTIRAM ERROS
	BEGIN CATCH

		-- DISPARAR UM ERRO
		SET @Erro = '[WhereToBuy-U10] ' + ERROR_MESSAGE();
		RAISERROR (@Erro, 15, 1)
		RETURN 0

	END CATCH
GO
PRINT N'Creating [dbo].[CategoryCount]...';


GO
CREATE PROCEDURE [dbo].[CategoryCount]
	@param1 int = 0,
	@param2 int
AS
	SELECT @param1, @param2
RETURN 0
GO
PRINT N'Creating [dbo].[CategoryDelete]...';


GO
CREATE PROCEDURE [dbo].[CategoryDelete]
	@param1 int = 0,
	@param2 int
AS
	SELECT @param1, @param2
RETURN 0
GO
PRINT N'Creating [dbo].[CategoryInsert]...';


GO
CREATE PROCEDURE [dbo].[CategoryInsert]
	@param1 int = 0,
	@param2 int
AS
	SELECT @param1, @param2
RETURN 0
GO
PRINT N'Creating [dbo].[CategoryUpdate]...';


GO
CREATE PROCEDURE [dbo].[CategoryUpdate]
	@param1 int = 0,
	@param2 int
AS
	SELECT @param1, @param2
RETURN 0
GO
PRINT N'Creating [dbo].[CategoySelect]...';


GO
CREATE PROCEDURE [dbo].[CategoySelect]
	@param1 int = 0,
	@param2 int
AS
	SELECT @param1, @param2
RETURN 0
GO
PRINT N'Creating [dbo].[CotacaoInsertSP]...';


GO
/*
	Esta Stored Procedure é tanto usada nas inserções unitárias (por exemplo a partir de um formulário na web), como
	nas inserções em lote...

	No caso das inserções em lote, antes da importação própriamente dita, as CotacoesIncompletas do fornecedor em questão 
	têm que ser removidas. Assim, o argumento @PrevineDuplicacoes deve ser passado com o valor 'false' já que esta prevenção
	foi efetuada com antecedência.

	No caso das inserções unitárias, o parametro @PrevineDuplicacoes deve ser passado com o valor 'true' para que a remoção
	de qualquer cotação incompleta, seja feita pela própria SP.

	!!! IMPORTANTE !!!
	> Existem campo que têm que ser obrigatóriamente indicados e outros que, se forem null (ou seja não indicados) serão sugeridos
	  automáticamente com (vazio).
	
	> Os campos Validade e ValidadeFormula são recebidos porque os prazos de validade de uma cotação podem ser
	  também comunicados pelo fornecedor. Se forem recebidos como NULL, então é o WhereToBuy que vai atribuir a validade.
*/

CREATE PROCEDURE [dbo].[CotacaoInsertSP]
	@PrevineDuplicacoes bit,
	@FornecedorCodigo nvarchar(20),
	@Data datetime,
	@_ProdutoCodigo nvarchar(256),
	@_ComplementoCodigo nvarchar(128),
	@_ComplementoDescricao nvarchar(128),
	@_Partnumber nvarchar(25),
	@_MarcaCodigo nvarchar(128),
	@_MarcaDescricao nvarchar(128),
	@_CategoriaCodigo nvarchar(128),
	@_CategoriaDescricao nvarchar(128),
	@_StockCodigo nvarchar(128),
	@_StockDescricao nvarchar(128),
	@_ImpostoCodigo nvarchar(128),
	@_ImpostoDescricao nvarchar(128),
	@_EstadoCodigo nvarchar(128),
	@_EstadoDescricao nvarchar(128),
	@_Descricao nvarchar(256),
	@_Link nvarchar(1024),
	@_Caracteristicas nvarchar(2048),
	@_Imagem nvarchar(1024),
	@_Preco decimal(14,4),
	@_OutrosCustos decimal(14,4),
	@_OutrosCustosDescricao nvarchar(128),
	@_Validade smalldatetime,
	@_ValidadeDescricao nvarchar(128),
	@Info nvarchar(256) OUTPUT
AS

	-- variaveis
	DECLARE @Partnumber nvarchar(25);


	/*
		Como esta SP é executada automaticamente para cada linha com o SSIS, pretende-se preencher duas colunas adicionais no resulset
		com o objetivo de, linha a linha, ser possivel perceber o problema encontrado.
	
		Para atingir este objetivo existem dois parametros a ter em conta:
			> @Info é um parametro de saída e deve conter a mensagem a colocar na linha / coluna em processamento no SSIS
			> @RETURN_VALUE que é o interno enviado à frente do RETURN e que corresponde ao numero de registos inseridos.

		Assim, se a SP não for executada pelo SSIS mas sim por uma outra aplicação, caso o RETURN_VALUE seja 0 (zero), o programador 
		deve considerar a mensagem de erro que existirá no parametro de saída @info.
	*/



	-- @PrevineDuplicacoes
	IF @PrevineDuplicacoes IS NULL
	BEGIN
		SET @Info = '[CotacaoInsertSP-01] (StoredProcedure)' + 'o valor do parametro @PrevineDuplicacoes não pode ser nulo!';
		RETURN 0
	END




	-- @FornecedorCodigo
	IF @FornecedorCodigo IS NULL
	BEGIN
		SET @Info = '[CotacaoInsertSP-02] (StoredProcedure)' + 'o valor do parametro @FornecedorCodigo não pode ser nulo!';
		RETURN 0
	END

	IF LEN(RTRIM(@FornecedorCodigo)) < 1
	BEGIN
		SET @Info ='[CotacaoInsertSP-03] (StoredProcedure)' + 'o valor do parametro @FornecedorCodigo tem um tamanho inválido!';
		RETURN 0
	END



	-- @Data
	IF @Data IS NULL
	BEGIN
		SET @Info = '[CotacaoInsertSP-04] (StoredProcedure)' + 'o valor do parametro @Data não pode ser nulo!';
		RETURN 0
	END



	-- @_ProdutoCodigo
	/*
		SERÁ AVALIADO APENAS NO FINAL DOS OUTROS PARAMETROS, PORQUE PRECISAMOS DO VALOR DA MARCA E PARTNUMBER PARA CONSTRUIR UM 
		CÓDIGO DE FORNECEDOR CASO ESTE NÃO ENVIE UM.
	*/



	-- @_ComplementoCodigo
	IF @_ComplementoCodigo IS NULL
	BEGIN
		SET @_ComplementoCodigo = '(vazio)';
	END

	IF LEN(RTRIM(@_ComplementoCodigo)) < 1
	BEGIN
		SET @_ComplementoCodigo = '(vazio)';
	END



	-- @_ComplementoDescricao
	IF @_ComplementoDescricao IS NULL
	BEGIN
		SET @_ComplementoDescricao = @_ComplementoCodigo;
	END

	IF LEN(RTRIM(@_ComplementoDescricao)) < 1
	BEGIN
		SET @_ComplementoDescricao = @_ComplementoCodigo;
	END



	-- @_Partnumber
	IF @_Partnumber IS NULL
	BEGIN
		SET @Info = '[CotacaoInsertSP-11] (StoredProcedure)' + 'o valor do parametro @_Partnumber não pode ser nulo!';
		RETURN 0
	END

	IF LEN(RTRIM(@_Partnumber)) < 1
	BEGIN
		SET @Info = '[CotacaoInsertSP-12] (StoredProcedure)' + 'o valor do parametro @_Partnumber tem um tamanho inválido!';
		RETURN 0
	END



	-- @_MarcaCodigo
	IF @_MarcaCodigo IS NULL
	BEGIN
		SET @Info ='[CotacaoInsertSP-13] (StoredProcedure)' + 'o valor do parametro @_MarcaCodigo não pode ser nulo!';
		RETURN 0
	END

	IF LEN(RTRIM(@_MarcaCodigo)) < 1
	BEGIN
		SET @Info = '[CotacaoInsertSP-14] (StoredProcedure)' + 'o valor do parametro @_MarcaCodigo tem um tamanho inválido!';
		RETURN 0
	END



	-- @_MarcaDescricao
	IF @_MarcaDescricao IS NULL
	BEGIN
		SET @_MarcaDescricao = @_MarcaCodigo;
	END

	IF LEN(RTRIM(@_MarcaDescricao)) < 1
	BEGIN
		SET @_MarcaDescricao = @_MarcaCodigo;
	END



	-- @_CategoriaCodigo
	IF @_CategoriaCodigo IS NULL
	BEGIN
		SET @Info = '[CotacaoInsertSP-17] (StoredProcedure)' + 'o valor do parametro @_CategoriaCodigo não pode ser nulo!';
		RETURN 0
	END

	IF LEN(RTRIM(@_CategoriaCodigo)) < 1
	BEGIN
		SET @Info = '[CotacaoInsertSP-18] (StoredProcedure)' + 'o valor do parametro @_CategoriaCodigo tem um tamanho inválido!';
		RETURN 0
	END




	-- @_CategoriaDescricao
	IF @_CategoriaDescricao IS NULL
	BEGIN
		SET @_CategoriaDescricao = @_CategoriaCodigo;
	END

	IF LEN(RTRIM(@_CategoriaDescricao)) < 1
	BEGIN
		SET @_CategoriaDescricao = @_CategoriaCodigo;
	END




	-- @_StockCodigo
	IF @_StockCodigo IS NULL
	BEGIN
		SET @_StockCodigo = '(vazio)';
	END

	IF LEN(RTRIM(@_StockCodigo)) < 1
	BEGIN
		SET @_StockCodigo = '(vazio)';
	END



	
	-- @_StockDescricao
	IF @_StockDescricao IS NULL
	BEGIN
		SET @_StockDescricao = @_StockCodigo;
	END

	IF LEN(RTRIM(@_StockDescricao)) < 1
	BEGIN
		SET @_StockDescricao = @_StockCodigo;
	END




	-- @_ImpostoCodigo
	IF @_ImpostoCodigo IS NULL
	BEGIN
		SET @_ImpostoCodigo = '(vazio)';
	END

	IF LEN(RTRIM(@_ImpostoCodigo)) < 1
	BEGIN
		SET @_ImpostoCodigo = '(vazio)';
	END



	
	-- @_ImpostoDescricao
	IF @_ImpostoDescricao IS NULL
	BEGIN
		SET @_ImpostoDescricao = @_ImpostoCodigo;
	END

	IF LEN(RTRIM(@_ImpostoDescricao)) < 1
	BEGIN
		SET @_ImpostoDescricao = @_ImpostoCodigo;
	END




	-- @_EstadoCodigo
	IF @_EstadoCodigo IS NULL
	BEGIN
		SET @_EstadoCodigo = '(vazio)';
	END

	IF LEN(RTRIM(@_EstadoCodigo)) < 1
	BEGIN
		SET @_EstadoCodigo = '(vazio)';
	END



	
	-- @_EstadoDescricao
	IF @_EstadoDescricao IS NULL
	BEGIN
		SET @_EstadoDescricao = @_EstadoCodigo;
	END

	IF LEN(RTRIM(@_EstadoDescricao)) < 1
	BEGIN
		SET @_EstadoDescricao = @_EstadoCodigo;
	END




	-- @_Descricao
	IF @_Descricao IS NULL
	BEGIN
		SET @Info = '[CotacaoInsertSP-29] (StoredProcedure)' + 'o valor do parametro @_Descricao não pode ser nulo!';
		RETURN 0
	END

	IF LEN(RTRIM(@_Descricao)) < 1
	BEGIN
		SET @Info = '[CotacaoInsertSP-30] (StoredProcedure)' + 'o valor do parametro @_Descricao tem um tamanho inválido!';
		RETURN 0
	END




	-- @_Link
	IF @_Link IS NULL
	BEGIN
		SET @_Link = '(vazio)';
	END

	IF LEN(RTRIM(@_Link)) < 1
	BEGIN
		SET @_Link = '(vazio)';
	END




	-- @_Caracteristicas
	IF @_Caracteristicas IS NULL
	BEGIN
		SET @_Caracteristicas = '(vazio)';
	END

	IF LEN(RTRIM(@_Caracteristicas)) < 1
	BEGIN
		SET @_Caracteristicas = '(vazio)';
	END




	-- @_Imagem
	IF @_Imagem IS NULL
	BEGIN
		SET @_Imagem = '(vazio)';
	END

	IF LEN(RTRIM(@_Imagem)) < 1
	BEGIN
		SET @_Imagem = '(vazio)';
	END





	-- @_Preco
	IF @_Preco IS NULL
	BEGIN
		SET @Info = '[CotacaoInsertSP-37] (StoredProcedure)' + 'o valor do parametro @_Preco não pode ser nulo!';
		RETURN 0
	END





	-- @_OutrosCustos
	IF @_OutrosCustos IS NULL
	BEGIN
		SET @_OutrosCustos = 0.0;
	END





	-- @_OutrosCustosDescricao
	IF @_OutrosCustosDescricao IS NULL
	BEGIN
		SET @_OutrosCustosDescricao = '(vazio)';
	END

	IF LEN(RTRIM(@_OutrosCustosDescricao)) < 1
	BEGIN
		SET @_OutrosCustosDescricao = '(vazio)';
	END




	-- @_Validade
	IF @_Validade IS NULL
	BEGIN
		SET @_Validade = CAST('01-01-2000' AS smalldatetime);
	END





	-- @_ValidadeDescricao
	IF @_ValidadeDescricao IS NULL
	BEGIN
		SET @_ValidadeDescricao = '(vazio)';
	END

	IF LEN(RTRIM(@_ValidadeDescricao)) < 1
	BEGIN
		SET @_OutrosCustosDescricao = '(vazio)';
	END





	-- PREPARAR @Partnumber (INTERNO)
	SET @Partnumber = dbo.GetCotacaoPartnumberFunction(@_Partnumber);



	-- impor regras para códigos externos (sistemas operacionais externos)
	SET @_ComplementoCodigo = dbo.GetCodigoExternoNormalizadoFunction(@_ComplementoCodigo);
	SET @_MarcaCodigo = dbo.GetCodigoExternoNormalizadoFunction(@_MarcaCodigo);
	SET @_CategoriaCodigo = dbo.GetCodigoExternoNormalizadoFunction(@_CategoriaCodigo);
	SET @_StockCodigo = dbo.GetCodigoExternoNormalizadoFunction(@_StockCodigo);
	SET @_ImpostoCodigo = dbo.GetCodigoExternoNormalizadoFunction(@_ImpostoCodigo);
	SET @_EstadoCodigo = dbo.GetCodigoExternoNormalizadoFunction(@_EstadoCodigo);



	-- @_ProdutoCodigo
	IF @_ProdutoCodigo IS NULL
	BEGIN
		SET @_ProdutoCodigo = '(' + @_MarcaCodigo + ')' + @Partnumber; -- uso o @Partnumber interno porque está limpo de caracteres anómalos
	END

	IF LEN(RTRIM(@_ProdutoCodigo)) < 1
	BEGIN
		SET @_ProdutoCodigo = '(' + @_MarcaCodigo + ')' + @Partnumber; -- uso o @Partnumber interno porque está limpo de caracteres anómalos
	END




	-- PREVINE DUPLICAÇÕES (remove a CotacaoNaoIntegrada que possa existir para este FornecedorCodigo / _ProdutoCodigo
	IF @PrevineDuplicacoes = CAST('true' as bit)
	BEGIN
		-- remove cotacoes já completas mas ainda não integradas
		DELETE FROM [dbo].CotacoesNaoIntegradasView
			   WHERE [FornecedorCodigo] = @FornecedorCodigo
					 AND [_ProdutoCodigo] = @_ProdutoCodigo

		-- remove cotações incompletas
		DELETE FROM [dbo].CotacoesIncompletasView
			   WHERE [FornecedorCodigo] = @FornecedorCodigo
					 AND [_ProdutoCodigo] = @_ProdutoCodigo

	END




	-- INSERIR
	SET NOCOUNT ON; -- não há necessidade de contar os registos (é sempre 1)


	BEGIN TRY
	
		INSERT INTO [dbo].[Cotacoes]
			   (
				   [FornecedorCodigo], [Data], [_ProdutoCodigo], [_ComplementoCodigo], [_ComplementoDescricao],
				   [_Partnumber], [_MarcaCodigo], [_MarcaDescricao], [_CategoriaCodigo], [_CategoriaDescricao], [_StockCodigo], [_StockDescricao],
				   [_ImpostoCodigo], [_ImpostoDescricao], [_EstadoCodigo], [_EstadoDescricao], [_Descricao], [_Link], [_Caracteristicas], [_Imagem], 
				   [_Preco], [_OutrosCustos], [_OutrosCustosDescricao], [_Validade], [_ValidadeDescricao],
				   [ComplementoCodigo], [Partnumber], [MarcaCodigo], [CategoriaCodigo], 
				   [StockCodigo], [StockCodigoSubstituto], [StockCodigoSubstitutoJustificacao], 
				   [ImpostoCodigo], [EstadoCodigo], [Descricao], [Link], [Caracteristicas], [PrecoCusto], [PrecoCustoFormula],
				   [Validade], [ValidadeFormula], [ProdutoCodigo], 
				   [Completo], [Integrado],
				   [Inativo], [Versao]
				)
				VALUES
				(
				   @FornecedorCodigo, @Data, @_ProdutoCodigo, @_ComplementoCodigo, @_ComplementoDescricao,
				   @_Partnumber, @_MarcaCodigo, @_MarcaDescricao, @_CategoriaCodigo, @_CategoriaDescricao, @_StockCodigo, @_StockDescricao,
				   @_ImpostoCodigo, @_ImpostoDescricao, @_EstadoCodigo, @_EstadoDescricao, @_Descricao, @_Link, @_Caracteristicas, @_Imagem, 
				   @_Preco, @_OutrosCustos, @_OutrosCustosDescricao, @_Validade, @_ValidadeDescricao,
				   null, @Partnumber, null, null, 
				   null, null, null, 
				   null, null, null, null, null, null, null, 
				   null, null, null, 
				   CAST('false' as bit), CAST('false' as bit),
				   CAST('false' as bit), GETDATE()
				);


		-- preencher output com informação - sucesso
		SET @Info = 'Cotação inserida com sucesso.';

		-- devolver informação que foi inserido um registo
		RETURN 1;

	END TRY
	BEGIN CATCH

		-- preencher output com informação - sucesso
		SET @Info = '[CotacaoInsertSP-50] ' +CAST(ERROR_NUMBER() as nvarchar) + ' - ' +ERROR_MESSAGE();

		-- devolver informação que foi inserido um registo
		RETURN 1;

	END CATCH

RETURN;
GO
PRINT N'Creating [dbo].[LanguageCount]...';


GO
CREATE PROCEDURE [dbo].[LanguageCount]
	@WhereClause nvarchar(512) = ''			-- ex1: Codigo IN ('001', '002'); ex2: Descricao LIKE '_este'; ex3: Descricao LIKE '%est%'
AS

	DECLARE @select nvarchar(1024), @where nvarchar(512), @sqlQuery nvarchar(2048)

	SET @select = 'SELECT Count([Codigo]) FROM [dbo].[Idiomas]' 

	SET @where = LTRIM(RTRIM(@WhereClause))
	IF Len(@where) > 0
	BEGIN
		SET @where = ' WHERE ' + @where
	END


	SET @sqlQuery = @select + @where


	EXEC(@sqlQuery)

RETURN  -- This SP must be used with ExecuteScalar
GO
PRINT N'Creating [dbo].[LanguageDelete]...';


GO
CREATE PROCEDURE [dbo].[LanguageDelete]
	@Codigo nvarchar(5),
	@Versao datetime
AS
	DECLARE @Erro nvarchar(255)


	-- VALIDAR SE O CODIGO EXISTE
	IF NOT EXISTS(SELECT [Codigo] FROM [dbo].[Idiomas] WHERE [Codigo] = @Codigo)
	BEGIN
		-- DISPARAR UM ERRO
		SET @Erro = '[WhereToBuy-D01] ' + 'O registo que pretende eliminar não existe!';
		RAISERROR (@Erro, 15, 1)
		RETURN 0
	END

	-- VALIDAR SE A VERSÃO AINDA É A MESMA
	IF NOT EXISTS(SELECT [Codigo] FROM [dbo].[Idiomas] WHERE [Codigo] = @Codigo AND [Versao] = @Versao)
	BEGIN
		-- DISPARAR UM ERRO
		SET @Erro = '[WhereToBuy-D02] ' + 'O registo que pretende eliminar, já foi alterado desde que o abriu!';
		RAISERROR (@Erro, 15, 1)
		RETURN 0
	END


	-- TUDO OK PARA SEGUIR EM FRENTE
	DECLARE @NumeroLinhasAfetadas int


	-- ELIMINAR O REGISTO
	BEGIN TRY

		-- INICIA CONTAGEM DE @@ROWCOUNT (para quando usado o ExecuteNonQuery())
		SET NOCOUNT OFF
		 
		-- ELIMINAR REGISTO
		DELETE FROM [dbo].[Idiomas] Where [Codigo] = @Codigo

		SET @NumeroLinhasAfetadas = @@ROWCOUNT -- GUARDAR O NUMERO DE LINHAS AFETADAS

		-- ACABA CONTAGEM DE @@ROWCOUNT
		SET NOCOUNT ON

		-- RETORNAR O NUMERO DE LINHAS AFETADAS
		-- Quando usado o ExecuteNonQuery é o @@ROWCOUNT que é lido (SET NOCOUNT OFF/ON), e não esta variável
		RETURN @NumeroLinhasAfetadas

	END TRY


	-- SE EXISTIRAM ERROS
	BEGIN CATCH
		
		-- DISPARAR UM ERRO
		SET @Erro = '[WhereToBuy-D10] ' + ERROR_MESSAGE();
		RAISERROR (@Erro, 15, 1)
		RETURN 0

	END CATCH
GO
PRINT N'Creating [dbo].[LanguageInsert]...';


GO
CREATE PROCEDURE [dbo].[LanguageInsert]
	@Codigo nvarchar(5),
	@Descricao nvarchar(50),
	@Inativo bit
AS
	
	DECLARE @Criacao smalldatetime, @Versao datetime, @NumeroLinhasAfetadas int, @Erro nvarchar(255)

	SET @Criacao = GETDATE()
	SET @Versao = GETDATE()


	-- INSERÇÃO DO REGISTO
	BEGIN TRY
		 
		-- INICIA CONTAGEM DE @@ROWCOUNT (para quando usado o ExecuteNonQuery())
		SET NOCOUNT OFF

		-- INSERIR REGISTO
		INSERT INTO [dbo].[Idiomas] ([Codigo], [Descricao], [Inativo], [Criacao], [Versao]) 
					VALUES (@Codigo, @Descricao, @Inativo, @Criacao, @Versao);
		
		SET @NumeroLinhasAfetadas = @@ROWCOUNT -- GUARDAR O NUMERO DE LINHAS AFETADAS

		-- ACABA CONTAGEM DE @@ROWCOUNT
		SET NOCOUNT ON

		-- RETORNAR O NUMERO DE LINHAS AFETADAS
		-- Quando usado o ExecuteNonQuery é o @@ROWCOUNT que é lido (SET NOCOUNT OFF/ON),  e não esta variável
		RETURN @NumeroLinhasAfetadas

	END TRY


	-- SE EXISTIRAM ERROS, DESFAZER TRANSACÇÃO
	BEGIN CATCH

		-- DISPARAR UM ERRO
		SET @Erro = 'WhereToBuy-I10] ' + ERROR_MESSAGE();
		RAISERROR (@Erro, 15, 1)
		RETURN 0

	END CATCH
GO
PRINT N'Creating [dbo].[LanguageSelect]...';


GO
CREATE PROCEDURE [dbo].[LanguageSelect]
	@WhereClause nvarchar(1024) = '',			-- ex1: Codigo IN ('001', '002'); ex2: Descricao LIKE '_este'; ex3: Descricao LIKE '%est%'
	@OrderByClause nvarchar(256) = ''			-- ex: Codigo desc
AS
	
	DECLARE @select nvarchar(2048), @where nvarchar(1024), @orderBy nvarchar(256), @sqlQuery nvarchar(4000)
	

	SET @select = 'SELECT i.[Codigo], i.[Descricao], i.[Inativo], i.[Criacao], i.[Versao]				
						FROM [dbo].[Idiomas] i' 
	

	SET @where = LTRIM(RTRIM(@WhereClause))
	IF Len(@where) > 0
	BEGIN
		SET @where = ' WHERE ' + @where
	END


	SET @orderBy = LTRIM(RTRIM(@OrderByClause))
	IF LEN(@orderBy) > 0
	BEGIN
		SET @orderBy = ' ORDER BY ' + @orderBy
	END


	SET @sqlQuery = @select + @where + @orderBy  


	EXEC(@sqlQuery)


RETURN @@ROWCOUNT
GO
PRINT N'Creating [dbo].[LanguageUpdate]...';


GO
CREATE PROCEDURE [dbo].[LanguageUpdate]
	@Codigo nvarchar(5),
	@Descricao nvarchar(50),
	@Inativo bit,
	@Versao datetime
AS

	DECLARE @Erro nvarchar(255)


	-- VALIDAR SE O REGISTO EXISTE
	IF NOT EXISTS(SELECT [Codigo] FROM [dbo].[Idiomas] WHERE [Codigo] = @Codigo)
	BEGIN
		-- DISPARAR UM ERRO
		SET @Erro = '[WhereToBuy-U01] ' + 'O registo que pretende alterar não existe!';
		RAISERROR (@Erro, 15, 1)
		RETURN 0
	END

	-- VALIDAR SE A VERSÃO AINDA É A MESMA
	IF NOT EXISTS(SELECT [Codigo] FROM [dbo].[Idiomas] WHERE [Codigo] = @Codigo AND [Versao] = @Versao)
	BEGIN
		-- DISPARAR UM ERRO
		SET @Erro = '[WhereToBuy-U02] ' + 'O registo que pretende alterar, já foi alterado desde que o abriu!';
		RAISERROR (@Erro, 15, 1)
		RETURN 0
	END


	-- TUDO OK PARA SEGUIR EM FRENTE
	DECLARE @NovaVersao datetime, @NumeroLinhasAfetadas int

	SET @NovaVersao = GETDATE()


	-- ALTERAÇÃO DO REGISTO
	BEGIN TRY

		-- INICIA CONTAGEM DE @@ROWCOUNT (para quando usado o ExecuteNonQuery())
		SET NOCOUNT OFF

		-- ALTERAR REGISTO
		UPDATE [dbo].[Idiomas] SET [Descricao] = @Descricao,
									[Versao] = @NovaVersao
								WHERE [Codigo] = @Codigo

		SET @NumeroLinhasAfetadas = @@ROWCOUNT -- GUARDAR O NUMERO DE LINHAS AFETADAS

		-- ACABA CONTAGEM DE @@ROWCOUNT
		SET NOCOUNT ON

		-- RETORNAR O NUMERO DE LINHAS AFETADAS
		-- Quando usado o ExecuteNonQuery é o @@ROWCOUNT que é lido (SET NOCOUNT OFF/ON), e não esta variável
		RETURN @NumeroLinhasAfetadas

	END TRY


	-- SE EXISTIRAM ERROS
	BEGIN CATCH

		-- DISPARAR UM ERRO
		SET @Erro = '[WhereToBuy-U10] ' + ERROR_MESSAGE();
		RAISERROR (@Erro, 15, 1)
		RETURN 0

	END CATCH
GO
PRINT N'Creating [dbo].[QuotationWarningCount]...';


GO
CREATE PROCEDURE [dbo].[QuotationWarningCount]
	@WhereClause nvarchar(512) = ''			-- ex1: Codigo IN ('001', '002'); ex2: Descricao LIKE '_este'; ex3: Descricao LIKE '%est%'
AS

	DECLARE @select nvarchar(1024), @where nvarchar(512), @sqlQuery nvarchar(2048)

	SET @select = 'SELECT Count([Id]) FROM [dbo].[CotacoesAvisos]' 

	SET @where = LTRIM(RTRIM(@WhereClause))
	IF Len(@where) > 0
	BEGIN
		SET @where = ' WHERE ' + @where
	END


	SET @sqlQuery = @select + @where


	EXEC(@sqlQuery)

RETURN  -- This SP must be used with ExecuteScalar
GO
PRINT N'Creating [dbo].[QuotationWarningDelete]...';


GO
CREATE PROCEDURE [dbo].[QuotationWarningDelete]
	@Id nvarchar(5)
AS
	DECLARE @Erro nvarchar(255)


	-- VALIDAR SE O CODIGO EXISTE
	IF NOT EXISTS(SELECT [Id] FROM [dbo].[CotacoesAvisos] WHERE [Id] = @Id)
	BEGIN
		-- DISPARAR UM ERRO
		SET @Erro = '[WhereToBuy-D01] ' + 'O registo que pretende eliminar não existe!';
		RAISERROR (@Erro, 15, 1)
		RETURN 0
	END


	-- TUDO OK PARA SEGUIR EM FRENTE
	DECLARE @NumeroLinhasAfetadas int


	-- ELIMINAR O REGISTO
	BEGIN TRY

		-- INICIA CONTAGEM DE @@ROWCOUNT (para quando usado o ExecuteNonQuery())
		SET NOCOUNT OFF
		 
		-- ELIMINAR REGISTO
		DELETE FROM [dbo].[CotacoesAvisos] Where [Id] = @Id

		SET @NumeroLinhasAfetadas = @@ROWCOUNT -- GUARDAR O NUMERO DE LINHAS AFETADAS

		-- ACABA CONTAGEM DE @@ROWCOUNT
		SET NOCOUNT ON

		-- RETORNAR O NUMERO DE LINHAS AFETADAS
		-- Quando usado o ExecuteNonQuery é o @@ROWCOUNT que é lido (SET NOCOUNT OFF/ON), e não esta variável
		RETURN @NumeroLinhasAfetadas

	END TRY


	-- SE EXISTIRAM ERROS
	BEGIN CATCH
		
		-- DISPARAR UM ERRO
		SET @Erro = '[WhereToBuy-D10] ' + ERROR_MESSAGE();
		RAISERROR (@Erro, 15, 1)
		RETURN 0

	END CATCH
GO
PRINT N'Creating [dbo].[QuotationWarningInsert]...';


GO
CREATE PROCEDURE [dbo].[QuotationWarningInsert]
	@Id uniqueidentifier,
	@Data smalldatetime,
	@ProdutoCodigo nvarchar(256),
	@ComplementoCodigo nvarchar(128),
	@FornecedorCodigo nvarchar(5),
	@AvisoTipoCodigo nvarchar(5),
	@Descricao nvarchar(20)
AS
	
	DECLARE @Criacao smalldatetime, @NumeroLinhasAfetadas int, @Erro nvarchar(255)

	SET @Criacao = GETDATE()


	-- INSERÇÃO DO REGISTO
	BEGIN TRY
		 
		-- INICIA CONTAGEM DE @@ROWCOUNT (para quando usado o ExecuteNonQuery())
		SET NOCOUNT OFF

		-- INSERIR REGISTO
		INSERT INTO [dbo].[CotacoesAvisos] ([Id], [Data], [_ProdutoCodigo], [_ComplementoCodigo], [FornecedorCodigo], [AvisoTipoCodigo], [Descricao], [Criacao]) 
					VALUES (@Id, @Data, @ProdutoCodigo, @ComplementoCodigo, @FornecedorCodigo, @AvisoTipoCodigo, @Descricao, @Criacao);
		
		SET @NumeroLinhasAfetadas = @@ROWCOUNT -- GUARDAR O NUMERO DE LINHAS AFETADAS

		-- ACABA CONTAGEM DE @@ROWCOUNT
		SET NOCOUNT ON

		-- RETORNAR O NUMERO DE LINHAS AFETADAS
		-- Quando usado o ExecuteNonQuery é o @@ROWCOUNT que é lido (SET NOCOUNT OFF/ON),  e não esta variável
		RETURN @NumeroLinhasAfetadas

	END TRY


	-- SE EXISTIRAM ERROS, DESFAZER TRANSACÇÃO
	BEGIN CATCH

		-- DISPARAR UM ERRO
		SET @Erro = 'WhereToBuy-I10] ' + ERROR_MESSAGE();
		RAISERROR (@Erro, 15, 1)
		RETURN 0

	END CATCH
GO
PRINT N'Creating [dbo].[QuotationWarningSelect]...';


GO
CREATE PROCEDURE [dbo].[QuotationWarningSelect]
	@WhereClause nvarchar(1024) = '',			-- ex1: Codigo IN ('001', '002'); ex2: Descricao LIKE '_este'; ex3: Descricao LIKE '%est%'
	@OrderByClause nvarchar(256) = ''			-- ex: Codigo desc
AS
	
	DECLARE @select nvarchar(2048), @where nvarchar(1024), @orderBy nvarchar(256), @sqlQuery nvarchar(4000)
	

	SET @select = 'SELECT c.[Id], c.[Data], c.[_ProdutoCodigo], 
							c.[_ComplementoCodigo], c.[FornecedorCodigo], f.[Nome], f.[Contribuinte]
							c.[AvisoTipoCodigo], c.[Descricao], c.[Criacao]				
						FROM [dbo].[CotacoesAvisos] c INNER JOIN [dbo].[Fornacedores] f
							ON c.[FornecedorCodigo] = f.[Codigo] and f[Inativo]=FALSE' 
	

	SET @where = LTRIM(RTRIM(@WhereClause))
	IF Len(@where) > 0
	BEGIN
		SET @where = ' WHERE ' + @where
	END


	SET @orderBy = LTRIM(RTRIM(@OrderByClause))
	IF LEN(@orderBy) > 0
	BEGIN
		SET @orderBy = ' ORDER BY ' + @orderBy
	END


	SET @sqlQuery = @select + @where + @orderBy  


	EXEC(@sqlQuery)


RETURN @@ROWCOUNT
GO
PRINT N'Creating [dbo].[QuotationWarningUpdate]...';


GO
CREATE PROCEDURE [dbo].[QuotationWarningUpdate]
	@Id uniqueidentifier,
	@Data smalldatetime,
	@ProdutoCodigo nvarchar(256),
	@ComplementoCodigo nvarchar(128),
	@FornecedorCodigo nvarchar(5),
	@AvisoTipoCodigo nvarchar(5),
	@Descricao nvarchar(20)

AS

	DECLARE @Erro nvarchar(255)


	-- VALIDAR SE O REGISTO EXISTE
	IF NOT EXISTS(SELECT [Id] FROM [dbo].[CotacoesAvisos] WHERE [Id] = @Id)
	BEGIN
		-- DISPARAR UM ERRO
		SET @Erro = '[WhereToBuy-U01] ' + 'O registo que pretende alterar não existe!';
		RAISERROR (@Erro, 15, 1)
		RETURN 0
	END

	-- TUDO OK PARA SEGUIR EM FRENTE
	DECLARE  @NumeroLinhasAfetadas int

	-- ALTERAÇÃO DO REGISTO
	BEGIN TRY

		-- INICIA CONTAGEM DE @@ROWCOUNT (para quando usado o ExecuteNonQuery())
		SET NOCOUNT OFF

		-- ALTERAR REGISTO
		UPDATE [dbo].[CotacoesAvisos] SET [Data] = @Data,
										[_ProdutoCodigo]=@ProdutoCodigo,
										[_ComplementoCodigo]=@ComplementoCodigo,
										[FornecedorCodigo] = @FornecedorCodigo,
										[AvisoTipoCodigo] = @AvisoTipoCodigo,
										[Descricao] = @Descricao
									WHERE [Id] = @Id

		SET @NumeroLinhasAfetadas = @@ROWCOUNT -- GUARDAR O NUMERO DE LINHAS AFETADAS

		-- ACABA CONTAGEM DE @@ROWCOUNT
		SET NOCOUNT ON

		-- RETORNAR O NUMERO DE LINHAS AFETADAS
		-- Quando usado o ExecuteNonQuery é o @@ROWCOUNT que é lido (SET NOCOUNT OFF/ON), e não esta variável
		RETURN @NumeroLinhasAfetadas

	END TRY


	-- SE EXISTIRAM ERROS
	BEGIN CATCH

		-- DISPARAR UM ERRO
		SET @Erro = '[WhereToBuy-U10] ' + ERROR_MESSAGE();
		RAISERROR (@Erro, 15, 1)
		RETURN 0

	END CATCH
GO
PRINT N'Creating [dbo].[StateCount]...';


GO
CREATE PROCEDURE [dbo].[StateCount]
	@param1 int = 0,
	@param2 int
AS
	SELECT @param1, @param2
RETURN 0
GO
PRINT N'Creating [dbo].[StateDelete]...';


GO
CREATE PROCEDURE [dbo].[StateDelete]
	@param1 int = 0,
	@param2 int
AS
	SELECT @param1, @param2
RETURN 0
GO
PRINT N'Creating [dbo].[StateInsert]...';


GO
CREATE PROCEDURE [dbo].[StateInsert]
	@param1 int = 0,
	@param2 int
AS
	SELECT @param1, @param2
RETURN 0
GO
PRINT N'Creating [dbo].[StateSelect]...';


GO
CREATE PROCEDURE [dbo].[StateSelect]
	@param1 int = 0,
	@param2 int
AS
	SELECT @param1, @param2
RETURN 0
GO
PRINT N'Creating [dbo].[StateUpdate]...';


GO
CREATE PROCEDURE [dbo].[StateUpdate]
	@param1 int = 0,
	@param2 int
AS
	SELECT @param1, @param2
RETURN 0
GO
PRINT N'Creating [dbo].[Step1a1_DeleteIncompleteAndNotIntegratedExistingQuotations]...';


GO
/*
	This SP deletes all Incomplete and Not Integrated Quotations from database
*/


CREATE PROCEDURE [dbo].[Step1a1_DeleteIncompleteAndNotIntegratedExistingQuotations]
	@FornecedorCodigo nvarchar(20),
	@Info nvarchar(256) OUTPUT
AS
	
	-- variables
	DECLARE @numberOfAffectedRows integer = 0;


	-- delete incomplete quotations
	BEGIN TRY

		-- remove all not integrated quotations from the supplier received on @FornecedorCodigo
		DELETE FROM [dbo].[CotacoesNaoIntegradasView] WHERE FornecedorCodigo = @FornecedorCodigo;

		-- sum to @numberOfAffectedRows
		SET @numberOfAffectedRows += @@ROWCOUNT;



		-- remove all incomplete quotations from the supplier too
		DELETE FROM [dbo].CotacoesIncompletasView WHERE [FornecedorCodigo] = @FornecedorCodigo

		-- sum to @numberOfAffectedRows
		SET @numberOfAffectedRows += @@ROWCOUNT;



		-- fill output @info with sucess message
		SET @Info = '[Step1a1_DeleteIncompleteAndNotIntegratedExistingQuotations-01] Were removed sucessfully, ' + CAST(@numberOfAffectedRows as nvarchar) + ' not integrated and incomplete quotations of the supplier ' + @FornecedorCodigo +'.';

		-- send true to output
		RETURN 1;

	END TRY

	BEGIN CATCH
		-- fill output @info with occurred error message
		SET @Info = '[Step1a1_DeleteIncompleteAndNotIntegratedExistingQuotations-02] ' + CAST(ERROR_NUMBER() as nvarchar) + ' - ' + ERROR_MESSAGE();

		-- send false to output
		RETURN 0;

	END CATCH

RETURN;
GO
PRINT N'Creating [dbo].[Step2a1_Preparation_CleanAllExistingWarnings]...';


GO
/*
	This SP cleans all rows from CotacoesAvisos Table
*/


CREATE PROCEDURE [dbo].[Step2a1_Preparation_CleanAllExistingWarnings]
	@Info nvarchar(256) OUTPUT
AS
	
	-- CLEAN TABLE
	BEGIN TRY

		-- clean CotacoesAvisos
		TRUNCATE Table [dbo].[CotacoesAvisos]

		-- fill output @info with sucess message
		SET @Info = '[Step2a1_Preparation_CleanAllExistingWarnings-01] Limpeza com sucesso da tabela CotacoesAvisos';

		-- send true to output
		RETURN 1;

	END TRY

	BEGIN CATCH
		-- fill output @info with occurred error message
		SET @Info = '[Step2a1_Preparation_CleanAllExistingWarnings-02] ' + CAST(ERROR_NUMBER() as nvarchar) + ' - ' +ERROR_MESSAGE();

		-- send false to output
		RETURN 0;

	END CATCH

RETURN;
GO
PRINT N'Creating [dbo].[Step2a2_Preparation_DeleteExpiredQuotations]...';


GO
/*
	This SP remove from database all expired and inactive quotations
*/


CREATE PROCEDURE [dbo].[Step2a2_Preparation_DeleteExpiredQuotations]
	@Info nvarchar(256) OUTPUT
AS
	
	-- clean old quotations
	BEGIN TRY

		-- remove all expired and inactive Cotacoes
		DELETE FROM [dbo].[Cotacoes] WHERE Inativo = CAST('true' as bit) AND Validade < DATEADD(MONTH, -3, GETDATE())

		-- fill output @info with sucess message
		SET @Info = '[Step2a2_Preparation_DeleteExpiredQuotations-01] Limpeza com sucesso das cotacoes inativas fora de validade (+3 meses)';

		-- send true to output
		RETURN 1;

	END TRY

	BEGIN CATCH
		-- fill output @info with occurred error message
		SET @Info = '[Step2a2_Preparation_DeleteExpiredQuotations-02] ' + CAST(ERROR_NUMBER() as nvarchar) + ' - ' + ERROR_MESSAGE();

		-- send false to output
		RETURN 0;

	END CATCH

RETURN;
GO
PRINT N'Creating [dbo].[Step2b1a_Mappings_Addons_FeedNewRules]...';


GO
/*
	This SP feeds Addons Matching table with new rules, considering the new incoming quotations
*/


CREATE PROCEDURE [dbo].[Step2b1a_Mappings_Addons_FeedNewRules]
	@Info nvarchar(256) OUTPUT
AS
	
	-- new rules feeding
	BEGIN TRY

		/*
			Feed (...)Matching table with new incomplete rules, to simplify mapping work to the user.
		*/
		INSERT [dbo].[ComplementosMatching] (FornecedorCodigo, Codigo, Descricao, MapTo, Inativo, Criacao, Versao)
	
		SELECT um.FornecedorCodigo, 
			   um.Codigo,
			   (
					-- get 1st existing description in CotacoesIncompletasView for this entity
					SELECT TOP 1 CASE WHEN ci._ComplementoDescricao IS NULL THEN '(vazio)'
									  ELSE ci._ComplementoDescricao
								 END
					FROM [dbo].[CotacoesIncompletasView] ci
					WHERE ci.FornecedorCodigo = um.FornecedorCodigo
						  AND ci._ComplementoCodigo = um.Codigo
				    ORDER BY ci._ComplementoDescricao DESC  -- prevents the existence of some _ComplementoDescricao = NULL
		      ) AS [Descricao],
			  NULL, -- MapTo will be filled later by user
			  CAST('false' as bit),
			  GETDATE(),
			  GETDATE()
		FROM
			  (
					-- un-existing but needed matching rules
					SELECT DISTINCT ci.FornecedorCodigo, ci._ComplementoCodigo AS Codigo
					FROM [dbo].[CotacoesIncompletasView] ci
					EXCEPT
					SELECT cm.FornecedorCodigo, cm.Codigo
					FROM [dbo].[ComplementosMatching] cm
			  ) um

		



		-- fill output @info with sucess message
		SET @Info = '[Step2b1a_Mappings_Addons_FeedNewRules-01] Number of created matching rules: ' + CAST(@@ROWCOUNT as nvarchar);

		-- send true to output
		RETURN 1;

	END TRY

	BEGIN CATCH
		-- fill output @info with occurred error message
		SET @Info = '[Step2b1a_Mappings_Addons_FeedNewRules-02] ' + CAST(ERROR_NUMBER() as nvarchar) + ' - ' + ERROR_MESSAGE();

		-- send false to output
		RETURN 0;

	END CATCH

RETURN;
GO
PRINT N'Creating [dbo].[Step2b1a_Mappings_Brands_FeedNewRules]...';


GO
/*
	This SP feeds MarcasMatching table with new rules, considering the new incoming quotations
*/


CREATE PROCEDURE [dbo].[Step2b1a_Mappings_Brands_FeedNewRules]
	@Info nvarchar(256) OUTPUT
AS
	
	-- new rules feeding
	BEGIN TRY

		/*
			Feed (...)Matching table with new incomplete rules, to simplify mapping work to the user.
		*/

		INSERT [dbo].[MarcasMatching] (FornecedorCodigo, Codigo, Descricao, MapTo, Inativo, Criacao, Versao)
	
		SELECT um.FornecedorCodigo, 
			   um.Codigo,
			   (
					-- get 1st existing description in CotacoesIncompletasView for this entity
					SELECT TOP 1 CASE WHEN ci._MarcaDescricao IS NULL THEN '(vazio)'
									  ELSE ci._MarcaDescricao
								 END
					FROM [dbo].[CotacoesIncompletasView] ci
					WHERE ci.FornecedorCodigo = um.FornecedorCodigo
						  AND ci._MarcaCodigo = um.Codigo
				    ORDER BY ci._MarcaDescricao DESC  -- prevents the existence of some _MarcaDescricao = NULL
		      ) AS [Descricao],
			  NULL, -- MapTo will be filled later by user
			  CAST('false' as bit),
			  GETDATE(),
			  GETDATE()
		FROM
			  (
					-- un-existing but needed matching rules
					SELECT DISTINCT ci.FornecedorCodigo, ci._MarcaCodigo AS Codigo
					FROM [dbo].[CotacoesIncompletasView] ci
					EXCEPT
					SELECT mm.FornecedorCodigo, mm.Codigo
					FROM [dbo].[MarcasMatching] mm
			  ) um
		



		-- fill output @info with sucess message
		SET @Info = '[Step2b1a_Mappings_Brands_FeedNewRules-01] Number of created matching rules: ' + CAST(@@ROWCOUNT as nvarchar);

		-- send true to output
		RETURN 1;

	END TRY

	BEGIN CATCH
		-- fill output @info with occurred error message
		SET @Info = '[Step2b1a_Mappings_Brands_FeedNewRules-02] ' + CAST(ERROR_NUMBER() as nvarchar) + ' - ' + ERROR_MESSAGE();

		-- send false to output
		RETURN 0;

	END CATCH

RETURN;
GO
PRINT N'Creating [dbo].[Step2b1a_Mappings_Categories_FeedNewRules]...';


GO
/*
	This SP feeds CategoriesMatching table with new rules, considering the new incoming quotations
*/


CREATE PROCEDURE [dbo].[Step2b1a_Mappings_Categories_FeedNewRules]
	@Info nvarchar(256) OUTPUT
AS
	
	-- new rules feeding
	BEGIN TRY

		/*
			Feed (...)Matching table with new incomplete rules, to simplify mapping work to the user.
		*/

		INSERT [dbo].[CategoriasMatching] (FornecedorCodigo, Codigo, Descricao, MapTo, Inativo, Criacao, Versao)
	
		SELECT um.FornecedorCodigo, 
			   um.Codigo,
			   (
					-- get 1st existing description in CotacoesIncompletasView for this entity
					SELECT TOP 1 CASE WHEN ci._CategoriaDescricao IS NULL THEN '(vazio)'
									  ELSE ci._CategoriaDescricao
								 END
					FROM [dbo].[CotacoesIncompletasView] ci
					WHERE ci.FornecedorCodigo = um.FornecedorCodigo
						  AND ci._CategoriaCodigo = um.Codigo
				    ORDER BY ci._CategoriaDescricao DESC  -- prevents the existence of some _CategoriaDescricao = NULL
		      ) AS [Descricao],
			  NULL, -- MapTo will be filled later by user
			  CAST('false' as bit),
			  GETDATE(),
			  GETDATE()
		FROM
			  (
					-- un-existing but needed matching rules
					SELECT DISTINCT ci.FornecedorCodigo, ci._CategoriaCodigo AS Codigo
					FROM [dbo].[CotacoesIncompletasView] ci
					EXCEPT
					SELECT tm.FornecedorCodigo, tm.Codigo
					FROM [dbo].[CategoriasMatching] tm
			  ) um
		



		-- fill output @info with sucess message
		SET @Info = '[Step2b1a_Mappings_Categories_FeedNewRules-01] Number of created matching rules: ' + CAST(@@ROWCOUNT as nvarchar);

		-- send true to output
		RETURN 1;

	END TRY

	BEGIN CATCH
		-- fill output @info with occurred error message
		SET @Info = '[Step2b1a_Mappings_Categories_FeedNewRules-02] ' + CAST(ERROR_NUMBER() as nvarchar) + ' - ' + ERROR_MESSAGE();

		-- send false to output
		RETURN 0;

	END CATCH

RETURN;
GO
PRINT N'Creating [dbo].[Step2b1a_Mappings_Statuses_FeedNewRules]...';


GO
/*
	This SP feeds Statuses Matching table with new rules, considering the new incoming quotations
*/


CREATE PROCEDURE [dbo].[Step2b1a_Mappings_Statuses_FeedNewRules]
	@Info nvarchar(256) OUTPUT
AS
	
	-- new rules feeding
	BEGIN TRY

		/*
			Feed (...)Matching table with new incomplete rules, to simplify mapping work to the user.
		*/
		INSERT [dbo].[EstadosMatching] (FornecedorCodigo, Codigo, Descricao, MapTo, Inativo, Criacao, Versao)
	
		SELECT um.FornecedorCodigo, 
			   um.Codigo,
			   (
					-- get 1st existing description in CotacoesIncompletasView for this entity
					SELECT TOP 1 CASE WHEN ci._EstadoDescricao IS NULL THEN '(vazio)'
									  ELSE ci._EstadoDescricao
								 END
					FROM [dbo].[CotacoesIncompletasView] ci
					WHERE ci.FornecedorCodigo = um.FornecedorCodigo
						  AND ci._EstadoCodigo = um.Codigo
				    ORDER BY ci._EstadoDescricao DESC  -- prevents the existence of some _EstadoDescricao = NULL
		      ) AS [Descricao],
			  NULL, -- MapTo will be filled later by user
			  CAST('false' as bit),
			  GETDATE(),
			  GETDATE()
		FROM
			  (
					-- un-existing but needed matching rules
					SELECT DISTINCT ci.FornecedorCodigo, ci._EstadoCodigo AS Codigo
					FROM [dbo].[CotacoesIncompletasView] ci
					EXCEPT
					SELECT dm.FornecedorCodigo, dm.Codigo
					FROM [dbo].[EstadosMatching] dm
			  ) um

		



		-- fill output @info with sucess message
		SET @Info = '[Step2b1a_Mappings_Statuses_FeedNewRules-01] Number of created matching rules: ' + CAST(@@ROWCOUNT as nvarchar);

		-- send true to output
		RETURN 1;

	END TRY

	BEGIN CATCH
		-- fill output @info with occurred error message
		SET @Info = '[Step2b1a_Mappings_Statuses_FeedNewRules-02] ' + CAST(ERROR_NUMBER() as nvarchar) + ' - ' + ERROR_MESSAGE();

		-- send false to output
		RETURN 0;

	END CATCH

RETURN;
GO
PRINT N'Creating [dbo].[Step2b1a_Mappings_Stocks_FeedNewRules]...';


GO
/*
	This SP feeds StocksMatching table with new rules, considering the new incoming quotations
*/


CREATE PROCEDURE [dbo].[Step2b1a_Mappings_Stocks_FeedNewRules]
	@Info nvarchar(256) OUTPUT
AS
	
	-- new rules feeding
	BEGIN TRY

		/*
			Feed (...)Matching table with new incomplete rules, to simplify mapping work to the user.
		*/

		INSERT [dbo].[StocksMatching] (FornecedorCodigo, Codigo, Descricao, MapTo, Inativo, Criacao, Versao)
	
		SELECT um.FornecedorCodigo, 
			   um.Codigo,
			   (
					-- get 1st existing description in CotacoesIncompletasView for this entity
					SELECT TOP 1 CASE WHEN ci._StockDescricao IS NULL THEN '(vazio)'
									  ELSE ci._StockDescricao
								 END
					FROM [dbo].[CotacoesIncompletasView] ci
					WHERE ci.FornecedorCodigo = um.FornecedorCodigo
						  AND ci._StockCodigo = um.Codigo
				    ORDER BY ci._StockDescricao DESC  -- prevents the existence of some _StockDescricao = NULL
		      ) AS [Descricao],
			  NULL, -- MapTo will be filled later by user
			  CAST('false' as bit),
			  GETDATE(),
			  GETDATE()
		FROM
			  (
					-- un-existing but needed matching rules
					SELECT DISTINCT ci.FornecedorCodigo, ci._StockCodigo AS Codigo
					FROM [dbo].[CotacoesIncompletasView] ci
					EXCEPT
					SELECT sm.FornecedorCodigo, sm.Codigo
					FROM [dbo].[StocksMatching] sm
			  ) um
		



		-- fill output @info with sucess message
		SET @Info = '[Step2b1a_Mappings_Stocks_FeedNewRules-01] Number of created matching rules: ' + CAST(@@ROWCOUNT as nvarchar);

		-- send true to output
		RETURN 1;

	END TRY

	BEGIN CATCH
		-- fill output @info with occurred error message
		SET @Info = '[Step2b1a_Mappings_Stocks_FeedNewRules-02] ' + CAST(ERROR_NUMBER() as nvarchar) + ' - ' + ERROR_MESSAGE();

		-- send false to output
		RETURN 0;

	END CATCH

RETURN;
GO
PRINT N'Creating [dbo].[Step2b1a_Mappings_Taxes_FeedNewRules]...';


GO
/*
	This SP feeds Taxes Matching table with new rules, considering the new incoming quotations
*/


CREATE PROCEDURE [dbo].[Step2b1a_Mappings_Taxes_FeedNewRules]
	@Info nvarchar(256) OUTPUT
AS
	
	-- new rules feeding
	BEGIN TRY

		/*
			Feed (...)Matching table with new incomplete rules, to simplify mapping work to the user.
		*/

		INSERT [dbo].[ImpostosMatching] (FornecedorCodigo, Codigo, Descricao, MapTo, Inativo, Criacao, Versao)
	
		SELECT um.FornecedorCodigo, 
			   um.Codigo,
			   (
					-- get 1st existing description in CotacoesIncompletasView for this entity
					SELECT TOP 1 CASE WHEN ci._ImpostoDescricao IS NULL THEN '(vazio)'
									  ELSE ci._ImpostoDescricao
								 END
					FROM [dbo].[CotacoesIncompletasView] ci
					WHERE ci.FornecedorCodigo = um.FornecedorCodigo
						  AND ci._ImpostoCodigo = um.Codigo
				    ORDER BY ci._ImpostoDescricao DESC  -- prevents the existence of some _ImpostoDescricao = NULL
		      ) AS [Descricao],
			  NULL, -- MapTo will be filled later by user
			  CAST('false' as bit),
			  GETDATE(),
			  GETDATE()
		FROM
			  (
					-- un-existing but needed matching rules
					SELECT DISTINCT ci.FornecedorCodigo, ci._ImpostoCodigo AS Codigo
					FROM [dbo].[CotacoesIncompletasView] ci
					EXCEPT
					SELECT im.FornecedorCodigo, im.Codigo
					FROM [dbo].[ImpostosMatching] im
			  ) um
		



		-- fill output @info with sucess message
		SET @Info = '[Step2b1a_Mappings_Taxes_FeedNewRules-01] Number of created matching rules: ' + CAST(@@ROWCOUNT as nvarchar);

		-- send true to output
		RETURN 1;

	END TRY

	BEGIN CATCH
		-- fill output @info with occurred error message
		SET @Info = '[Step2b1a_Mappings_Taxes_FeedNewRules-02] ' + CAST(ERROR_NUMBER() as nvarchar) + ' - ' + ERROR_MESSAGE();

		-- send false to output
		RETURN 0;

	END CATCH

RETURN;
GO
PRINT N'Creating [dbo].[Step2b1b_Mappings_Addons_Map]...';


GO
/*
	This SP, perform Addons Mapping of incomplete Quotations.
*/


CREATE PROCEDURE [dbo].[Step2b1b_Mappings_Addons_Map]
	@Info nvarchar(256) OUTPUT
AS
	
	-- begin matching
	BEGIN TRY

		/*
			Map entities considering (...)Matching rules.
		*/
		UPDATE [dbo].[CotacoesIncompletasView]
		SET ComplementoCodigo = cm.MapTo,
			Versao = GETDATE()

		/*  Using (...)IncompletasView I am assuring that I'm only working with Cotacoes where Inactivo='false' and Completo='false'
			(although, with this mapping lack, never the quotation whould be completed - so this control is redundant)
		*/
		FROM [dbo].[CotacoesIncompletasView] ci
			INNER JOIN [dbo].[ComplementosMatching] cm
				ON ci.FornecedorCodigo = cm.FornecedorCodigo
					AND ci._ComplementoCodigo = cm.Codigo

		-- filter only active matching rules with MapTo already settled, and not mapped incomplete quotations
		WHERE cm.Inativo = CAST('false' as bit)
			  AND ci.ComplementoCodigo IS NULL
			  AND cm.MapTo IS NOT NULL



		-- fill output @info with sucess message
		SET @Info = '[Step2b1b_Mappings_Addons_Map-01] Number of mapped quotations: ' + CAST(@@ROWCOUNT as nvarchar);

		-- send true to output
		RETURN 1;

	END TRY

	BEGIN CATCH
		-- fill output @info with occurred error message
		SET @Info = '[Step2b1b_Mappings_Addons_Map-02] ' + CAST(ERROR_NUMBER() as nvarchar) + ' - ' + ERROR_MESSAGE();

		-- send false to output
		RETURN 0;

	END CATCH

RETURN;
GO
PRINT N'Creating [dbo].[Step2b1b_Mappings_Brands_Map]...';


GO
/*
	This SP, perform Brand Mapping of incomplete Quotations.
*/


CREATE PROCEDURE [dbo].[Step2b1b_Mappings_Brands_Map]
	@Info nvarchar(256) OUTPUT
AS
	
	-- begin matching
	BEGIN TRY

		/*
			Map entities considering (...)Matching rules.
		*/
		UPDATE [dbo].[CotacoesIncompletasView]
		SET MarcaCodigo = mm.MapTo,
			Versao = GETDATE()

		/*  Using (...)IncompletasView I am assuring that I'm only working with Cotacoes where Inactivo='false' and Completo='false'
			(although, with this mapping lack, never the quotation whould be completed - so this control is redundant)
		*/
		FROM [dbo].[CotacoesIncompletasView] ci
			INNER JOIN [dbo].[MarcasMatching] mm
				ON ci.FornecedorCodigo = mm.FornecedorCodigo
					AND ci._MarcaCodigo = mm.Codigo

		-- filter only active matching rules with MapTo already settled, and not mapped incomplete quotations
		WHERE mm.Inativo = CAST('false' as bit)
			  AND ci.MarcaCodigo IS NULL
			  AND mm.MapTo IS NOT NULL



		-- fill output @info with sucess message
		SET @Info = '[Step2b1b_Mappings_Brands_Map-01] Number of mapped quotations: ' + CAST(@@ROWCOUNT as nvarchar);

		-- send true to output
		RETURN 1;

	END TRY

	BEGIN CATCH
		-- fill output @info with occurred error message
		SET @Info = '[Step2b1b_Mappings_Brands_Map-02] ' + CAST(ERROR_NUMBER() as nvarchar) + ' - ' + ERROR_MESSAGE();

		-- send false to output
		RETURN 0;

	END CATCH

RETURN;
GO
PRINT N'Creating [dbo].[Step2b1b_Mappings_Categories_Map]...';


GO
/*
	This SP, perform Category Mapping of incomplete Quotations.
*/


CREATE PROCEDURE [dbo].[Step2b1b_Mappings_Categories_Map]
	@Info nvarchar(256) OUTPUT
AS
	
	-- begin matching
	BEGIN TRY

		/*
			Map entities considering (...)Matching rules.
		*/
		UPDATE [dbo].[CotacoesIncompletasView]
		SET CategoriaCodigo = tm.MapTo,
			Versao = GETDATE()

		/*  Using (...)IncompletasView I am assuring that I'm only working with Cotacoes where Inactivo='false' and Completo='false'
			(although, with this mapping lack, never the quotation whould be completed - so this control is redundant)
		*/
		FROM [dbo].[CotacoesIncompletasView] ci
			INNER JOIN [dbo].[CategoriasMatching] tm
				ON ci.FornecedorCodigo = tm.FornecedorCodigo
					AND ci._CategoriaCodigo = tm.Codigo

		-- filter only active matching rules with MapTo already settled, and not mapped incomplete quotations
		WHERE tm.Inativo = CAST('false' as bit)
			  AND ci.CategoriaCodigo IS NULL
			  AND tm.MapTo IS NOT NULL



		-- fill output @info with sucess message
		SET @Info = '[Step2b1b_Mappings_Categories_Map-01] Number of mapped quotations: ' + CAST(@@ROWCOUNT as nvarchar);

		-- send true to output
		RETURN 1;

	END TRY

	BEGIN CATCH
		-- fill output @info with occurred error message
		SET @Info = '[Step2b1b_Mappings_Categories_Map-02] ' + CAST(ERROR_NUMBER() as nvarchar) + ' - ' + ERROR_MESSAGE();

		-- send false to output
		RETURN 0;

	END CATCH

RETURN;
GO
PRINT N'Creating [dbo].[Step2b1b_Mappings_Statuses_Map]...';


GO
/*
	This SP, perform Statuses Mapping of incomplete Quotations.
*/


CREATE PROCEDURE [dbo].[Step2b1b_Mappings_Statuses_Map]
	@Info nvarchar(256) OUTPUT
AS
	
	-- begin matching
	BEGIN TRY

		/*
			Map entities considering (...)Matching rules.
		*/
		UPDATE [dbo].[CotacoesIncompletasView]
		SET EstadoCodigo = dm.MapTo,
			Versao = GETDATE()

		/*  Using (...)IncompletasView I am assuring that I'm only working with Cotacoes where Inactivo='false' and Completo='false'
			(although, with this mapping lack, never the quotation whould be completed - so this control is redundant)
		*/
		FROM [dbo].[CotacoesIncompletasView] ci
			INNER JOIN [dbo].[EstadosMatching] dm
				ON ci.FornecedorCodigo = dm.FornecedorCodigo
					AND ci._EstadoCodigo = dm.Codigo

		-- filter only active matching rules with MapTo already settled, and not mapped incomplete quotations
		WHERE dm.Inativo = CAST('false' as bit)
			  AND ci.EstadoCodigo IS NULL
			  AND dm.MapTo IS NOT NULL



		-- fill output @info with sucess message
		SET @Info = '[Step2b1b_Mappings_Statuses_Map-01] Number of mapped quotations: ' + CAST(@@ROWCOUNT as nvarchar);

		-- send true to output
		RETURN 1;

	END TRY

	BEGIN CATCH
		-- fill output @info with occurred error message
		SET @Info = '[Step2b1b_Mappings_Statuses_Map-02] ' + CAST(ERROR_NUMBER() as nvarchar) + ' - ' + ERROR_MESSAGE();

		-- send false to output
		RETURN 0;

	END CATCH

RETURN;
GO
PRINT N'Creating [dbo].[Step2b1b_Mappings_Stocks_Map]...';


GO
/*
	This SP, perform Stock Mapping of incomplete Quotations.
*/


CREATE PROCEDURE [dbo].[Step2b1b_Mappings_Stocks_Map]
	@Info nvarchar(256) OUTPUT
AS
	
	-- begin matching
	BEGIN TRY

		/*
			Map entities considering (...)Matching rules.
		*/
		UPDATE [dbo].[CotacoesIncompletasView]
		SET StockCodigo = sm.MapTo,
			Versao = GETDATE()

		/*  Using (...)IncompletasView I am assuring that I'm only working with Cotacoes where Inactivo='false' and Completo='false'
			(although, with this mapping lack, never the quotation whould be completed - so this control is redundant)
		*/
		FROM [dbo].[CotacoesIncompletasView] ci
			INNER JOIN [dbo].[StocksMatching] sm
				ON ci.FornecedorCodigo = sm.FornecedorCodigo
					AND ci._StockCodigo = sm.Codigo

		-- filter only active matching rules with MapTo already settled, and not mapped incomplete quotations
		WHERE sm.Inativo = CAST('false' as bit)
			  AND ci.StockCodigo IS NULL
			  AND sm.MapTo IS NOT NULL



		-- fill output @info with sucess message
		SET @Info = '[Step2b1b_Mappings_Stocks_Map-01] Number of mapped quotations: ' + CAST(@@ROWCOUNT as nvarchar);

		-- send true to output
		RETURN 1;

	END TRY

	BEGIN CATCH
		-- fill output @info with occurred error message
		SET @Info = '[Step2b1b_Mappings_Stocks_Map-02] ' + CAST(ERROR_NUMBER() as nvarchar) + ' - ' + ERROR_MESSAGE();

		-- send false to output
		RETURN 0;

	END CATCH

RETURN;
GO
PRINT N'Creating [dbo].[Step2b1b_Mappings_Taxes_Map]...';


GO
/*
	This SP, perform Taxes Mapping of incomplete Quotations.
*/


CREATE PROCEDURE [dbo].[Step2b1b_Mappings_Taxes_Map]
	@Info nvarchar(256) OUTPUT
AS
	
	-- begin matching
	BEGIN TRY

		/*
			Map entities considering (...)Matching rules.
		*/
		UPDATE [dbo].[CotacoesIncompletasView]
		SET ImpostoCodigo = im.MapTo,
			Versao = GETDATE()

		/*  Using (...)IncompletasView I am assuring that I'm only working with Cotacoes where Inactivo='false' and Completo='false'
			(although, with this mapping lack, never the quotation whould be completed - so this control is redundant)
		*/
		FROM [dbo].[CotacoesIncompletasView] ci
			INNER JOIN [dbo].[ImpostosMatching] im
				ON ci.FornecedorCodigo = im.FornecedorCodigo
					AND ci._ImpostoCodigo = im.Codigo

		-- filter only active matching rules with MapTo already settled, and not mapped incomplete quotations
		WHERE im.Inativo = CAST('false' as bit)
			  AND ci.ImpostoCodigo IS NULL
			  AND im.MapTo IS NOT NULL



		-- fill output @info with sucess message
		SET @Info = '[Step2b1b_Mappings_Taxes_Map-01] Number of mapped quotations: ' + CAST(@@ROWCOUNT as nvarchar);

		-- send true to output
		RETURN 1;

	END TRY

	BEGIN CATCH
		-- fill output @info with occurred error message
		SET @Info = '[Step2b1b_Mappings_Taxes_Map-02] ' + CAST(ERROR_NUMBER() as nvarchar) + ' - ' + ERROR_MESSAGE();

		-- send false to output
		RETURN 0;

	END CATCH

RETURN;
GO
PRINT N'Creating [dbo].[Step2b1c_Mappings_Addons_Notifications]...';


GO
/*
	This SP makes sure that user is notified via CotacoesAvisos table, that something 
	wrong happened in the mapping task.
*/

CREATE PROCEDURE [dbo].[Step2b1c_Mappings_Addons_Notifications]
	@Info nvarchar(256) OUTPUT
AS
	
	-- insert notifications on CotacoesAvisos table
	BEGIN TRY

		/*
			Insert notifications rows for all incomplete quotations that remain unmapped
		*/
		INSERT INTO [dbo].[CotacoesAvisos] 
				    (Id, FornecedorCodigo, Data, _ProdutoCodigo, _ComplementoCodigo, AvisoTipoCodigo, Descricao, Criacao)

		SELECT NEWID(), 
			   ci.FornecedorCodigo,
			   ci.Data,
			   ci._ProdutoCodigo,
			   ci._ComplementoCodigo,
			   CASE WHEN cm.Inativo = CAST('true' as bit) THEN 'CICM1' -- inactive mapping rule
					ELSE 'CICM0'									   -- incomplete mapping rule
			   END AS AvisoTipoCodigo,
			   'verifique regra de matching!' AS Descricao,
			   GETDATE() AS Criacao

		FROM [dbo].[CotacoesIncompletasView] ci
			 INNER JOIN [dbo].[ComplementosMatching] cm
				ON ci.FornecedorCodigo = cm.FornecedorCodigo
					AND ci._ComplementoCodigo = cm.Codigo

		-- filter all quotations not yet mapped after the mapping occurrence
		WHERE ci.ComplementoCodigo IS NULL



		-- fill output @info with sucess message
		SET @Info = '[Step2b1c_Mappings_Addons_Notifications-01] Number of inserted notifications: ' + CAST(@@ROWCOUNT as nvarchar);

		-- send true to output
		RETURN 1;

	END TRY

	BEGIN CATCH
		-- fill output @info with occurred error message
		SET @Info = '[Step2b1c_Mappings_Addons_Notifications-02] ' + CAST(ERROR_NUMBER() as nvarchar) + ' - ' + ERROR_MESSAGE();

		-- send false to output
		RETURN 0;

	END CATCH

RETURN;
GO
PRINT N'Creating [dbo].[Step2b1c_Mappings_Brands_Notifications]...';


GO
/*
	This SP makes sure that user is notified via CotacoesAvisos table, that something 
	wrong happened in the mapping task.
*/

CREATE PROCEDURE [dbo].[Step2b1c_Mappings_Brands_Notifications]
	@Info nvarchar(256) OUTPUT
AS
	
	-- insert notifications on CotacoesAvisos table
	BEGIN TRY

		/*
			Insert notifications rows for all incomplete quotations that remain unmapped
		*/
		INSERT INTO [dbo].[CotacoesAvisos] 
				    (Id, FornecedorCodigo, Data, _ProdutoCodigo, _ComplementoCodigo, AvisoTipoCodigo, Descricao, Criacao)

		SELECT NEWID(), 
			   ci.FornecedorCodigo,
			   ci.Data,
			   ci._ProdutoCodigo,
			   ci._ComplementoCodigo,
			   CASE WHEN mm.Inativo = CAST('true' as bit) THEN 'CIMM1' -- inactive mapping rule
					ELSE 'CIMM0'									   -- incomplete mapping rule
			   END AS AvisoTipoCodigo,
			   'verifique regra de matching!' AS Descricao,
			   GETDATE() AS Criacao

		FROM [dbo].[CotacoesIncompletasView] ci
			 INNER JOIN [dbo].[MarcasMatching] mm
				ON ci.FornecedorCodigo = mm.FornecedorCodigo
					AND ci._MarcaCodigo = mm.Codigo

		-- filter all quotations not yet mapped after the mapping occurrence
		WHERE ci.MarcaCodigo IS NULL



		-- fill output @info with sucess message
		SET @Info = '[Step2b1c_Mappings_Brands_Notifications-01] Number of inserted notifications: ' + CAST(@@ROWCOUNT as nvarchar);

		-- send true to output
		RETURN 1;

	END TRY

	BEGIN CATCH
		-- fill output @info with occurred error message
		SET @Info = '[Step2b1c_Mappings_Brands_Notifications-02] ' + CAST(ERROR_NUMBER() as nvarchar) + ' - ' + ERROR_MESSAGE();

		-- send false to output
		RETURN 0;

	END CATCH

RETURN;
GO
PRINT N'Creating [dbo].[Step2b1c_Mappings_Categories_Notifications]...';


GO
/*
	This SP makes sure that user is notified via CotacoesAvisos table, that something 
	wrong happened in the mapping task.
*/

CREATE PROCEDURE [dbo].[Step2b1c_Mappings_Categories_Notifications]
	@Info nvarchar(256) OUTPUT
AS
	
	-- insert notifications on CotacoesAvisos table
	BEGIN TRY

		/*
			Insert notifications rows for all incomplete quotations that remain unmapped
		*/
		INSERT INTO [dbo].[CotacoesAvisos] 
				    (Id, FornecedorCodigo, Data, _ProdutoCodigo, _ComplementoCodigo, AvisoTipoCodigo, Descricao, Criacao)

		SELECT NEWID(), 
			   ci.FornecedorCodigo,
			   ci.Data,
			   ci._ProdutoCodigo,
			   ci._ComplementoCodigo,
			   CASE WHEN tm.Inativo = CAST('true' as bit) THEN 'CITM1' -- inactive mapping rule
					ELSE 'CITM0'									   -- incomplete mapping rule
			   END AS AvisoTipoCodigo,
			   'verifique regra de matching!' AS Descricao,
			   GETDATE() AS Criacao

		FROM [dbo].[CotacoesIncompletasView] ci
			 INNER JOIN [dbo].[CategoriasMatching] tm
				ON ci.FornecedorCodigo = tm.FornecedorCodigo
					AND ci._CategoriaCodigo = tm.Codigo

		-- filter all quotations not yet mapped after the mapping occurrence
		WHERE ci.CategoriaCodigo IS NULL



		-- fill output @info with sucess message
		SET @Info = '[Step2b1c_Mappings_Categories_Notifications-01] Number of inserted notifications: ' + CAST(@@ROWCOUNT as nvarchar);

		-- send true to output
		RETURN 1;

	END TRY

	BEGIN CATCH
		-- fill output @info with occurred error message
		SET @Info = '[Step2b1c_Mappings_Categories_Notifications-02] ' + CAST(ERROR_NUMBER() as nvarchar) + ' - ' + ERROR_MESSAGE();

		-- send false to output
		RETURN 0;

	END CATCH

RETURN;
GO
PRINT N'Creating [dbo].[Step2b1c_Mappings_Statuses_Notifications]...';


GO
/*
	This SP makes sure that user is notified via CotacoesAvisos table, that something 
	wrong happened in the mapping task.
*/

CREATE PROCEDURE [dbo].[Step2b1c_Mappings_Statuses_Notifications]
	@Info nvarchar(256) OUTPUT
AS
	
	-- insert notifications on CotacoesAvisos table
	BEGIN TRY

		/*
			Insert notifications rows for all incomplete quotations that remain unmapped
		*/
		INSERT INTO [dbo].[CotacoesAvisos] 
				    (Id, FornecedorCodigo, Data, _ProdutoCodigo, _ComplementoCodigo, AvisoTipoCodigo, Descricao, Criacao)

		SELECT NEWID(), 
			   ci.FornecedorCodigo,
			   ci.Data,
			   ci._ProdutoCodigo,
			   ci._ComplementoCodigo,
			   CASE WHEN dm.Inativo = CAST('true' as bit) THEN 'CIDM1' -- inactive mapping rule
					ELSE 'CIDM0'									   -- incomplete mapping rule
			   END AS AvisoTipoCodigo,
			   'verifique regra de matching!' AS Descricao,
			   GETDATE() AS Criacao

		FROM [dbo].[CotacoesIncompletasView] ci
			 INNER JOIN [dbo].[EstadosMatching] dm
				ON ci.FornecedorCodigo = dm.FornecedorCodigo
					AND ci._EstadoCodigo = dm.Codigo

		-- filter all quotations not yet mapped after the mapping occurrence
		WHERE ci.EstadoCodigo IS NULL



		-- fill output @info with sucess message
		SET @Info = '[Step2b1c_Mappings_Statuses_Notifications-01] Number of inserted notifications: ' + CAST(@@ROWCOUNT as nvarchar);

		-- send true to output
		RETURN 1;

	END TRY

	BEGIN CATCH
		-- fill output @info with occurred error message
		SET @Info = '[Step2b1c_Mappings_Statuses_Notifications-02] ' + CAST(ERROR_NUMBER() as nvarchar) + ' - ' + ERROR_MESSAGE();

		-- send false to output
		RETURN 0;

	END CATCH

RETURN;
GO
PRINT N'Creating [dbo].[Step2b1c_Mappings_Stocks_Notifications]...';


GO
/*
	This SP makes sure that user is notified via CotacoesAvisos table, that something 
	wrong happened in the mapping task.
*/

CREATE PROCEDURE [dbo].[Step2b1c_Mappings_Stocks_Notifications]
	@Info nvarchar(256) OUTPUT
AS
	
	-- insert notifications on CotacoesAvisos table
	BEGIN TRY

		/*
			Insert notifications rows for all incomplete quotations that remain unmapped
		*/
		INSERT INTO [dbo].[CotacoesAvisos] 
				    (Id, FornecedorCodigo, Data, _ProdutoCodigo, _ComplementoCodigo, AvisoTipoCodigo, Descricao, Criacao)

		SELECT NEWID(), 
			   ci.FornecedorCodigo,
			   ci.Data,
			   ci._ProdutoCodigo,
			   ci._ComplementoCodigo,
			   CASE WHEN sm.Inativo = CAST('true' as bit) THEN 'CISM1' -- inactive mapping rule
					ELSE 'CISM0'									   -- incomplete mapping rule
			   END AS AvisoTipoCodigo,
			   'verifique regra de matching!' AS Descricao,
			   GETDATE() AS Criacao

		FROM [dbo].[CotacoesIncompletasView] ci
			 INNER JOIN [dbo].[StocksMatching] sm
				ON ci.FornecedorCodigo = sm.FornecedorCodigo
					AND ci._StockCodigo = sm.Codigo

		-- filter all quotations not yet mapped after the mapping occurrence
		WHERE ci.StockCodigo IS NULL



		-- fill output @info with sucess message
		SET @Info = '[Step2b1c_Mappings_Stocks_Notifications-01] Number of inserted notifications: ' + CAST(@@ROWCOUNT as nvarchar);

		-- send true to output
		RETURN 1;

	END TRY

	BEGIN CATCH
		-- fill output @info with occurred error message
		SET @Info = '[Step2b1c_Mappings_Stocks_Notifications-02] ' + CAST(ERROR_NUMBER() as nvarchar) + ' - ' + ERROR_MESSAGE();

		-- send false to output
		RETURN 0;

	END CATCH

RETURN;
GO
PRINT N'Creating [dbo].[Step2b1c_Mappings_Taxes_Notifications]...';


GO
/*
	This SP makes sure that user is notified via CotacoesAvisos table, that something 
	wrong happened in the mapping task.
*/

CREATE PROCEDURE [dbo].[Step2b1c_Mappings_Taxes_Notifications]
	@Info nvarchar(256) OUTPUT
AS
	
	-- insert notifications on CotacoesAvisos table
	BEGIN TRY

		/*
			Insert notifications rows for all incomplete quotations that remain unmapped
		*/
		INSERT INTO [dbo].[CotacoesAvisos] 
				    (Id, FornecedorCodigo, Data, _ProdutoCodigo, _ComplementoCodigo, AvisoTipoCodigo, Descricao, Criacao)

		SELECT NEWID(), 
			   ci.FornecedorCodigo,
			   ci.Data,
			   ci._ProdutoCodigo,
			   ci._ComplementoCodigo,
			   CASE WHEN im.Inativo = CAST('true' as bit) THEN 'CIIM1' -- inactive mapping rule
					ELSE 'CIIM0'									   -- incomplete mapping rule
			   END AS AvisoTipoCodigo,
			   'verifique regra de matching!' AS Descricao,
			   GETDATE() AS Criacao

		FROM [dbo].[CotacoesIncompletasView] ci
			 INNER JOIN [dbo].[ImpostosMatching] im
				ON ci.FornecedorCodigo = im.FornecedorCodigo
					AND ci._ImpostoCodigo = im.Codigo

		-- filter all quotations not yet mapped after the mapping occurrence
		WHERE ci.ImpostoCodigo IS NULL



		-- fill output @info with sucess message
		SET @Info = '[Step2b1c_Mappings_Taxes_Notifications-01] Number of inserted notifications: ' + CAST(@@ROWCOUNT as nvarchar);

		-- send true to output
		RETURN 1;

	END TRY

	BEGIN CATCH
		-- fill output @info with occurred error message
		SET @Info = '[Step2b1c_Mappings_Taxes_Notifications-02] ' + CAST(ERROR_NUMBER() as nvarchar) + ' - ' + ERROR_MESSAGE();

		-- send false to output
		RETURN 0;

	END CATCH

RETURN;
GO
PRINT N'Creating [dbo].[Step2b1z_QuotationRules_FeedNewRules]...';


GO
/*
	This SP feeds Quotations Rues (CotacoesRegras) table with new rules, considering the new just mapped quotations
*/


CREATE PROCEDURE [dbo].[Step2b1z_QuotationRules_FeedNewRules]
	@Info nvarchar(256) OUTPUT
AS
	
	-- new rules feeding
	BEGIN TRY

		/*
			Feed CotacoesRegras table with new incomplete rules. 
			Consider only Quotations that are already mapped.
		*/
		
		INSERT [dbo].[CotacoesRegras] (FornecedorCodigo, MarcaCodigo, CategoriaCodigo, StockCodigo, HorasValidade, StockCodigoSubstituto, DataReset, Notas, Versao)

		SELECT um.FornecedorCodigo, 
			   um.MarcaCodigo,
			   um.CategoriaCodigo,
			   um.StockCodigo, 
			   f.HorasValidadeSugestao,
			   NULL,
			   NULL,
			   NULL,
			   GETDATE()

		FROM
			  (
					-- un-existing but needed Quotation Rules (CotacoesRegras)
					SELECT DISTINCT ci.FornecedorCodigo, ci.MarcaCodigo, CategoriaCodigo, StockCodigo
					FROM [dbo].[CotacoesIncompletasView] ci
					WHERE MarcaCodigo IS NOT NULL
						  AND CategoriaCodigo IS NOT NULL
						  AND StockCodigo IS NOT NULL
						  AND ImpostoCodigo IS NOT NULL
						  AND ComplementoCodigo IS NOT NULL
						  AND EstadoCodigo IS NOT NULL

					EXCEPT

					SELECT cr.FornecedorCodigo, cr.MarcaCodigo, cr.CategoriaCodigo, cr.StockCodigo
					FROM [dbo].[CotacoesRegras] cr
			  ) um

			INNER JOIN [dbo].[Fornecedores] f
				ON um.FornecedorCodigo = f.Codigo



		-- fill output @info with sucess message
		SET @Info = '[Step2b1z_QuotationRules_FeedNewRules-01] Number of created rules: ' + CAST(@@ROWCOUNT as nvarchar);

		-- send true to output
		RETURN 1;

	END TRY

	BEGIN CATCH
		-- fill output @info with occurred error message
		SET @Info = '[Step2b1z_QuotationRules_FeedNewRules-02] ' + CAST(ERROR_NUMBER() as nvarchar) + ' - ' + ERROR_MESSAGE();

		-- send false to output
		RETURN 0;

	END CATCH

RETURN;
GO
PRINT N'Creating [dbo].[Step2c1_MappingProducts_FeedNewRules]...';


GO
/*
	This SP feeds Products Matching rules (ProdutosMatching) with new rules to be filled manually by user
	or automatic (specific to products matching) later in algorithm process.
*/


CREATE PROCEDURE [dbo].[Step2c1_MappingProducts_FeedNewRules]
	@Info nvarchar(256) OUTPUT
AS
	
	-- new rules feeding
	BEGIN TRY

		/*
			Feed (...)Matching table with new incomplete rules, to simplify mapping work to the user or to be automatically mapped later.
		*/
		INSERT [dbo].[ProdutosMatching] (FornecedorCodigo, ComplementoCodigo, Codigo, Descricao, MapTo, 
			   HorasValidadeCotacao, StockCodigoSubstituto, DispensaPrevencaoPrecosDesfasados, DispensaPrevencaoFalsoStock, DataReset, Notas,
			   Inativo, Criacao, Versao)

		SELECT um.FornecedorCodigo,
			   um.ComplementoCodigo, 
			   um.Codigo,
			   (
					-- get 1st existing description in CotacoesIncompletasMapeamentoProdutoView for this product
					SELECT TOP 1 CASE WHEN ci._Descricao IS NULL THEN '(vazio)'
									  ELSE ci._Descricao
								 END
					FROM [dbo].[CotacoesIncompletasMapeamentoProdutoView] ci
					WHERE ci.FornecedorCodigo = um.FornecedorCodigo
						  AND ci.ComplementoCodigo = um.ComplementoCodigo
						  AND ci._ProdutoCodigo = um.Codigo
				    ORDER BY ci._Descricao DESC  -- prevents the existence of some _Descricao = NULL
		      ) AS [Descricao],
			  NULL,		-- MapTo will be filled later by user or automatic next in the algorithm (specific to products)
			  NULL,		-- this null means that prevails the rules defined on CotacoesRegras. (to automatic set as inative all quotations for this supplier / product, set this value to -1)
			  NULL,		-- use this field if you want to specify a stock position directly to the product. this rule prevails to CotacoesRegras rules
			  CAST('false' as bit),	-- by default all products must be tested to offset prices..
			  CAST('false' as bit),	-- by default all products must be tested on FakeStock prevention
			  NULL,		-- Date to auto reset this custom definitions
			  NULL,
			  CAST('false' as bit),
			  GETDATE(),
			  GETDATE()
		FROM
			  (
					-- un-existing but needed matching rules
					SELECT DISTINCT ci.FornecedorCodigo, ci.ComplementoCodigo, ci._ProdutoCodigo AS Codigo
					FROM [dbo].[CotacoesIncompletasMapeamentoProdutoView] ci
					EXCEPT
					SELECT pm.FornecedorCodigo, pm.ComplementoCodigo, pm.Codigo
					FROM [dbo].[ProdutosMatching] pm
			  ) um



		-- fill output @info with sucess message
		SET @Info = '[Step2c1_MappingProducts_FeedNewRules-01] Number of created matching rules: ' + CAST(@@ROWCOUNT as nvarchar);

		-- send true to output
		RETURN 1;

	END TRY

	BEGIN CATCH
		-- fill output @info with occurred error message
		SET @Info = '[Step2c1_MappingProducts_FeedNewRules-02] ' + CAST(ERROR_NUMBER() as nvarchar) + ' - ' + ERROR_MESSAGE();

		-- send false to output
		RETURN 0;

	END CATCH

RETURN;
GO
PRINT N'Creating [dbo].[Step2c2_MappingProducts_InsertNewProducts]...';


GO
/*
	This SP create new Products based on new quotations received from suppliers.
*/


CREATE PROCEDURE [dbo].[Step2c2_MappingProducts_InsertNewProducts]
	@Info nvarchar(256) OUTPUT
AS
	
	-- new rules feeding
	BEGIN TRY

		/*
			Insert new Products
		*/
		INSERT [dbo].[Produtos] 
			   (
					Codigo, MarcaCodigo, CategoriaCodigo, ImpostoCodigo, FornecedorCodigo, Partnumber, Descricao,
					Descontinuado, Inativo, Criacao, Versao
			   )

		SELECT Referencia, MarcaCodigo, CategoriaCodigo, ImpostoCodigo, FornecedorCodigo, Partnumber, '(' + Partnumber + ')',
		       CAST('false' as bit), CAST('false' as bit), GETDATE(), GETDATE()
		FROM [dbo].[CotacoesMatrizCriacaoProdutosView]



		-- fill output @info with sucess message
		SET @Info = '[Step2c2_MappingProducts_InsertNewProducts-01] Number of created products: ' + CAST(@@ROWCOUNT as nvarchar);

		-- send true to output
		RETURN 1;

	END TRY

	BEGIN CATCH
		-- fill output @info with occurred error message
		SET @Info = '[Step2c2_MappingProducts_InsertNewProducts-02] ' + CAST(ERROR_NUMBER() as nvarchar) + ' - ' + ERROR_MESSAGE();

		-- send false to output
		RETURN 0;

	END CATCH

RETURN;
GO
PRINT N'Creating [dbo].[Step2c3_MappingProducts_FillMapTo]...';


GO
/*
	This SP, fills the MapTo field of de ProdutosMatching of suppliers autorized to automatic mapping.
*/


CREATE PROCEDURE [dbo].[Step2c3_MappingProducts_FillMapTo]
	@Info nvarchar(256) OUTPUT
AS
	
	-- begin fill MapTo fields of ProdutosMatching tasble
	BEGIN TRY

		/*
			begin automatic fill of MapTo fields
		*/
		UPDATE [dbo].[ProdutosMatching]
		SET MapTo = c.Referencia,
			Versao = GETDATE()

		/*  CotacoesMatrizPreenchimentoMapToView ensures that only suppliers autorized to automatic Matching are considered int this process
		    and only existing products (in products table) are setted.
		*/
		FROM [dbo].[ProdutosMatching] pm
			 INNER JOIN [dbo].[CotacoesMatrizPreenchimentoMapToView] c
				ON pm.FornecedorCodigo = c.FornecedorCodigo
				   AND pm.ComplementoCodigo = c.ComplementoCodigo
				   AND pm.Codigo = c._ProdutoCodigo

		-- filter only matching rules with a not set MapTo
		WHERE pm.MapTo IS NULL



		-- fill output @info with sucess message
		SET @Info = '[Step2c3_MappingProducts_FillMapTo-01] Number of ProdutosMatching, filled with a MapTo: ' + CAST(@@ROWCOUNT as nvarchar);

		-- send true to output
		RETURN 1;

	END TRY

	BEGIN CATCH
		-- fill output @info with occurred error message
		SET @Info = '[Step2c3_MappingProducts_FillMapTo-02] ' + CAST(ERROR_NUMBER() as nvarchar) + ' - ' + ERROR_MESSAGE();

		-- send false to output
		RETURN 0;

	END CATCH

RETURN;
GO
PRINT N'Creating [dbo].[Step2c4_MappingProducts_Map]...';


GO
/*
	This SP, perform Product Mapping of incomplete Quotations.
*/


CREATE PROCEDURE [dbo].[Step2c4_MappingProducts_Map]
	@Info nvarchar(256) OUTPUT
AS
	
	-- begin matching
	BEGIN TRY

		/*
			Map entities considering ProdutosMatching rules.
		*/
		UPDATE ci
		SET ProdutoCodigo = pm.MapTo,
			Versao = GETDATE()

		/*  Using CotacoesIncompletasMapeamentoProdutoView, I am assuring that I'm only working with Cotacoes where Inactivo='false' and Completo='false'
			(although, with this mapping lack, never the quotation whould be completed - so this control is redundant)
		*/
		FROM [dbo].[CotacoesIncompletasMapeamentoProdutoView] ci
			INNER JOIN [dbo].[ProdutosMatching] pm
				ON ci.FornecedorCodigo = pm.FornecedorCodigo
				   AND ci.ComplementoCodigo = pm.ComplementoCodigo
				   AND ci._ProdutoCodigo = pm.Codigo
			INNER JOIN [dbo].[Fornecedores] f
				ON ci.FornecedorCodigo = f.Codigo

		-- filter only active matching rules with MapTo already settled, and not mapped incomplete quotations
		WHERE pm.Inativo = CAST('false' as bit)
			  AND pm.MapTo IS NOT NULL
			  AND f.ProdutosMatchingAutomatico = CAST('true' as bit)



		-- fill output @info with sucess message
		SET @Info = '[Step2c4_MappingProducts_Map-01] Number of mapped quotations: ' + CAST(@@ROWCOUNT as nvarchar);

		-- send true to output
		RETURN 1;

	END TRY

	BEGIN CATCH
		-- fill output @info with occurred error message
		SET @Info = '[Step2c4_MappingProducts_Map-02] ' + CAST(ERROR_NUMBER() as nvarchar) + ' - ' + ERROR_MESSAGE();

		-- send false to output
		RETURN 0;

	END CATCH

RETURN;
GO
PRINT N'Creating [dbo].[Step2c5_MappingProducts_Notifications1]...';


GO
/*
	Notifications SP: 1 of 3	(not ambiguous partnumbers)

	This SP makes sure that user is notified via CotacoesAvisos table, that something 
	wrong happened in the mapping task.
*/

CREATE PROCEDURE [dbo].[Step2c5_MappingProducts_Notifications1]
	@Info nvarchar(256) OUTPUT
AS
	
	-- insert notifications on CotacoesAvisos table
	BEGIN TRY

		/*
			Insert notifications rows for all incomplete quotations that remain unmapped
		*/
		INSERT INTO [dbo].[CotacoesAvisos] 
				    (Id, FornecedorCodigo, Data, _ProdutoCodigo, _ComplementoCodigo, AvisoTipoCodigo, Descricao, Criacao)

		SELECT NEWID(), 
			   ci.FornecedorCodigo,
			   ci.Data,
			   ci._ProdutoCodigo,
			   ci._ComplementoCodigo,
			   
			   CASE WHEN pm.Inativo = CAST('true' as bit) THEN 'CIPM1'															-- rule mapping inactive
			        WHEN pm.Inativo = CAST('false' as bit) AND f.ProdutosCriacaoAutomatica = CAST('false' as bit) THEN 'CIPM2'	-- supplier can not insert products...
					WHEN pm.Inativo = CAST('false' as bit) AND f.ProdutosMatchingAutomatico = CAST('false' as bit) THEN 'CIPM3'	-- supplier can not do automatic matching
					ELSE 'CIPM0'																								-- mapping rule is incomplete (misses MapTo)
			   END AS AvisoTipoCodigo,

			   'verifique configurações de matching!' AS Descricao,
			   GETDATE() AS Criacao

		-- consider again only quotations missing yet (after processing) ProdutoCodigo mapping.
		FROM [dbo].[CotacoesIncompletasMapeamentoProdutoView] ci
			 INNER JOIN [dbo].[ProdutosMatching] pm
				ON ci.FornecedorCodigo = pm.FornecedorCodigo
				   AND ci.ComplementoCodigo = pm.ComplementoCodigo
				   AND ci._ProdutoCodigo = pm.Codigo
			 INNER JOIN [dbo].[Fornecedores] f
				ON ci.FornecedorCodigo = f.Codigo

		-- consider only quotations not in Partnumbers ambiguous list
		WHERE ci.Partnumber NOT IN
			  (
				   SELECT Partnumber FROM [dbo].[PartnumbersAmbiguosView]
			  )




		-- fill output @info with sucess message
		SET @Info = '[Step2c5_MappingProducts_Notifications1-01] Number of inserted notifications: ' + CAST(@@ROWCOUNT as nvarchar);

		-- send true to output
		RETURN 1;

	END TRY

	BEGIN CATCH
		-- fill output @info with occurred error message
		SET @Info = '[Step2c5_MappingProducts_Notifications1-02] ' + CAST(ERROR_NUMBER() as nvarchar) + ' - ' + ERROR_MESSAGE();

		-- send false to output
		RETURN 0;

	END CATCH

RETURN;
GO
PRINT N'Creating [dbo].[Step2c5_MappingProducts_Notifications2]...';


GO
/*
	Notifications SP: 2 of 3   (ambiguous partnumbers)

	This SP makes sure that user is notified via CotacoesAvisos table, that something 
	wrong happened in the mapping task.
*/

CREATE PROCEDURE [dbo].[Step2c5_MappingProducts_Notifications2]
	@Info nvarchar(256) OUTPUT
AS
	
	-- insert notifications on CotacoesAvisos table
	BEGIN TRY

		/*
			Insert notifications rows for all incomplete quotations that remain unmapped
		*/
		INSERT INTO [dbo].[CotacoesAvisos] 
				    (Id, FornecedorCodigo, Data, _ProdutoCodigo, _ComplementoCodigo, AvisoTipoCodigo, Descricao, Criacao)

		SELECT NEWID(), 
			   ci.FornecedorCodigo,
			   ci.Data,
			   ci._ProdutoCodigo,
			   ci._ComplementoCodigo,
			   'CIPM9',	-- Partnumber belongs to PartnumbersAmbiguous SET
			   'proceda à criação e mapeamento do produto manualmente!' AS Descricao,
			   GETDATE() AS Criacao

		-- consider again only quotations missing yet (after processing) ProdutoCodigo mapping.
		FROM [dbo].[CotacoesIncompletasMapeamentoProdutoView] ci
			 INNER JOIN [dbo].[ProdutosMatching] pm
				ON ci.FornecedorCodigo = pm.FornecedorCodigo
				   AND ci.ComplementoCodigo = pm.ComplementoCodigo
				   AND ci._ProdutoCodigo = pm.Codigo

		-- consider only quotations that are in Partnumbers ambiguous list
		WHERE ci.Partnumber IN
			  (
				   SELECT Partnumber FROM [dbo].[PartnumbersAmbiguosView]
			  )



		-- fill output @info with sucess message
		SET @Info = '[Step2c5_MappingProducts_Notifications2-01] Number of inserted notifications: ' + CAST(@@ROWCOUNT as nvarchar);

		-- send true to output
		RETURN 1;

	END TRY

	BEGIN CATCH
		-- fill output @info with occurred error message
		SET @Info = '[Step2c5_MappingProducts_Notifications2-02] ' + CAST(ERROR_NUMBER() as nvarchar) + ' - ' + ERROR_MESSAGE();

		-- send false to output
		RETURN 0;

	END CATCH

RETURN;
GO
PRINT N'Creating [dbo].[Step2c5_MappingProducts_Notifications3]...';


GO
/*
	Notifications SP: 3 of 3   (inactive products)

	This SP makes sure that user is notified via CotacoesAvisos table, that althought the quotation is mapped
	the product record is inactive...
*/

CREATE PROCEDURE [dbo].[Step2c5_MappingProducts_Notifications3]
	@Info nvarchar(256) OUTPUT
AS
	
	-- insert notifications on CotacoesAvisos table
	BEGIN TRY

		/*
			Insert notifications rows for all inactive products with active quotations
		*/
		INSERT INTO [dbo].[CotacoesAvisos] 
				    (Id, FornecedorCodigo, Data, _ProdutoCodigo, _ComplementoCodigo, AvisoTipoCodigo, Descricao, Criacao)

		SELECT NEWID(), 
			   c.FornecedorCodigo,
			   c.Data,
			   c._ProdutoCodigo,
			   c._ComplementoCodigo,
			   'CIPM4',	-- product is configured as inative (not active)
			   'produto configurado como inativo mas com cotações ativas, verifque!' AS Descricao,
			   GETDATE() AS Criacao

		-- consider again only quotations missing yet (after processing) ProdutoCodigo mapping.
		FROM [dbo].[CotacoesAtivasView] c
			 INNER JOIN [dbo].[Produtos] p
				ON c.ProdutoCodigo = p.Codigo

		-- consider only quotations that are in Partnumbers ambiguous list
		WHERE p.Inativo = CAST('true' as bit)



		-- fill output @info with sucess message
		SET @Info = '[Step2c5_MappingProducts_Notifications3-01] Number of inserted notifications: ' + CAST(@@ROWCOUNT as nvarchar);

		-- send true to output
		RETURN 1;

	END TRY

	BEGIN CATCH
		-- fill output @info with occurred error message
		SET @Info = '[Step2c5_MappingProducts_Notifications3-02] ' + CAST(ERROR_NUMBER() as nvarchar) + ' - ' + ERROR_MESSAGE();

		-- send false to output
		RETURN 0;

	END CATCH

RETURN;
GO
PRINT N'Creating [dbo].[Step2d1_Normalization_OtherFieldsFulfillment]...';


GO
/*
	This SP, perform Quotation other fields fulfillment.
*/


CREATE PROCEDURE [dbo].[Step2d1_Normalization_OtherFieldsFulfillment]
	@Info nvarchar(256) OUTPUT
AS

	BEGIN TRY

		/*
			Normalize and fill the remain Quotation internal fields.
		*/
		UPDATE ci
		SET ci.Descricao = ci.DescricaoUniformizada,
			ci.Caracteristicas = ci.CaracteristicasUniformizadas,
			ci.Link = ci.LinkUniformizado,
			ci.Imagem = ci.ImagemUniformizada,

			-- cost price
			ci.PrecoCusto = ci.PrecoCustoCalculado,
			ci.PrecoCustoFormula = ci.FormulaPrecoCustoCalculado,

			-- expiration date
			ci.Validade = ci.ValidadeCalculada,
			ci.ValidadeFormula = ci.FormulaValidadeCalculada,

			-- stockSubstituto
			ci.StockCodigoSubstituto = ci.StockCodigoSubstitutoCalculado,
			ci.StockCodigoSubstitutoJustificacao = ci.JustificacaoStockCodigoSubstitutoCalculado,
			
			-- version
			ci.Versao = GETDATE()


		/*  Using CotacoesIncompletasNormalizacaoView, I'm ensuring that I am working only with Incomplete Quotations  
			and adicional fields are generated only inside this view to simplify work of set internal fields of Quotations
			in Cotacoes table.
		*/
		FROM [dbo].[CotacoesIncompletasNormalizacaoView] ci



		-- fill output @info with sucess message
		SET @Info = '[Step2d1_Normalization_OtherFieldsFulfillment-01] Number of processed quotations: ' + CAST(@@ROWCOUNT as nvarchar);

		-- send true to output
		RETURN 1;

	END TRY

	BEGIN CATCH
		-- fill output @info with occurred error message
		SET @Info = '[Step2d1_Normalization_OtherFieldsFulfillment-02] ' + CAST(ERROR_NUMBER() as nvarchar) + ' - ' + ERROR_MESSAGE();

		-- send false to output
		RETURN 0;

	END CATCH

RETURN;
GO
PRINT N'Creating [dbo].[Step2d2_Normalization_SetComplete]...';


GO
/*
	This SP, set all filled quotations with the complete flat (Completo = true)
*/


CREATE PROCEDURE [dbo].[Step2d2_Normalization_SetComplete]
	@Info nvarchar(256) OUTPUT
AS

	BEGIN TRY

		/*
			Set complete all filled quotations
		*/
		UPDATE ci
		SET ci.Completo = CAST('true' as bit),
			ci.Versao = GETDATE()


		/*  Using CotacoesIncompletasFinalizacaoView, I'm ensuring that I am working only with Incomplete Quotations  
			that are ready to be settled as Completo = true
		*/
		FROM [dbo].[CotacoesIncompletasFinalizacaoView] ci



		-- fill output @info with sucess message
		SET @Info = '[Step2d2_Normalization_SetComplete-01] Number of quotations settled as completed: ' + CAST(@@ROWCOUNT as nvarchar);

		-- send true to output
		RETURN 1;

	END TRY

	BEGIN CATCH
		-- fill output @info with occurred error message
		SET @Info = '[Step2d2_Normalization_SetComplete-02] ' + CAST(ERROR_NUMBER() as nvarchar) + ' - ' + ERROR_MESSAGE();

		-- send false to output
		RETURN 0;

	END CATCH

RETURN;
GO
PRINT N'Creating [dbo].[Step3a1_Preparation_ProductMatchingsReset]...';


GO
/*
	This SP, resets all Product Matching rules (ProdutosMatching table) to it's defaults when date on DataReset field is reached.
*/


CREATE PROCEDURE [dbo].[Step3a1_Preparation_ProductMatchingsReset]
	@Info nvarchar(256) OUTPUT
AS

	BEGIN TRY

		/*
			Reset to default Product Matching rules with DataReset date <= GETDATE()
		*/
		
		UPDATE pm

			-- restablish defaults
		SET pm.HorasValidadeCotacao = NULL,
		    pm.StockCodigoSubstituto = NULL,
			pm.DispensaPrevencaoPrecosDesfasados = CAST('false' as bit),
			
			-- if there are some notes already settled on row do not remove them (append text at begining)
			pm.Notas =
					CASE WHEN pm.Notas IS NULL THEN '!reset (' + CONVERT(varchar, GETDATE(), 120) + ')'
					     ELSE SUBSTRING('!reset (' + CONVERT(varchar, GETDATE(), 120) + ') | ' + pm.Notas, 1, 256)
					END,

			-- set DataReset to default to
			pm.DataReset = NULL,

			-- thats a new row version
			pm.Versao = GETDATE()


		/*  Join to Suppliers table is not necessary at the moment, but could make sense in future to retreive defaults from
			Supplier data
		*/
		FROM [dbo].[ProdutosMatching] pm
			 INNER JOIN [dbo].[Fornecedores] f
				   ON pm.FornecedorCodigo = f.Codigo

		-- filter all rules with a DataReset settled with a date <= today...
		WHERE pm.DataReset IS NOT NULL
			  AND pm.DataReset <= GETDATE()




		-- fill output @info with sucess message
		SET @Info = '[Step3a1_Preparation_ProductMatchingsReset-01] Number of ProductMatching rules reseted to default: ' + CAST(@@ROWCOUNT as nvarchar);

		-- send true to output
		RETURN 1;

	END TRY

	BEGIN CATCH
		-- fill output @info with occurred error message
		SET @Info = '[Step3a1_Preparation_ProductMatchingsReset-02] ' + CAST(ERROR_NUMBER() as nvarchar) + ' - ' + ERROR_MESSAGE();

		-- send false to output
		RETURN 0;

	END CATCH

RETURN;
GO
PRINT N'Creating [dbo].[Step3a2_Preparation_QuotationRulesReset]...';


GO
/*
	This SP, resets all Quotation Rules (CotacoesRegras table) to it's defaults when date on DataReset field is reached.
*/


CREATE PROCEDURE [dbo].[Step3a2_Preparation_QuotationRulesReset]
	@Info nvarchar(256) OUTPUT
AS

	BEGIN TRY

		/*
			Reset to default Quotation Rules with DataReset date <= GETDATE()
		*/
		
		UPDATE cr

			-- restablish defaults
		SET cr.HorasValidade = f.HorasValidadeSugestao,
			cr.StockCodigoSubstituto = NULL,
			
			-- if there are some notes already settled on row do not remove them (append text at begining)
			cr.Notas =
					CASE WHEN cr.Notas IS NULL THEN '!reset (' + CONVERT(varchar, GETDATE(), 120) + ')'
					     ELSE SUBSTRING('!reset (' + CONVERT(varchar, GETDATE(), 120) + ') | ' + cr.Notas, 1, 256)
					END,
		
			-- set DataReset to default to
			cr.DataReset = NULL,

			-- thats a new row version
			cr.Versao = GETDATE()


		FROM [dbo].[CotacoesRegras] cr
			 INNER JOIN [dbo].[Fornecedores] f
				   ON cr.FornecedorCodigo = f.Codigo

		-- filter all rules with a DataReset settled with a date <= today...
		WHERE cr.DataReset IS NOT NULL
			  AND cr.DataReset <= GETDATE()





		-- fill output @info with sucess message
		SET @Info = '[Step3a2_Preparation_QuotationRulesReset-01] Number of Quotation Rules reseted to default: ' + CAST(@@ROWCOUNT as nvarchar);

		-- send true to output
		RETURN 1;

	END TRY

	BEGIN CATCH
		-- fill output @info with occurred error message
		SET @Info = '[Step3a2_Preparation_QuotationRulesReset-02] ' + CAST(ERROR_NUMBER() as nvarchar) + ' - ' + ERROR_MESSAGE();

		-- send false to output
		RETURN 0;

	END CATCH

RETURN;
GO
PRINT N'Creating [dbo].[Step3b1_Promotion_PromoteQuotations]...';


GO
/*
	This SP, disable old Actual Quotations and Promote just completed quotations to Actual Quotations
	This procedure is executed inside a transaction to ensure data integrity.
*/


CREATE PROCEDURE [dbo].[Step3b1_Promotion_PromoteQuotations]
	@Info nvarchar(256) OUTPUT
AS

	-- begin transacion
	BEGIN TRANSACTION


		BEGIN TRY

			/*
				disable all Actual Quotations that have a newly not integrated quotation (CotacoesNaoIntegradas)
			*/

			WITH CotacoesAtuaisDespromover AS
			(
				/*	Intersect all existing Atual Quotations with Not Integrated Quotations.
					The resulting set of this query represents all quotations that must be disabled, because
					there are newly quotations to take their places
				*/
				SELECT FornecedorCodigo, ProdutoCodigo FROM CotacoesAtuaisView
				INTERSECT
				SELECT FornecedorCodigo, ProdutoCodigo FROM CotacoesNaoIntegradasView
			)

			UPDATE c
			SET c.Inativo = CAST('true' as bit),
				c.Versao = GETDATE()
			FROM [dbo].[CotacoesAtuaisView] c
				 INNER JOIN CotacoesAtuaisDespromover cd
					   ON c.FornecedorCodigo = cd.FornecedorCodigo
					      AND c.ProdutoCodigo = cd.ProdutoCodigo


			-- fill output @info with sucess message
			SET @Info = '[Step3b1_Promotion_PromoteQuotations-01] Disabled Quotations: ' + CAST(@@ROWCOUNT as nvarchar);
			
			
			/*
				set all Not Integrated Quotations (CotacoesNaoIntegradasView) to integrated status.
				
				(at this moment, we have total sure that we can promote all Not Integrated Quotations (CotacoesNaoIntegradasView)
				ensuring that will exist one Actual Quotation for each FornecedorCodigo / ProdutoCodigo)
			*/

			UPDATE c
			SET c.Integrado = CAST('true' as bit),
				c.Versao = GETDATE()
			FROM [dbo].[CotacoesNaoIntegradasView] c


			-- fill output @info with sucess message
			SET @Info += '; Promoted Quotations: ' + CAST(@@ROWCOUNT as nvarchar);


			-- commit transaction
			COMMIT TRANSACTION;

			-- send true to output
			RETURN 1;

		END TRY

		BEGIN CATCH
			-- fill output @info with occurred error message
			SET @Info = '[Step3b1_Promotion_PromoteQuotations-02] ' + CAST(ERROR_NUMBER() as nvarchar) + ' - ' + ERROR_MESSAGE();

			-- rollback transaction;
			ROLLBACK TRANSACTION;

			-- send false to output
			RETURN 0;

		END CATCH

RETURN;
GO
PRINT N'Creating [dbo].[Step4a1_Preparation_Notifications]...';


GO
/*
	Register on CotacoesAvisos, all change that will be sended to database, based on changed rules defined in ProdutosMatching and CotacoesRegras
*/


CREATE PROCEDURE [dbo].[Step4a1_Preparation_Notifications]
	@Info nvarchar(256) OUTPUT
AS

	-- variables
	DECLARE @numberOfAffectedRows integer = 0;


	BEGIN TRY

		/*
			Insert notifications (CotacoesAvisos) of quotations changed values due to changes in rules ProdutosMatching and CotacoesRegras
		*/
				-- cost price update notifications
		INSERT INTO [dbo].[CotacoesAvisos] 
				    (Id, FornecedorCodigo, Data, _ProdutoCodigo, _ComplementoCodigo, AvisoTipoCodigo, Descricao, Criacao)

		SELECT NEWID() AS Id, 
			   c.FornecedorCodigo,
			   c.Data,
			   c._ProdutoCodigo,
			   c._ComplementoCodigo,
			   'CAC01' AS AvisoTipoCodigo,
			   'esta informação pode resultar de uma alteração recente de regras (ProdutosMatching ou CotacoesRegras)!' AS Descricao,
			   GETDATE() AS Criacao

		-- consider all quotations on CotacoesAtuaisRecalcularView, because all of them have changes to report
		FROM [dbo].CotacoesAtuaisRecalcularView c
		WHERE c.PrecoCusto <> c.PrecoCustoCalculado;

		-- sum to @numberOfAffectedRows
		SET @numberOfAffectedRows += @@ROWCOUNT;




		-- cost price formula update notifications
		INSERT INTO [dbo].[CotacoesAvisos] 
				    (Id, FornecedorCodigo, Data, _ProdutoCodigo, _ComplementoCodigo, AvisoTipoCodigo, Descricao, Criacao)

		SELECT NEWID() AS Id, 
			   c.FornecedorCodigo,
			   c.Data,
			   c._ProdutoCodigo,
			   c._ComplementoCodigo,
			   'CAC02' AS AvisoTipoCodigo,
			   'esta informação pode resultar de uma alteração recente da formula correspondente!' AS Descricao,
			   GETDATE() AS Criacao

		-- consider all quotations on CotacoesAtuaisRecalcularView, because all of them have changes to report
		FROM [dbo].CotacoesAtuaisRecalcularView c
		WHERE c.PrecoCustoFormula <> c.FormulaPrecoCustoCalculado;

		-- sum to @numberOfAffectedRows
		SET @numberOfAffectedRows += @@ROWCOUNT;



		-- expiration date update notifications
		INSERT INTO [dbo].[CotacoesAvisos] 
				    (Id, FornecedorCodigo, Data, _ProdutoCodigo, _ComplementoCodigo, AvisoTipoCodigo, Descricao, Criacao)

		SELECT NEWID() AS Id, 
			   c.FornecedorCodigo,
			   c.Data,
			   c._ProdutoCodigo,
			   c._ComplementoCodigo,
			   'CAC03' AS AvisoTipoCodigo,
			   'esta informação pode resultar de uma alteração recente de regras (ProdutosMatching ou CotacoesRegras)!' AS Descricao,
			   GETDATE() AS Criacao

		-- consider all quotations on CotacoesAtuaisRecalcularView, because all of them have changes to report
		FROM [dbo].CotacoesAtuaisRecalcularView c
		WHERE c.Validade <> c.ValidadeCalculada;

		-- sum to @numberOfAffectedRows
		SET @numberOfAffectedRows += @@ROWCOUNT;




		-- expiration date formula update notifications
		INSERT INTO [dbo].[CotacoesAvisos] 
				    (Id, FornecedorCodigo, Data, _ProdutoCodigo, _ComplementoCodigo, AvisoTipoCodigo, Descricao, Criacao)

		SELECT NEWID() AS Id, 
			   c.FornecedorCodigo,
			   c.Data,
			   c._ProdutoCodigo,
			   c._ComplementoCodigo,
			   'CAC04' AS AvisoTipoCodigo,
			   'esta informação pode resultar de uma alteração recente da formula correspondente!' AS Descricao,
			   GETDATE() AS Criacao

		-- consider all quotations on CotacoesAtuaisRecalcularView, because all of them have changes to report
		FROM [dbo].CotacoesAtuaisRecalcularView c
		WHERE c.ValidadeFormula <> c.FormulaValidadeCalculada;

		-- sum to @numberOfAffectedRows
		SET @numberOfAffectedRows += @@ROWCOUNT;




		-- description update notifications
		INSERT INTO [dbo].[CotacoesAvisos] 
				    (Id, FornecedorCodigo, Data, _ProdutoCodigo, _ComplementoCodigo, AvisoTipoCodigo, Descricao, Criacao)

		SELECT NEWID() AS Id, 
			   c.FornecedorCodigo,
			   c.Data,
			   c._ProdutoCodigo,
			   c._ComplementoCodigo,
			   'CAC05' AS AvisoTipoCodigo,
			   'esta informação pode resultar de uma alteração recente da formula de normalização!' AS Descricao,
			   GETDATE() AS Criacao

		-- consider all quotations on CotacoesAtuaisRecalcularView, because all of them have changes to report
		FROM [dbo].CotacoesAtuaisRecalcularView c
		WHERE c.Descricao <> c.DescricaoUniformizada;

		-- sum to @numberOfAffectedRows
		SET @numberOfAffectedRows += @@ROWCOUNT;




		-- features update notifications
		INSERT INTO [dbo].[CotacoesAvisos] 
				    (Id, FornecedorCodigo, Data, _ProdutoCodigo, _ComplementoCodigo, AvisoTipoCodigo, Descricao, Criacao)

		SELECT NEWID() AS Id, 
			   c.FornecedorCodigo,
			   c.Data,
			   c._ProdutoCodigo,
			   c._ComplementoCodigo,
			   'CAC06' AS AvisoTipoCodigo,
			   'esta informação pode resultar de uma alteração recente da formula de normalização!' AS Descricao,
			   GETDATE() AS Criacao

		-- consider all quotations on CotacoesAtuaisRecalcularView, because all of them have changes to report
		FROM [dbo].CotacoesAtuaisRecalcularView c
		WHERE c.Caracteristicas <> c.CaracteristicasUniformizadas;

		-- sum to @numberOfAffectedRows
		SET @numberOfAffectedRows += @@ROWCOUNT;



				
		-- link update notifications
		INSERT INTO [dbo].[CotacoesAvisos] 
				    (Id, FornecedorCodigo, Data, _ProdutoCodigo, _ComplementoCodigo, AvisoTipoCodigo, Descricao, Criacao)

		SELECT NEWID() AS Id, 
			   c.FornecedorCodigo,
			   c.Data,
			   c._ProdutoCodigo,
			   c._ComplementoCodigo,
			   'CAC07' AS AvisoTipoCodigo,
			   'esta informação pode resultar de uma alteração recente da formula de normalização!' AS Descricao,
			   GETDATE() AS Criacao

		-- consider all quotations on CotacoesAtuaisRecalcularView, because all of them have changes to report
		FROM [dbo].CotacoesAtuaisRecalcularView c
		WHERE c.Link <> c.LinkUniformizado;

		-- sum to @numberOfAffectedRows
		SET @numberOfAffectedRows += @@ROWCOUNT;




		-- image update notifications
		INSERT INTO [dbo].[CotacoesAvisos] 
				    (Id, FornecedorCodigo, Data, _ProdutoCodigo, _ComplementoCodigo, AvisoTipoCodigo, Descricao, Criacao)

		SELECT NEWID() AS Id, 
			   c.FornecedorCodigo,
			   c.Data,
			   c._ProdutoCodigo,
			   c._ComplementoCodigo,
			   'CAC08' AS AvisoTipoCodigo,
			   'esta informação pode resultar de uma alteração recente da formula de normalização!' AS Descricao,
			   GETDATE() AS Criacao

		-- consider all quotations on CotacoesAtuaisRecalcularView, because all of them have changes to report
		FROM [dbo].CotacoesAtuaisRecalcularView c
		WHERE c.Imagem <> c.ImagemUniformizada;

		-- sum to @numberOfAffectedRows
		SET @numberOfAffectedRows += @@ROWCOUNT;
		



		-- substitute stock update notifications
		INSERT INTO [dbo].[CotacoesAvisos] 
				    (Id, FornecedorCodigo, Data, _ProdutoCodigo, _ComplementoCodigo, AvisoTipoCodigo, Descricao, Criacao)

		SELECT NEWID() AS Id, 
			   c.FornecedorCodigo,
			   c.Data,
			   c._ProdutoCodigo,
			   c._ComplementoCodigo,
			   'CAC09' AS AvisoTipoCodigo,
			   'esta informação pode resultar de uma alteração recente de regras (ProdutosMatching ou CotacoesRegras)!' AS Descricao,
			   GETDATE() AS Criacao

		-- consider all quotations on CotacoesAtuaisRecalcularView, because all of them have changes to report
		FROM [dbo].CotacoesAtuaisRecalcularView c
		WHERE c.StockCodigoSubstituto <> c.StockCodigoSubstitutoCalculado;

		-- sum to @numberOfAffectedRows
		SET @numberOfAffectedRows += @@ROWCOUNT;
		



		-- substitute stock formula update notifications
		INSERT INTO [dbo].[CotacoesAvisos] 
				    (Id, FornecedorCodigo, Data, _ProdutoCodigo, _ComplementoCodigo, AvisoTipoCodigo, Descricao, Criacao)

		SELECT NEWID() AS Id, 
			   c.FornecedorCodigo,
			   c.Data,
			   c._ProdutoCodigo,
			   c._ComplementoCodigo,
			   'CAC10' AS AvisoTipoCodigo,
			   'esta informação pode resultar de uma alteração recente da formula correspondente!' AS Descricao,
			   GETDATE() AS Criacao

		-- consider all quotations on CotacoesAtuaisRecalcularView, because all of them have changes to report
		FROM [dbo].CotacoesAtuaisRecalcularView c
		WHERE c.StockCodigoSubstitutoJustificacao <> c.JustificacaoStockCodigoSubstitutoCalculado;

		-- sum to @numberOfAffectedRows
		SET @numberOfAffectedRows += @@ROWCOUNT;






		-- fill output @info with sucess message
		SET @Info = '[Step4a1_Preparation_Notifications-01] Number of inserted notifications: ' + CAST(@numberOfAffectedRows as nvarchar);

		-- send true to output
		RETURN 1;

	END TRY

	BEGIN CATCH
		-- fill output @info with occurred error message
		SET @Info = '[Step4a1_Preparation_Notifications-02] ' + CAST(ERROR_NUMBER() as nvarchar) + ' - ' + ERROR_MESSAGE();

		-- send false to output
		RETURN 0;

	END CATCH

RETURN;
GO
PRINT N'Creating [dbo].[Step4a2_Preparation_OtherFieldsRefresh]...';


GO
/*
	Update (refresh) Quotations information that must be changed due to ProdutosMatching or CotacoesRegras updated rules.
	This SP uses CotacoesAtuaisRecalcular to simplify the process.
*/


CREATE PROCEDURE [dbo].[Step4a2_Preparation_OtherFieldsRefresh]
	@Info nvarchar(256) OUTPUT
AS

	BEGIN TRY

		/*
			Refresh values of quotation fields, as needed
		*/
		
		UPDATE c
		
		SET c.PrecoCusto = c.PrecoCustoCalculado,
		    c.PrecoCustoFormula = c.FormulaPrecoCustoCalculado,
			c.Validade = c.ValidadeCalculada,
			c.ValidadeFormula = c.FormulaValidadeCalculada,
			c.Descricao = c.DescricaoUniformizada,
			c.Caracteristicas = c.CaracteristicasUniformizadas,
			c.Link = c.LinkUniformizado,
			c.Imagem = c.ImagemUniformizada,
			c.StockCodigoSubstituto = c.StockCodigoSubstitutoCalculado,
			c.StockCodigoSubstitutoJustificacao = c.JustificacaoStockCodigoSubstitutoCalculado,
			c.Versao = GETDATE()

		FROM [dbo].[CotacoesAtuaisRecalcularView] c




		-- fill output @info with sucess message
		SET @Info = '[Step4a2_Preparation_OtherFieldsRefresh-01] Number of Refreshed Quotations: ' + CAST(@@ROWCOUNT as nvarchar);

		-- send true to output
		RETURN 1;

	END TRY

	BEGIN CATCH
		-- fill output @info with occurred error message
		SET @Info = '[Step4a2_Preparation_OtherFieldsRefresh-02] ' + CAST(ERROR_NUMBER() as nvarchar) + ' - ' + ERROR_MESSAGE();

		-- send false to output
		RETURN 0;

	END CATCH

RETURN;
GO
PRINT N'Creating [dbo].[Step4a3_Preparation_SetInactiveExpiredQuotations]...';


GO
/*
	This SP set as inactive all expired quotations on Cotacoes table.
	It is executed only in this step, because Validade field could be updated till last instruction (OtherFieldsRefresh).
*/


CREATE PROCEDURE [dbo].[Step4a3_Preparation_SetInactiveExpiredQuotations]
	@Info nvarchar(256) OUTPUT
AS
	
	-- change expired quotations inactive field value
	BEGIN TRY

		-- set inactive all expired quotations
		UPDATE c
		SET c.Inativo = CAST('true' as bit),
		    c.Versao = GETDATE()
		FROM [dbo].[CotacoesAtuaisView] c
		WHERE Validade < GETDATE();


		-- fill output @info with sucess message
		SET @Info = '[Step4a3_Preparation_SetInactiveExpiredQuotations-01] Inativação de quotações expiradas realizada com sucesso';

		-- send true to output
		RETURN 1;

	END TRY

	BEGIN CATCH
		-- fill output @info with occurred error message
		SET @Info = '[Step4a3_Preparation_SetInactiveExpiredQuotations-02] ' + CAST(ERROR_NUMBER() as nvarchar) + ' - ' + ERROR_MESSAGE();

		-- send false to output
		RETURN 0;

	END CATCH

RETURN;
GO
PRINT N'Creating [dbo].[Step4a4_Finishing_ProductDescontinuation]...';


GO
/*
	This SP, set as descontinued all products that don't have any Actual Quotation (CotacoesAtuais).
	If a product doesn't have any Actual Quotation, that means that it is not possible to sell it any more.
*/


CREATE PROCEDURE [dbo].[Step4a4_Finishing_ProductDescontinuation]
	@Info nvarchar(256) OUTPUT
AS

	BEGIN TRY

		/*
			Set descontinued all products without Actual Quotations.
		*/
		UPDATE p
		SET p.Descontinuado = CAST('true' as bit),
			p.Versao = GETDATE()

		FROM [dbo].[ProdutosAtuaisView] p

		-- it is not necessary to filter only inativo='false' and descontinuado='false' because ProdutosAtuaisView already filter it
		WHERE p.Codigo NOT IN 
							  (
									SELECT DISTINCT ProdutoCodigo FROM [dbo].[CotacoesAtuaisView]
							  )



		-- fill output @info with sucess message
		SET @Info = '[Step4a4_Finishing_ProductDescontinuation-01] Number of Descontinued Products: ' + CAST(@@ROWCOUNT as nvarchar);

		-- send true to output
		RETURN 1;

	END TRY

	BEGIN CATCH
		-- fill output @info with occurred error message
		SET @Info = '[Step4a4_Finishing_ProductDescontinuation-02] ' + CAST(ERROR_NUMBER() as nvarchar) + ' - ' + ERROR_MESSAGE();

		-- send false to output
		RETURN 0;

	END CATCH

RETURN;
GO
PRINT N'Creating [dbo].[Step4a5_Finishing_ProductResurrection]...';


GO
/*
	This SP, set as not descontinued all descontinued products that back to have Actual Quotations (CotacoesAtuais).
	If a product no longer have quotations (CotacoesAtuais), that means that the product is been descontinued. Hoever, if it
	comes back having quotations later, the product must be ressurected...
*/


CREATE PROCEDURE [dbo].[Step4a5_Finishing_ProductResurrection]
	@Info nvarchar(256) OUTPUT
AS

	BEGIN TRY

		/*
			Set as ressurected (not descontinued) all descontinued products that have Actual Quotations (again).
		*/

		UPDATE p
		SET p.Descontinuado = CAST('false' as bit),
			p.Versao = GETDATE()

		FROM [dbo].[Produtos] p
		WHERE p.Inativo = CAST('false' as bit)
			  AND p.Descontinuado = CAST('true' as bit)
			  AND p.Codigo IN 
						  (
							   SELECT DISTINCT ProdutoCodigo FROM [dbo].[CotacoesAtuaisView]
						  )


		-- fill output @info with sucess message
		SET @Info = '[Step4a5_Finishing_ProductResurrection-01] Number of Resurrected Products: ' + CAST(@@ROWCOUNT as nvarchar);

		-- send true to output
		RETURN 1;

	END TRY

	BEGIN CATCH
		-- fill output @info with occurred error message
		SET @Info = '[Step4a5_Finishing_ProductResurrection-02] ' + CAST(ERROR_NUMBER() as nvarchar) + ' - ' + ERROR_MESSAGE();

		-- send false to output
		RETURN 0;

	END CATCH

RETURN;
GO
PRINT N'Creating [dbo].[Step4b1_Cautions_FakeStock_Notifications]...';


GO
/*
	This SP makes sure that user is notified via CotacoesAvisos table, that some actual quotations were updated with
	new StockCodigoSubsituto due to date evolution and configuration of percentil codes on Stocks table.
*/

CREATE PROCEDURE [dbo].[Step4b1_Cautions_FakeStock_Notifications]
	@Info nvarchar(256) OUTPUT
AS
	
	-- insert notifications on CotacoesAvisos table
	BEGIN TRY

		/*
			Insert notifications rows for all quotations that can have a fake stock classification
		*/
		INSERT INTO [dbo].[CotacoesAvisos] 
				    (Id, FornecedorCodigo, Data, _ProdutoCodigo, _ComplementoCodigo, AvisoTipoCodigo, Descricao, Criacao)

		SELECT NEWID(), 
			   c.FornecedorCodigo,
			   c.Data,
			   c._ProdutoCodigo,
			   c._ComplementoCodigo,
			   'PFS' AS AvisoTipoCodigo,
			   CASE WHEN (GETDATE() >= c.P90) AND (c.ValidadeP90_StockCodigo IS NOT NULL) THEN 
								'!Prevenção[FalsoStock] (' + CONVERT(varchar, GETDATE(), 103) + ') P90 atingido! '
					
					WHEN (GETDATE() >= c.P80) AND (c.ValidadeP80_StockCodigo IS NOT NULL) THEN
								'!Prevenção[FalsoStock] (' + CONVERT(varchar, GETDATE(), 103) + ') P80 atingido! '
					
					WHEN (GETDATE() >= c.P70) AND (c.ValidadeP70_StockCodigo IS NOT NULL) THEN
								'!Prevenção[FalsoStock] (' + CONVERT(varchar, GETDATE(), 103) + ') P70 atingido! '

					WHEN (GETDATE() >= c.P60) AND (c.ValidadeP60_StockCodigo IS NOT NULL) THEN
								'!Prevenção[FalsoStock] (' + CONVERT(varchar, GETDATE(), 103) + ') P60 atingido! '

					WHEN (GETDATE() >= c.P50) AND (c.ValidadeP50_StockCodigo IS NOT NULL) THEN
								'!Prevenção[FalsoStock] (' + CONVERT(varchar, GETDATE(), 103) + ') P50 atingido! '

					ELSE c.StockCodigoSubstitutoJustificacao
			   END,

			   GETDATE() AS Criacao

		-- consider only quotations filtered to FakeStock prevention
		FROM [dbo].[CotacoesAtuaisFalsoStockView] c



		-- fill output @info with sucess message
		SET @Info = '[Step4b1_Cautions_FakeStock_Notifications-01] Number of inserted notifications: ' + CAST(@@ROWCOUNT as nvarchar);

		-- send true to output
		RETURN 1;

	END TRY

	BEGIN CATCH
		-- fill output @info with occurred error message
		SET @Info = '[Step4b1_Cautions_FakeStock_Notifications-02] ' + CAST(ERROR_NUMBER() as nvarchar) + ' - ' + ERROR_MESSAGE();

		-- send false to output
		RETURN 0;

	END CATCH

RETURN;
GO
PRINT N'Creating [dbo].[Step4b2_Cautions_FakeStock_Execution]...';


GO
/*
	This stored procedure entends to lower stock availability on all quotations that have more than 2/3 of it's valid life.
	Every Actual Quotations that have more than 2/3 of its life (to expire), must be reconfigured with a more secure availability stock code.
*/


CREATE PROCEDURE [dbo].[Step4b2_Cautions_FakeStock_Execution]
	@Info nvarchar(256) OUTPUT
AS

	BEGIN TRY

		/*
			Update quotations with a new Stock Code to prevent a fack stock promotion.
		*/
		UPDATE c

		SET StockCodigoSubstitutoJustificacao =
				CASE WHEN (GETDATE() >= c.P90) AND (c.ValidadeP90_StockCodigo IS NOT NULL) THEN 
								SUBSTRING('!Prevenção[FalsoStock] (' + CONVERT(varchar, GETDATE(), 103) + ') P90 atingido! ' + COALESCE(c.StockCodigoSubstitutoJustificacao, ''), 1, 256)

					 WHEN (GETDATE() >= c.P80) AND (c.ValidadeP80_StockCodigo IS NOT NULL) THEN
								SUBSTRING('!Prevenção[FalsoStock] (' + CONVERT(varchar, GETDATE(), 103) + ') P80 atingido! ' + COALESCE(c.StockCodigoSubstitutoJustificacao, ''), 1, 256)

					 WHEN (GETDATE() >= c.P70) AND (c.ValidadeP70_StockCodigo IS NOT NULL) THEN
								SUBSTRING('!Prevenção[FalsoStock] (' + CONVERT(varchar, GETDATE(), 103) + ') P70 atingido! ' + COALESCE(c.StockCodigoSubstitutoJustificacao, ''), 1, 256)

					 WHEN (GETDATE() >= c.P60) AND (c.ValidadeP60_StockCodigo IS NOT NULL) THEN
								SUBSTRING('!Prevenção[FalsoStock] (' + CONVERT(varchar, GETDATE(), 103) + ') P60 atingido! ' + COALESCE(c.StockCodigoSubstitutoJustificacao, ''), 1, 256)

					 WHEN (GETDATE() >= c.P50) AND (c.ValidadeP50_StockCodigo IS NOT NULL) THEN
								SUBSTRING('!Prevenção[FalsoStock] (' + CONVERT(varchar, GETDATE(), 103) + ') P50 atingido! ' + COALESCE(c.StockCodigoSubstitutoJustificacao, ''), 1, 256)

					 ELSE c.StockCodigoSubstitutoJustificacao
				END,
			
			StockCodigoSubstituto =
				CASE WHEN (GETDATE() >= c.P90) AND (c.ValidadeP90_StockCodigo IS NOT NULL) THEN 
								c.ValidadeP90_StockCodigo

					 WHEN (GETDATE() >= c.P80) AND (c.ValidadeP80_StockCodigo IS NOT NULL) THEN 
								c.ValidadeP80_StockCodigo

					 WHEN (GETDATE() >= c.P70) AND (c.ValidadeP70_StockCodigo IS NOT NULL) THEN 
								c.ValidadeP70_StockCodigo

					 WHEN (GETDATE() >= c.P60) AND (c.ValidadeP60_StockCodigo IS NOT NULL) THEN 
								c.ValidadeP60_StockCodigo

					 WHEN (GETDATE() >= c.P50) AND (c.ValidadeP50_StockCodigo IS NOT NULL) THEN 
								c.ValidadeP50_StockCodigo

					 ELSE c.StockCodigoSubstituto
				END,
			
			c.Versao = GETDATE()

		FROM [dbo].[CotacoesAtuaisFalsoStockView] c




		-- fill output @info with sucess message
		SET @Info = '[Step4b2_Cautions_FakeStock_Execution-01] Number of executed FakeStock preventions: ' + CAST(@@ROWCOUNT as nvarchar);

		-- send true to output
		RETURN 1;

	END TRY

	BEGIN CATCH
		-- fill output @info with occurred error message
		SET @Info = '[Step4b2_Cautions_FakeStock_Execution-02] ' + CAST(ERROR_NUMBER() as nvarchar) + ' - ' + ERROR_MESSAGE();

		-- send false to output
		RETURN 0;

	END CATCH

RETURN;
GO
PRINT N'Creating [dbo].[Step4b3_Cautions_OutOfInterval_Notifications]...';


GO
/*
	This SP makes sure that user is notified via CotacoesAvisos table, that some actual quotations were disabled becouse the
	it's price is out of the interval specified on Category interval allowed
*/

CREATE PROCEDURE [dbo].[Step4b3_Cautions_OutOfInterval_Notifications]
	@Info nvarchar(256) OUTPUT
AS
	
	-- insert notifications on CotacoesAvisos table
	BEGIN TRY

		/*
			Insert notifications rows for all disabled quotations
		*/
		INSERT INTO [dbo].[CotacoesAvisos] 
				    (Id, FornecedorCodigo, Data, _ProdutoCodigo, _ComplementoCodigo, AvisoTipoCodigo, Descricao, Criacao)

		SELECT NEWID(), 
			   c.FornecedorCodigo,
			   c.Data,
			   c._ProdutoCodigo,
			   c._ComplementoCodigo,
			   'IAPD1' AS AvisoTipoCodigo,
			   '!Prevenção[Preço Desfasado] (' + CONVERT(varchar, GETDATE(), 103) + ') Preço fora do intervalo ' +
			   '[' + CONVERT(varchar, c.PrecoMinimoPermitido) + ',' +
			   CONVERT(varchar, c.PrecoMaximoPermitido) + ']',
			   GETDATE() AS Criacao

		-- consider only quotations filtered to Out of Interval prevention
		FROM [dbo].[CotacoesAtuaisPrecosForaIntervaloView] c



		-- fill output @info with sucess message
		SET @Info = '[Step4b3_Cautions_OutOfInterval_Notifications-01] Number of inserted notifications: ' + CAST(@@ROWCOUNT as nvarchar);

		-- send true to output
		RETURN 1;

	END TRY

	BEGIN CATCH
		-- fill output @info with occurred error message
		SET @Info = '[Step4b3_Cautions_OutOfInterval_Notifications-02] ' + CAST(ERROR_NUMBER() as nvarchar) + ' - ' + ERROR_MESSAGE();

		-- send false to output
		RETURN 0;

	END CATCH

RETURN;
GO
PRINT N'Creating [dbo].[Step4b4_Cautions_OutOfInterval_Execution]...';


GO
/*
	This stored procedure entends to inactivate Actual Quotations that has it's price out of the interval defined on correspondent category.
*/


CREATE PROCEDURE [dbo].[Step4b4_Cautions_OutOfInterval_Execution]
	@Info nvarchar(256) OUTPUT
AS

	BEGIN TRY

		/*
			Inactivate Actual Quotations that has a irregular price (Out Of Interval)
		*/
		UPDATE c
		
		SET c.Inativo = CAST('true' as bit),
			c.Versao = GETDATE()

		FROM [dbo].[CotacoesAtuaisPrecosForaIntervaloView] c



		-- fill output @info with sucess message
		SET @Info = '[Step4b2_Cautions_FakeStock_Execution-01] Number of executed Out Of Interval preventions: ' + CAST(@@ROWCOUNT as nvarchar);

		-- send true to output
		RETURN 1;

	END TRY

	BEGIN CATCH
		-- fill output @info with occurred error message
		SET @Info = '[Step4b4_Cautions_OutOfInterval_Execution-02] ' + CAST(ERROR_NUMBER() as nvarchar) + ' - ' + ERROR_MESSAGE();

		-- send false to output
		RETURN 0;

	END CATCH

RETURN;
GO
PRINT N'Creating [dbo].[Step4b5_Cautions_IrregularAmplitude_Notifications]...';


GO
/*
	This SP makes sure that user is notified via CotacoesAvisos table, that some actual quotations were disabled because the
	it's price is causing an irregular price amplitude (inside the same product)
*/

CREATE PROCEDURE [dbo].[Step4b5_Cautions_IrregularAmplitude_Notifications]
	@Info nvarchar(256) OUTPUT
AS
	
	-- insert notifications on CotacoesAvisos table
	BEGIN TRY

		/*
			Insert notifications rows for all disabled quotations
		*/
		INSERT INTO [dbo].[CotacoesAvisos] 
				    (Id, FornecedorCodigo, Data, _ProdutoCodigo, _ComplementoCodigo, AvisoTipoCodigo, Descricao, Criacao)

		SELECT NEWID(), 
			   c.FornecedorCodigo,
			   c.Data,
			   c._ProdutoCodigo,
			   c._ComplementoCodigo,
			   'IAPD2' AS AvisoTipoCodigo,
			   '!Prevenção[Preço Desfasado] (' + CONVERT(varchar, GETDATE(), 103) + ') Preço com amplitude irregular ' +
			   '[' + c.AmplitudeFormulaDetecaoDesfasamento + ']. ' +
			   'O preço desfasado é ' + CONVERT(varchar, c.PrecoDesfasado) + ' ' +
			   '[' + c.PrecoDesfasadoFormulaDecisao + '].',

			   GETDATE() AS Criacao

		-- consider only quotations filtered to Out of Interval prevention
		FROM [dbo].[CotacoesAtuaisAmplitudeIrregularView] c



		-- fill output @info with sucess message
		SET @Info = '[Step4b5_Cautions_IrregularAmplitude_Notifications-01] Number of inserted notifications: ' + CAST(@@ROWCOUNT as nvarchar);

		-- send true to output
		RETURN 1;

	END TRY

	BEGIN CATCH
		-- fill output @info with occurred error message
		SET @Info = '[Step4b5_Cautions_IrregularAmplitude_Notifications-02] ' + CAST(ERROR_NUMBER() as nvarchar) + ' - ' + ERROR_MESSAGE();

		-- send false to output
		RETURN 0;

	END CATCH

RETURN;
GO
PRINT N'Creating [dbo].[Step4b6_Cautions_IrregularAmplitude_Execution]...';


GO
/*
	This stored procedure entends to inactivate Actual Quotations with irregular amplitude quotations (most irregular price grouping by ProdutoCodigo).
*/


CREATE PROCEDURE [dbo].[Step4b6_Cautions_IrregularAmplitude_Execution]
	@Info nvarchar(256) OUTPUT
AS

	BEGIN TRY

		/*
			Inactivate Actual Quotations that has a irregular price (Out Of Interval)
		*/
		UPDATE c
		
		SET c.Inativo = CAST('true' as bit),
			c.Versao = GETDATE()

		FROM [dbo].[CotacoesAtuaisAmplitudeIrregularView] c



		-- fill output @info with sucess message
		SET @Info = '[Step4b6_Cautions_IrregularAmplitude_Execution-01] Number of executed Irregular Amplitude preventions: ' + CAST(@@ROWCOUNT as nvarchar);

		-- send true to output
		RETURN 1;

	END TRY

	BEGIN CATCH
		-- fill output @info with occurred error message
		SET @Info = '[Step4b6_Cautions_IrregularAmplitude_Execution-02] ' + CAST(ERROR_NUMBER() as nvarchar) + ' - ' + ERROR_MESSAGE();

		-- send false to output
		RETURN 0;

	END CATCH

RETURN;
GO
PRINT N'Creating [dbo].[Step4c1_Finishing_ProductsUpdate]...';


GO
/*
	This stored procedure will update Products table with recent processed information.
	This SP will use CotacoesVencedoras view to support product updating...
*/


CREATE PROCEDURE [dbo].[Step4c1_Finishing_ProductsUpdate]
	@Info nvarchar(256) OUTPUT
AS

	-- variables
	DECLARE @numberOfAffectedRows integer = 0;


	-- start a transaction scope
	BEGIN TRANSACTION


	BEGIN TRY

		/*
			Update Product information
		*/
		-- new day prices update (do update price history) (update prices if needed of products not updated today already)
		UPDATE p
		SET p.PrecoCusto_U3 = p.PrecoCusto_U2,
			p.PrecoCusto_U3Data = p.PrecoCusto_U2Data,
			p.PrecoCusto_U2 = p.PrecoCusto_U1,
			p.PrecoCusto_U2Data = p.PrecoCusto_U1Data,
			p.PrecoCusto_U1 = p.PrecoCusto,
			p.PrecoCusto_U1Data = p.PrecoCusto_Data,
			p.PrecoCusto = c.PrecoCusto,
			p.PrecoCusto_Data = CAST(GETDATE() AS DATE),
			p.Versao = GETDATE()

		FROM [dbo].[Produtos] p
			 INNER JOIN [dbo].[CotacoesVencedorasView] c
				   ON p.Codigo = c.ProdutoCodigo

		-- we want to update only different prices (product vs quotations) and last update date was not today...
		WHERE COALESCE(p.PrecoCusto, -999999999) <> c.PrecoCusto
			  AND COALESCE(p.PrecoCusto_Data, CAST('01-01-2000' as date)) <> CAST(GETDATE() AS DATE)


		-- sum to @numberOfAffectedRows
		SET @numberOfAffectedRows += @@ROWCOUNT;





		-- same day prices update (do NOT update price history)
		UPDATE p
		SET p.PrecoCusto = c.PrecoCusto,
			p.Versao = GETDATE()

		FROM [dbo].[Produtos] p
			 INNER JOIN [dbo].[CotacoesVencedorasView] c
				   ON p.Codigo = c.ProdutoCodigo

		-- we want to update only different prices (product vs quotations) and last update date was today...
		WHERE COALESCE(p.PrecoCusto, -999999999) <> c.PrecoCusto
			  AND COALESCE(p.PrecoCusto_Data, CAST('01-01-2000' as date)) = CAST(GETDATE() AS DATE)


		-- sum to @numberOfAffectedRows
		SET @numberOfAffectedRows += @@ROWCOUNT;





		-- new day stock update (do update stock history) (update stocks if needed of products not updated today already)
		UPDATE p
		SET p.StockCodigo_U3 = p.StockCodigo_U2,
			p.StockCodigo_U3Data = p.StockCodigo_U2Data,
			p.StockCodigo_U2 = p.StockCodigo_U1,
			p.StockCodigo_U2Data = p.StockCodigo_U1Data,
			p.StockCodigo_U1 = p.StockCodigo,
			p.StockCodigo_U1Data = p.StockCodigo_Data,
			p.StockCodigo = c.StockCodigoEfetivo,
			p.StockCodigo_Data = CAST(GETDATE() AS DATE),
			p.Versao = GETDATE()

		FROM [dbo].[Produtos] p
			 INNER JOIN [dbo].[CotacoesVencedorasView] c
				   ON p.Codigo = c.ProdutoCodigo

		-- we want to update only different stocks (product vs quotations) and last update date was not today...
		WHERE COALESCE(p.StockCodigo, '') <> c.StockCodigoEfetivo
			  AND COALESCE(p.StockCodigo_Data, CAST('01-01-2000' as date)) <> CAST(GETDATE() AS DATE)


		-- sum to @numberOfAffectedRows
		SET @numberOfAffectedRows += @@ROWCOUNT;





		-- same day stocks update (do NOT update stock history)
		UPDATE p
		SET p.StockCodigo = c.StockCodigoEfetivo,
			p.Versao = GETDATE()

		FROM [dbo].[Produtos] p
			 INNER JOIN [dbo].[CotacoesVencedorasView] c
				   ON p.Codigo = c.ProdutoCodigo

		-- we want to update only different stocks (product vs quotations) and last update date was today...
		WHERE COALESCE(p.StockCodigo, '') <> c.StockCodigoEfetivo
			  AND COALESCE(p.StockCodigo_Data, CAST('01-01-2000' as date)) = CAST(GETDATE() AS DATE)


		-- sum to @numberOfAffectedRows
		SET @numberOfAffectedRows += @@ROWCOUNT;





		-- update other fields of quotation
		UPDATE p
		SET p.Descricao = c.Descricao,
			p.Partnumber = c.Partnumber,
			p.FornecedorCodigo = c.FornecedorCodigo,
			p.Versao = GETDATE()

		FROM [dbo].[Produtos] p
			 INNER JOIN [dbo].[CotacoesVencedorasView] c
				   ON p.Codigo = c.ProdutoCodigo

		-- filter only records with info to be updated
		WHERE COALESCE(p.Descricao,'') <> c.Descricao
			  OR COALESCE(p.Partnumber, '') <> c.Partnumber
			  OR COALESCE(p.FornecedorCodigo, '') <> c.FornecedorCodigo


		-- sum to @numberOfAffectedRows
		SET @numberOfAffectedRows += @@ROWCOUNT;




		-- commit all changes
		COMMIT TRANSACTION

		-- fill output @info with sucess message
		SET @Info = '[Step4c1_Finishing_ProductsUpdate-01] Total of affected rows (one product could be updated by several instructions): ' + CAST(@numberOfAffectedRows as nvarchar);

		-- send true to output
		RETURN 1;

	END TRY

	BEGIN CATCH
		-- rollback transaction
		ROLLBACK TRANSACTION

		-- fill output @info with occurred error message
		SET @Info = '[Step4c1_Finishing_ProductsUpdate-02] ' + CAST(ERROR_NUMBER() as nvarchar) + ' - ' + ERROR_MESSAGE();

		-- send false to output
		RETURN 0;

	END CATCH

RETURN;
GO
PRINT N'Creating [dbo].[Step4c2_Finishing_ProductsDetailUpdate]...';


GO
/*
	This stored procedure will update Products Detail (ProdutosDetalhe) table with recent information.
*/


CREATE PROCEDURE [dbo].[Step4c2_Finishing_ProductsDetailUpdate]
	@Info nvarchar(256) OUTPUT
AS

	-- variables
	DECLARE @numberOfAffectedRows integer = 0;


	-- start a transaction scope
	BEGIN TRANSACTION


	BEGIN TRY

		/*
			Update Products Detail information
		*/
		

	
		-- set new content preocupation index (based on description and features from Quotations table - the new value...)
		UPDATE pd
		SET pd.IndicePreocupacaoConteudo = [dbo].[GetProdutoDetalheIndicePreocupacaoFunction](c.Descricao, c.Caracteristicas),
			pd.Versao = GETDATE()
		FROM [dbo].[ProdutosDetalhe] pd
			 INNER JOIN [dbo].[CotacoesAtuaisView] c
				   ON pd.FornecedorCodigo = c.FornecedorCodigo
					  AND pd.ProdutoCodigo = c.ProdutoCodigo
		-- process only rows that has changes on description or features...
		WHERE pd.AtualizacaoAutomaticaInativa = CAST('false' as bit)
			  AND (
					pd.Descricao <> c.Descricao
					OR pd.Caracteristicas <> c.Caracteristicas
				  )

		-- sum to @numberOfAffectedRows
		SET @numberOfAffectedRows += @@ROWCOUNT;





		-- description
		UPDATE pd
		SET pd.DescricaoPontuacao += 1,
			pd.Descricao = c.Descricao,
			pd.Versao = GETDATE()
		FROM [dbo].[ProdutosDetalhe] pd
			 INNER JOIN [dbo].[CotacoesAtuaisView] c
				   ON pd.FornecedorCodigo = c.FornecedorCodigo
					  AND pd.ProdutoCodigo = c.ProdutoCodigo
		-- process only rows that are settled to update automaticaly and need description update
		WHERE pd.AtualizacaoAutomaticaInativa = CAST('false' as bit)
			  AND pd.Descricao <> c.Descricao

		-- sum to @numberOfAffectedRows
		SET @numberOfAffectedRows += @@ROWCOUNT;





		-- features
		UPDATE pd
		SET pd.CaracteristicasPontuacao += 1,
			pd.Caracteristicas = c.Caracteristicas,
			pd.Versao = GETDATE()
		FROM [dbo].[ProdutosDetalhe] pd
			 INNER JOIN [dbo].[CotacoesAtuaisView] c
				   ON pd.FornecedorCodigo = c.FornecedorCodigo
					  AND pd.ProdutoCodigo = c.ProdutoCodigo
		-- process only rows that are settled to update automaticaly and need features update
		WHERE pd.AtualizacaoAutomaticaInativa = CAST('false' as bit)
			  AND pd.Caracteristicas <> c.Caracteristicas

		-- sum to @numberOfAffectedRows
		SET @numberOfAffectedRows += @@ROWCOUNT;




		-- link
		UPDATE pd
		SET pd.LinkPontuacao += 1,
			pd.Link = c.Link,
			pd.Versao = GETDATE()
		FROM [dbo].[ProdutosDetalhe] pd
			 INNER JOIN [dbo].[CotacoesAtuaisView] c
				   ON pd.FornecedorCodigo = c.FornecedorCodigo
					  AND pd.ProdutoCodigo = c.ProdutoCodigo
		-- process only rows that are settled to update automaticaly and need link update
		WHERE pd.AtualizacaoAutomaticaInativa = CAST('false' as bit)
			  AND pd.Link <> c.Link

		-- sum to @numberOfAffectedRows
		SET @numberOfAffectedRows += @@ROWCOUNT;




		-- image
		UPDATE pd
		SET pd.ImagemPontuacao += 1,
			pd.Imagem = c.Imagem,
			pd.Versao = GETDATE()
		FROM [dbo].[ProdutosDetalhe] pd
			 INNER JOIN [dbo].[CotacoesAtuaisView] c
				   ON pd.FornecedorCodigo = c.FornecedorCodigo
					  AND pd.ProdutoCodigo = c.ProdutoCodigo
		-- process only rows that are settled to update automaticaly and need image update
		WHERE pd.AtualizacaoAutomaticaInativa = CAST('false' as bit)
			  AND pd.Imagem <> c.Imagem

		-- sum to @numberOfAffectedRows
		SET @numberOfAffectedRows += @@ROWCOUNT;





		-- notify user manual update if needed
		UPDATE pd
		SET pd.AtualizacaoManualNecessaria = CAST('true' as bit),
			pd.Versao = GETDATE()
		FROM [dbo].[ProdutosDetalhe] pd
			 INNER JOIN [dbo].[CotacoesAtuaisView] c
				   ON pd.FornecedorCodigo = c.FornecedorCodigo
					  AND pd.ProdutoCodigo = c.ProdutoCodigo
		-- filter rows needing some update and configured to do not update automaticaly
		WHERE pd.AtualizacaoAutomaticaInativa = CAST('true' as bit)
			  AND (
					pd.Descricao <> c.Descricao
					OR pd.Caracteristicas <> c.Caracteristicas
					OR pd.Link <> c.Link
					OR pd.Imagem <> c.Imagem
				  )

		-- sum to @numberOfAffectedRows
		SET @numberOfAffectedRows += @@ROWCOUNT;



		-- commit all changes
		COMMIT TRANSACTION

		-- fill output @info with sucess message
		SET @Info = '[Step4c2_Finishing_ProductsDetailUpdate-01] Total of affected rows (one product detail could be updated by several instructions): ' + CAST(@numberOfAffectedRows as nvarchar);

		-- send true to output
		RETURN 1;

	END TRY

	BEGIN CATCH
		-- rollback transaction
		ROLLBACK TRANSACTION

		-- fill output @info with occurred error message
		SET @Info = '[Step4c2_Finishing_ProductsDetailUpdate-02] ' + CAST(ERROR_NUMBER() as nvarchar) + ' - ' + ERROR_MESSAGE();

		-- send false to output
		RETURN 0;

	END CATCH

RETURN;
GO
PRINT N'Creating [dbo].[Step4c3_Finishing_ProductsDetailInsert]...';


GO
/*
	This stored procedure will insert Products Detail (ProdutosDetalhe) table.
*/


CREATE PROCEDURE [dbo].[Step4c3_Finishing_ProductsDetailInsert]
	@Info nvarchar(256) OUTPUT
AS


	BEGIN TRY

		/*
			Insert Products Detail information
		*/
		INSERT [dbo].[ProdutosDetalhe]
			   (
				  -- pk
				   FornecedorCodigo,
				   ProdutoCodigo,
		   
				   -- description
				   Descricao,
				   DescricaoPontuacao,
				   DescricaoInativa,

				   -- features
				   Caracteristicas, 
				   CaracteristicasPontuacao,
				   CaracteristicasInativas,

				   -- link
				   Link,
				   LinkPontuacao,
				   LinkInativo,

				   -- imagem
				   Imagem,
				   ImagemPontuacao,
				   ImagemInativa,

				   -- others
				   AtualizacaoAutomaticaInativa,
				   AtualizacaoManualNecessaria,
				   IndicePreocupacaoConteudo,
				   Criacao,
				   Versao
				)


		SELECT 
			   -- pk
			   c.FornecedorCodigo,
			   c.ProdutoCodigo,

			   -- description
			   c.Descricao, 
			   f.DescricaoPontuacaoInicial,
			   f.DescricaoSugereInativo,

			   -- features
			   c.Caracteristicas,
			   f.CaracteristicasPontuacaoInicial,
			   f.CaracteristicasSugereInativo,

			   -- link
			   c.Link,
			   f.LinkPontuacaoInicial,
			   f.LinkSugereInativo,

			   -- image
			   c.Imagem,
			   f.ImagemPontuacaoInicial,
			   f.ImagemSugereInativo,

			   -- others
			   f.AtualizacaoAutomaticaInativaSugestao,
			   CAST('false' as bit),
			   [dbo].[GetProdutoDetalheIndicePreocupacaoFunction](c.Descricao, c.Caracteristicas),
			   GETDATE(),
			   GETDATE()

		FROM [dbo].[CotacoesAtuaisView] c
			 INNER JOIN (

							-- set of Actual Quotations not in ProdutosDetalhe
							SELECT DISTINCT FornecedorCodigo, ProdutoCodigo
							FROM [dbo].[CotacoesAtuaisView]
					
							EXCEPT
					
							SELECT FornecedorCodigo, ProdutoCodigo
							FROM [dbo].[ProdutosDetalhe]

						) nd
							ON c.FornecedorCodigo = nd.FornecedorCodigo
							   AND c.ProdutoCodigo = nd.ProdutoCodigo
			 INNER JOIN [dbo].[Fornecedores] f
				   ON c.FornecedorCodigo = f.Codigo




		-- fill output @info with sucess message
		SET @Info = '[Step4c3_Finishing_ProductsDetailInsert-01] Total of inserted Product Details: ' + CAST(@@ROWCOUNT as nvarchar);

		-- send true to output
		RETURN 1;

	END TRY

	BEGIN CATCH

		-- fill output @info with occurred error message
		SET @Info = '[Step4c3_Finishing_ProductsDetailInsert-02] ' + CAST(ERROR_NUMBER() as nvarchar) + ' - ' + ERROR_MESSAGE();

		-- send false to output
		RETURN 0;

	END CATCH

RETURN;
GO
PRINT N'Creating [dbo].[SupplementCount]...';


GO
CREATE PROCEDURE [dbo].[SupplementCount]
	@param1 int = 0,
	@param2 int
AS
	SELECT @param1, @param2
RETURN 0
GO
PRINT N'Creating [dbo].[SupplementDelete]...';


GO
CREATE PROCEDURE [dbo].[SupplementDelete]
	@param1 int = 0,
	@param2 int
AS
	SELECT @param1, @param2
RETURN 0
GO
PRINT N'Creating [dbo].[SupplementInsert]...';


GO
CREATE PROCEDURE [SupplementInsert]
	@param1 int = 0,
	@param2 int
AS
	SELECT @param1, @param2
RETURN 0
GO
PRINT N'Creating [dbo].[SupplementSelect]...';


GO
CREATE PROCEDURE [dbo].[SupplementSelect]
	@param1 int = 0,
	@param2 int
AS
	SELECT @param1, @param2
RETURN 0
GO
PRINT N'Creating [dbo].[SupplementUpdate]...';


GO
CREATE PROCEDURE [dbo].[SupplementUpdate]
	@param1 int = 0,
	@param2 int
AS
	SELECT @param1, @param2
RETURN 0
GO
PRINT N'Creating [dbo].[SupplierCount]...';


GO
CREATE PROCEDURE [dbo].[SupplierCount]
	@WhereClause nvarchar(512) = ''			-- ex1: Codigo IN ('001', '002'); ex2: Descricao LIKE '_este'; ex3: Descricao LIKE '%est%'
AS

	DECLARE @select nvarchar(1024), @where nvarchar(512), @sqlQuery nvarchar(2048)

	SET @select = 'SELECT Count([Codigo]) FROM [dbo].[Fornecedores]' 

	SET @where = LTRIM(RTRIM(@WhereClause))
	IF Len(@where) > 0
	BEGIN
		SET @where = ' WHERE ' + @where
	END


	SET @sqlQuery = @select + @where


	EXEC(@sqlQuery)

RETURN  -- This SP must be used with ExecuteScalar
GO
PRINT N'Creating [dbo].[SupplierDelete]...';


GO
CREATE PROCEDURE [dbo].[SupplierDelete]
	@Codigo nvarchar(5),
	@Versao datetime
AS
	DECLARE @Erro nvarchar(255)


	-- VALIDAR SE O CODIGO EXISTE
	IF NOT EXISTS(SELECT [Codigo] FROM [dbo].[Fornecedores] WHERE [Codigo] = @Codigo)
	BEGIN
		-- DISPARAR UM ERRO
		SET @Erro = '[WhereToBuy-D01] ' + 'O registo que pretende eliminar não existe!';
		RAISERROR (@Erro, 15, 1)
		RETURN 0
	END

	-- VALIDAR SE A VERSÃO AINDA É A MESMA
	IF NOT EXISTS(SELECT [Codigo] FROM [dbo].[Fornecedores] WHERE [Codigo] = @Codigo AND [Versao] = @Versao)
	BEGIN
		-- DISPARAR UM ERRO
		SET @Erro = '[WhereToBuy-D02] ' + 'O registo que pretende eliminar, já foi alterado desde que o abriu!';
		RAISERROR (@Erro, 15, 1)
		RETURN 0
	END


	-- TUDO OK PARA SEGUIR EM FRENTE
	DECLARE @NumeroLinhasAfetadas int


	-- ELIMINAR O REGISTO
	BEGIN TRY

		-- INICIA CONTAGEM DE @@ROWCOUNT (para quando usado o ExecuteNonQuery())
		SET NOCOUNT OFF
		 
		-- ELIMINAR REGISTO
		DELETE FROM [dbo].[Fornecedores] Where [Codigo] = @Codigo

		SET @NumeroLinhasAfetadas = @@ROWCOUNT -- GUARDAR O NUMERO DE LINHAS AFETADAS

		-- ACABA CONTAGEM DE @@ROWCOUNT
		SET NOCOUNT ON

		-- RETORNAR O NUMERO DE LINHAS AFETADAS
		-- Quando usado o ExecuteNonQuery é o @@ROWCOUNT que é lido (SET NOCOUNT OFF/ON), e não esta variável
		RETURN @NumeroLinhasAfetadas

	END TRY


	-- SE EXISTIRAM ERROS
	BEGIN CATCH
		
		-- DISPARAR UM ERRO
		SET @Erro = '[WhereToBuy-D10] ' + ERROR_MESSAGE();
		RAISERROR (@Erro, 15, 1)
		RETURN 0

	END CATCH
GO
PRINT N'Creating [dbo].[SupplierInsert]...';


GO
CREATE PROCEDURE [dbo].[SupplierInsert]
	@Codigo nvarchar(5), 
	@Nome nvarchar(50), 
	@Morada nvarchar(200), 
	@CodigoPostal nvarchar(15),
	@LocalidadePostal nvarchar(50), 
	@Contribuinte nvarchar(20), 
	@Vendedor nvarchar(50), 
	@Telefone nvarchar(20), 
	@Telemovel nvarchar(15), 
	@SMS nvarchar(15), 
	@Email nvarchar(100), 
	@AcessoOnlineAtivo bit, 
	@Username nvarchar(20), 
	@Password nvarchar(20), 
	@HorasValidadeSugestao smallint, 
	@ProdutosMatchingAutomatico bit, 
	@ProdutosCriacaoAutomatica bit, 
	@DisponibilizaInfoProdutoDetalhe bit, 
	@DescricaoPontuacaoInicial smallint, 
	@CaracteristicasPontuacaoInicial smallint, 
	@LinkPontuacaoInicial smallint, 
	@ImagemPontuacaoInicial smallint, 
	@DescricaoSugereInativo bit, 
	@CaracteristicasSugereInativo bit, 
	@LinkSugereInativo bit, 
	@ImagemSugereInativo bit, 
	@AtualizacaoAutomaticaInativaSugestao bit, 
	@ProdutosConfiancaPreco float, 
	@ProdutosConfiancaDisponibilidade float, 
	@Inativo bit 

AS
	
	DECLARE @Criacao smalldatetime, @Versao datetime, @NumeroLinhasAfetadas int, @Erro nvarchar(255)

	SET @Criacao = GETDATE()
	SET @Versao = GETDATE()


	-- INSERÇÃO DO REGISTO
	BEGIN TRY
		 
		-- INICIA CONTAGEM DE @@ROWCOUNT (para quando usado o ExecuteNonQuery())
		SET NOCOUNT OFF

		-- INSERIR REGISTO
		INSERT INTO [dbo].[Fornecedores] ([Codigo], [Nome], [Morada], [CodigoPostal], [LocalidadePostal], [Contribuinte], 
											[Vendedor], [Telefone], [Telemovel], [SMS], [Email], [AcessoOnlineAtivo], 
											[Username], [Password], [HorasValidadeSugestao], [ProdutosMatchingAutomatico], 
											[ProdutosCriacaoAutomatica], [DisponibilizaInfoProdutoDetalhe], 
											[DescricaoPontuacaoInicial], [CaracteristicasPontuacaoInicial], 
											[LinkPontuacaoInicial], [ImagemPontuacaoInicial], [DescricaoSugereInativo], 
											[CaracteristicasSugereInativo], [LinkSugereInativo], [ImagemSugereInativo], 
											[AtualizacaoAutomaticaInativaSugestao], [ProdutosConfiancaPreco], 
											[ProdutosConfiancaDisponibilidade], [Inativo], [Criacao], [Versao])
 
					VALUES (@Codigo, @Nome, @Morada, @CodigoPostal, @LocalidadePostal, @Contribuinte, 
											@Vendedor, @Telefone, @Telemovel, @SMS, @Email, @AcessoOnlineAtivo, 
											@Username, @Password, @HorasValidadeSugestao, @ProdutosMatchingAutomatico, 
											@ProdutosCriacaoAutomatica, @DisponibilizaInfoProdutoDetalhe, 
											@DescricaoPontuacaoInicial, @CaracteristicasPontuacaoInicial, 
											@LinkPontuacaoInicial, @ImagemPontuacaoInicial, @DescricaoSugereInativo, 
											@CaracteristicasSugereInativo, @LinkSugereInativo, @ImagemSugereInativo, 
											@AtualizacaoAutomaticaInativaSugestao, @ProdutosConfiancaPreco, 
											@ProdutosConfiancaDisponibilidade, @Inativo, @Criacao, @Versao);

		
		SET @NumeroLinhasAfetadas = @@ROWCOUNT -- GUARDAR O NUMERO DE LINHAS AFETADAS

		-- ACABA CONTAGEM DE @@ROWCOUNT
		SET NOCOUNT ON

		-- RETORNAR O NUMERO DE LINHAS AFETADAS
		-- Quando usado o ExecuteNonQuery é o @@ROWCOUNT que é lido (SET NOCOUNT OFF/ON),  e não esta variável
		RETURN @NumeroLinhasAfetadas

	END TRY


	-- SE EXISTIRAM ERROS, DESFAZER TRANSACÇÃO
	BEGIN CATCH

		-- DISPARAR UM ERRO
		SET @Erro = 'WhereToBuy-I10] ' + ERROR_MESSAGE();
		RAISERROR (@Erro, 15, 1)
		RETURN 0

	END CATCH
GO
PRINT N'Creating [dbo].[SupplierSelect]...';


GO
CREATE PROCEDURE [dbo].[SupplierSelect]
	@WhereClause nvarchar(1024) = '',			-- ex1: Codigo IN ('001', '002'); ex2: Descricao LIKE '_este'; ex3: Descricao LIKE '%est%'
	@OrderByClause nvarchar(256) = ''			-- ex: Codigo desc
AS
	
	DECLARE @select nvarchar(2048), @where nvarchar(1024), @orderBy nvarchar(256), @sqlQuery nvarchar(4000)
	

	SET @select = 'SELECT f.[Codigo], f.[Nome], f.[Morada], 
							f.[CodigoPostal], f.[LocalidadePostal], 
							f.[Contribuinte], f.[Vendedor], 
							f.[Telefone], f.[Telemovel], 
							f.[SMS], f.[Email], 
							f.[AcessoOnlineAtivo], 
							f.[Username], fornecedores.[Password], 
							f.[HorasValidadeSugestao], 
							f.[ProdutosMatchingAutomatico], 
							f.[ProdutosCriacaoAutomatica], 
							f.[DisponibilizaInfoProdutoDetalhe], 
							f.[DescricaoPontuacaoInicial], 
							f.[CaracteristicasPontuacaoInicial], 
							f.[LinkPontuacaoInicial], 
							f.[ImagemPontuacaoInicial], 
							f.[DescricaoSugereInativo], 
							f.[CaracteristicasSugereInativo], 
							f.[LinkSugereInativo], 
							f.[ImagemSugereInativo], 
							f.[AtualizacaoAutomaticaInativaSugestao], 
							f.[ProdutosConfiancaPreco], 
							f.[ProdutosConfiancaDisponibilidade], 
							f.[Inativo], fornecedores.[Criacao], 
							f.[Versao] 
						FROM [dbo].[Fornecedores] f' 
	

	SET @where = LTRIM(RTRIM(@WhereClause))
	IF Len(@where) > 0
	BEGIN
		SET @where = ' WHERE ' + @where
	END


	SET @orderBy = LTRIM(RTRIM(@OrderByClause))
	IF LEN(@orderBy) > 0
	BEGIN
		SET @orderBy = ' ORDER BY ' + @orderBy
	END


	SET @sqlQuery = @select + @where + @orderBy  


	EXEC(@sqlQuery)


RETURN @@ROWCOUNT
GO
PRINT N'Creating [dbo].[SupplierUpdate]...';


GO
CREATE PROCEDURE [dbo].[SupplierUpdate]
	@Codigo nvarchar(5), 
	@Nome nvarchar(50), 
	@Morada nvarchar(200), 
	@CodigoPostal nvarchar(15),
	@LocalidadePostal nvarchar(50), 
	@Contribuinte nvarchar(20), 
	@Vendedor nvarchar(50), 
	@Telefone nvarchar(20), 
	@Telemovel nvarchar(15), 
	@SMS nvarchar(15), 
	@Email nvarchar(100), 
	@AcessoOnlineAtivo bit, 
	@Username nvarchar(20), 
	@Password nvarchar(20), 
	@HorasValidadeSugestao smallint, 
	@ProdutosMatchingAutomatico bit, 
	@ProdutosCriacaoAutomatica bit, 
	@DisponibilizaInfoProdutoDetalhe bit, 
	@DescricaoPontuacaoInicial smallint, 
	@CaracteristicasPontuacaoInicial smallint, 
	@LinkPontuacaoInicial smallint, 
	@ImagemPontuacaoInicial smallint, 
	@DescricaoSugereInativo bit, 
	@CaracteristicasSugereInativo bit, 
	@LinkSugereInativo bit, 
	@ImagemSugereInativo bit, 
	@AtualizacaoAutomaticaInativaSugestao bit, 
	@ProdutosConfiancaPreco float, 
	@ProdutosConfiancaDisponibilidade float, 
	@Inativo bit, 
	@Versao datetime 


AS

	DECLARE @Erro nvarchar(255)


	-- VALIDAR SE O REGISTO EXISTE
	IF NOT EXISTS(SELECT [Codigo] FROM [dbo].[Fornecedores] WHERE [Codigo] = @Codigo)
	BEGIN
		-- DISPARAR UM ERRO
		SET @Erro = '[WhereToBuy-U01] ' + 'O registo que pretende alterar não existe!';
		RAISERROR (@Erro, 15, 1)
		RETURN 0
	END

	-- VALIDAR SE A VERSÃO AINDA É A MESMA
	IF NOT EXISTS(SELECT [Codigo] FROM [dbo].[Fornecedores] WHERE [Codigo] = @Codigo AND [Versao] = @Versao)
	BEGIN
		-- DISPARAR UM ERRO
		SET @Erro = '[WhereToBuy-U02] ' + 'O registo que pretende alterar, já foi alterado desde que o abriu!';
		RAISERROR (@Erro, 15, 1)
		RETURN 0
	END


	-- TUDO OK PARA SEGUIR EM FRENTE
	DECLARE @NovaVersao datetime, @NumeroLinhasAfetadas int

	SET @NovaVersao = GETDATE()


	-- ALTERAÇÃO DO REGISTO
	BEGIN TRY

		-- INICIA CONTAGEM DE @@ROWCOUNT (para quando usado o ExecuteNonQuery())
		SET NOCOUNT OFF

		-- ALTERAR REGISTO
		UPDATE [dbo].[Fornecedores] SET [Nome]=@Nome, 
										[Morada]=@Morada, 
										[CodigoPostal]=@CodigoPostal, 
										[LocalidadePostal]=@LocalidadePostal, 
										[Contribuinte]=@Contribuinte, 
										[Vendedor]=@Vendedor, 
										[Telefone]=@Telefone, 
										[Telemovel]=@Telemovel, 
										[SMS]=@SMS, 
										[Email]=@Email, 
										[AcessoOnlineAtivo]=@AcessoOnlineAtivo, 
										[Username]=@Username, 
										[Password]=@Password, 
										[HorasValidadeSugestao]=@HorasValidadeSugestao, 
										[ProdutosMatchingAutomatico]=@ProdutosMatchingAutomatico, 
										[ProdutosCriacaoAutomatica]=@ProdutosCriacaoAutomatica, 
										[DisponibilizaInfoProdutoDetalhe]=@DisponibilizaInfoProdutoDetalhe, 
										[DescricaoPontuacaoInicial]=@DescricaoPontuacaoInicial, 
										[CaracteristicasPontuacaoInicial]=@CaracteristicasPontuacaoInicial, 
										[LinkPontuacaoInicial]=@LinkPontuacaoInicial, 
										[ImagemPontuacaoInicial]=@ImagemPontuacaoInicial, 
										[DescricaoSugereInativo]=@DescricaoSugereInativo, 
										[CaracteristicasSugereInativo]=@CaracteristicasSugereInativo, 
										[LinkSugereInativo]=@LinkSugereInativo, 
										[ImagemSugereInativo]=@ImagemSugereInativo, 
										[AtualizacaoAutomaticaInativaSugestao]=@AtualizacaoAutomaticaInativaSugestao, 
										[ProdutosConfiancaPreco]=@ProdutosConfiancaPreco, 
										[ProdutosConfiancaDisponibilidade]=@ProdutosConfiancaDisponibilidade, 
										[Inativo]=@Inativo,
										[Versao] = @NovaVersao
								WHERE [Codigo] = @Codigo

		SET @NumeroLinhasAfetadas = @@ROWCOUNT -- GUARDAR O NUMERO DE LINHAS AFETADAS

		-- ACABA CONTAGEM DE @@ROWCOUNT
		SET NOCOUNT ON

		-- RETORNAR O NUMERO DE LINHAS AFETADAS
		-- Quando usado o ExecuteNonQuery é o @@ROWCOUNT que é lido (SET NOCOUNT OFF/ON), e não esta variável
		RETURN @NumeroLinhasAfetadas

	END TRY


	-- SE EXISTIRAM ERROS
	BEGIN CATCH

		-- DISPARAR UM ERRO
		SET @Erro = '[WhereToBuy-U10] ' + ERROR_MESSAGE();
		RAISERROR (@Erro, 15, 1)
		RETURN 0

	END CATCH
GO
PRINT N'Creating [dbo].[TaxCount]...';


GO
CREATE PROCEDURE [dbo].[TaxCount]
	@param1 int = 0,
	@param2 int
AS
	SELECT @param1, @param2
RETURN 0
GO
PRINT N'Creating [dbo].[TaxDelete]...';


GO
CREATE PROCEDURE [dbo].[TaxDelete]
	@param1 int = 0,
	@param2 int
AS
	SELECT @param1, @param2
RETURN 0
GO
PRINT N'Creating [dbo].[TaxInsert]...';


GO
CREATE PROCEDURE [dbo].[TaxInsert]
	@param1 int = 0,
	@param2 int
AS
	SELECT @param1, @param2
RETURN 0
GO
PRINT N'Creating [dbo].[TaxSelect]...';


GO
CREATE PROCEDURE [dbo].[TaxSelect]
	@param1 int = 0,
	@param2 int
AS
	SELECT @param1, @param2
RETURN 0
GO
PRINT N'Creating [dbo].[TaxUpdate]...';


GO
CREATE PROCEDURE [dbo].[TaxUpdate]
	@param1 int = 0,
	@param2 int
AS
	SELECT @param1, @param2
RETURN 0
GO
PRINT N'Creating [dbo].[UserCount]...';


GO
CREATE PROCEDURE [dbo].[UserCount]
	@WhereClause nvarchar(512) = ''			-- ex1: Codigo IN ('001', '002'); ex2: Descricao LIKE '_este'; ex3: Descricao LIKE '%est%'
AS

	DECLARE @select nvarchar(1024), @where nvarchar(512), @sqlQuery nvarchar(2048)

	SET @select = 'SELECT Count([Username]) FROM [dbo].[Utilizadores]' 

	SET @where = LTRIM(RTRIM(@WhereClause))
	IF Len(@where) > 0
	BEGIN
		SET @where = ' WHERE ' + @where
	END


	SET @sqlQuery = @select + @where


	EXEC(@sqlQuery)

RETURN  -- This SP must be used with ExecuteScalar
RETURN 0
GO
PRINT N'Creating [dbo].[UserDelete]...';


GO
CREATE PROCEDURE [dbo].[UserDelete]
	@Username nvarchar(20),
	@Versao datetime
AS
	DECLARE @Erro nvarchar(255)


	-- VALIDAR SE O CODIGO EXISTE
	IF NOT EXISTS(SELECT [Username] FROM [dbo].[Utilizadores] WHERE [Username] = @Username)
	BEGIN
		-- DISPARAR UM ERRO
		SET @Erro = '[WhereToBuy-D01] ' + 'O registo que pretende eliminar não existe!';
		RAISERROR (@Erro, 15, 1)
		RETURN 0
	END

	-- VALIDAR SE A VERSÃO AINDA É A MESMA
	IF NOT EXISTS(SELECT [Username] FROM [dbo].[Utilizadores] WHERE [Username] = @Username AND [Versao] = @Versao)
	BEGIN
		-- DISPARAR UM ERRO
		SET @Erro = '[WhereToBuy-D02] ' + 'O registo que pretende eliminar, já foi alterado desde que o abriu!';
		RAISERROR (@Erro, 15, 1)
		RETURN 0
	END


	-- TUDO OK PARA SEGUIR EM FRENTE
	DECLARE @NumeroLinhasAfetadas int


	-- ELIMINAR O REGISTO
	BEGIN TRY

		-- INICIA CONTAGEM DE @@ROWCOUNT (para quando usado o ExecuteNonQuery())
		SET NOCOUNT OFF
		 
		-- ELIMINAR REGISTO
		DELETE FROM [dbo].[Utilizadores] Where [Username] = @Username

		SET @NumeroLinhasAfetadas = @@ROWCOUNT -- GUARDAR O NUMERO DE LINHAS AFETADAS

		-- ACABA CONTAGEM DE @@ROWCOUNT
		SET NOCOUNT ON

		-- RETORNAR O NUMERO DE LINHAS AFETADAS
		-- Quando usado o ExecuteNonQuery é o @@ROWCOUNT que é lido (SET NOCOUNT OFF/ON), e não esta variável
		RETURN @NumeroLinhasAfetadas

	END TRY


	-- SE EXISTIRAM ERROS
	BEGIN CATCH
		
		-- DISPARAR UM ERRO
		SET @Erro = '[WhereToBuy-D10] ' + ERROR_MESSAGE();
		RAISERROR (@Erro, 15, 1)
		RETURN 0

	END CATCH
GO
PRINT N'Creating [dbo].[UserInsert]...';


GO
CREATE PROCEDURE [dbo].[UserInsert]
	@Username nvarchar(20),
	@Password varbinary(64),
	@Nome nvarchar(50),
	@Email nvarchar(100),
	@Mobile nvarchar(15),
	@Sms nvarchar(15),
	@Administrador bit,
	@Inativo bit
AS
	
	DECLARE @Criacao smalldatetime, @Versao datetime, @NumeroLinhasAfetadas int, @Erro nvarchar(255)

	SET @Criacao = GETDATE()
	SET @Versao = GETDATE()


	-- INSERÇÃO DO REGISTO
	BEGIN TRY
		 
		-- INICIA CONTAGEM DE @@ROWCOUNT (para quando usado o ExecuteNonQuery())
		SET NOCOUNT OFF

		-- INSERIR REGISTO
		INSERT INTO [dbo].[Utilizadores] ([Username], [Password], [Nome], [Email], [Mobile], [Sms], [Administrador], [Inativo], [Criacao], [Versao]) 
					VALUES (@Username, HASHBYTES('SHA2_512', @Password), @Nome, @Email, @Mobile, @Sms, @Administrador, @Inativo, @Criacao, @Versao);
		
		SET @NumeroLinhasAfetadas = @@ROWCOUNT -- GUARDAR O NUMERO DE LINHAS AFETADAS

		-- ACABA CONTAGEM DE @@ROWCOUNT
		SET NOCOUNT ON

		-- RETORNAR O NUMERO DE LINHAS AFETADAS
		-- Quando usado o ExecuteNonQuery é o @@ROWCOUNT que é lido (SET NOCOUNT OFF/ON),  e não esta variável
		RETURN @NumeroLinhasAfetadas

	END TRY


	-- SE EXISTIRAM ERROS, DESFAZER TRANSACÇÃO
	BEGIN CATCH

		-- DISPARAR UM ERRO
		SET @Erro = 'WhereToBuy-I10] ' + ERROR_MESSAGE();
		RAISERROR (@Erro, 15, 1)
		RETURN 0

	END CATCH
GO
PRINT N'Creating [dbo].[UserSelect]...';


GO
CREATE PROCEDURE [dbo].[UserSelect]
	@WhereClause nvarchar(1024) = '',			-- ex1: Codigo IN ('001', '002'); ex2: Descricao LIKE '_este'; ex3: Descricao LIKE '%est%'
	@OrderByClause nvarchar(256) = ''			-- ex: Codigo desc
AS
	
	DECLARE @select nvarchar(2048), @where nvarchar(1024), @orderBy nvarchar(256), @sqlQuery nvarchar(4000)
	

	SET @select = 'SELECT utilizadores.[Username], utilizadores.[Password], utilizadores.[Nome], utilizadores.[Email], utilizadores.[Mobile], utilizadores.[Sms], utilizadores.[Administrador], utilizadores.[Inativo], utilizadores.[Criacao], utilizadores.[Versao]				
						FROM [dbo].[Utilizadores] utilizadores' 
	

	SET @where = LTRIM(RTRIM(@WhereClause))
	IF Len(@where) > 0
	BEGIN
		SET @where = ' WHERE ' + @where
	END


	SET @orderBy = LTRIM(RTRIM(@OrderByClause))
	IF LEN(@orderBy) > 0
	BEGIN
		SET @orderBy = ' ORDER BY ' + @orderBy
	END


	SET @sqlQuery = @select + @where + @orderBy  


	EXEC(@sqlQuery)


RETURN @@ROWCOUNT
GO
PRINT N'Creating [dbo].[UserUpdate]...';


GO
CREATE PROCEDURE [dbo].[UserUpdate]
	@Username nvarchar(20),
	@Password varbinary(64),
	@Nome nvarchar(50),
	@Email nvarchar(100),
	@Mobile nvarchar(15),
	@Sms nvarchar(15),
	@Administrador bit,
	@Inativo bit,
	@Versao datetime
AS

	DECLARE @Erro nvarchar(255)


	-- VALIDAR SE O REGISTO EXISTE
	IF NOT EXISTS(SELECT [Username] FROM [dbo].[Utilizadores] WHERE [Username] = @Username)
	BEGIN
		-- DISPARAR UM ERRO
		SET @Erro = '[WhereToBuy-U01] ' + 'O registo que pretende alterar não existe!';
		RAISERROR (@Erro, 15, 1)
		RETURN 0
	END

	-- VALIDAR SE A VERSÃO AINDA É A MESMA
	IF NOT EXISTS(SELECT [Username] FROM [dbo].[Utilizadores] WHERE [Username] = @Username AND [Versao] = @Versao)
	BEGIN
		-- DISPARAR UM ERRO
		SET @Erro = '[WhereToBuy-U02] ' + 'O registo que pretende alterar, já foi alterado desde que o abriu!';
		RAISERROR (@Erro, 15, 1)
		RETURN 0
	END


	-- TUDO OK PARA SEGUIR EM FRENTE
	DECLARE @NovaVersao datetime, @NumeroLinhasAfetadas int

	SET @NovaVersao = GETDATE()


	-- ALTERAÇÃO DO REGISTO
	BEGIN TRY

		-- INICIA CONTAGEM DE @@ROWCOUNT (para quando usado o ExecuteNonQuery())
		SET NOCOUNT OFF

		-- ALTERAR REGISTO
		UPDATE [dbo].[Utilizadores] SET [Password] = HASHBYTES('SHA2_512', @Password),
									[Nome] = @Nome,
									[Email] = @Email,
									[Mobile] = @Mobile,
									[Sms] = @Sms,
									[Administrador] = @Administrador,
									[Versao] = @NovaVersao

								WHERE [Username] = @Username

		SET @NumeroLinhasAfetadas = @@ROWCOUNT -- GUARDAR O NUMERO DE LINHAS AFETADAS

		-- ACABA CONTAGEM DE @@ROWCOUNT
		SET NOCOUNT ON

		-- RETORNAR O NUMERO DE LINHAS AFETADAS
		-- Quando usado o ExecuteNonQuery é o @@ROWCOUNT que é lido (SET NOCOUNT OFF/ON), e não esta variável
		RETURN @NumeroLinhasAfetadas

	END TRY


	-- SE EXISTIRAM ERROS
	BEGIN CATCH

		-- DISPARAR UM ERRO
		SET @Erro = '[WhereToBuy-U10] ' + ERROR_MESSAGE();
		RAISERROR (@Erro, 15, 1)
		RETURN 0

	END CATCH
GO
PRINT N'Creating [dbo].[WarningTypeCount]...';


GO
CREATE PROCEDURE [dbo].[WarningTypeCount]
	@WhereClause nvarchar(512) = ''			-- ex1: Codigo IN ('001', '002'); ex2: Descricao LIKE '_este'; ex3: Descricao LIKE '%est%'
AS

	DECLARE @select nvarchar(1024), @where nvarchar(512), @sqlQuery nvarchar(2048)

	SET @select = 'SELECT Count([Codigo]) FROM [dbo].[AvisosTipo]' 

	SET @where = LTRIM(RTRIM(@WhereClause))
	IF Len(@where) > 0
	BEGIN
		SET @where = ' WHERE ' + @where
	END


	SET @sqlQuery = @select + @where


	EXEC(@sqlQuery)

RETURN  -- This SP must be used with ExecuteScalar
GO
PRINT N'Creating [dbo].[WarningTypeDelete]...';


GO
CREATE PROCEDURE [dbo].[WarningTypeDelete]
	@Codigo nvarchar(5),
	@Versao datetime
AS
	DECLARE @Erro nvarchar(255)


	-- VALIDAR SE O CODIGO EXISTE
	IF NOT EXISTS(SELECT [Codigo] FROM [dbo].[AvisosTipo] WHERE [Codigo] = @Codigo)
	BEGIN
		-- DISPARAR UM ERRO
		SET @Erro = '[WhereToBuy-D01] ' + 'O registo que pretende eliminar não existe!';
		RAISERROR (@Erro, 15, 1)
		RETURN 0
	END

	-- VALIDAR SE A VERSÃO AINDA É A MESMA
	IF NOT EXISTS(SELECT [Codigo] FROM [dbo].[AvisosTipo] WHERE [Codigo] = @Codigo AND [Versao] = @Versao)
	BEGIN
		-- DISPARAR UM ERRO
		SET @Erro = '[WhereToBuy-D02] ' + 'O registo que pretende eliminar, já foi alterado desde que o abriu!';
		RAISERROR (@Erro, 15, 1)
		RETURN 0
	END


	-- TUDO OK PARA SEGUIR EM FRENTE
	DECLARE @NumeroLinhasAfetadas int


	-- ELIMINAR O REGISTO
	BEGIN TRY

		-- INICIA CONTAGEM DE @@ROWCOUNT (para quando usado o ExecuteNonQuery())
		SET NOCOUNT OFF
		 
		-- ELIMINAR REGISTO
		DELETE FROM [dbo].[AvisosTipo] Where [Codigo] = @Codigo

		SET @NumeroLinhasAfetadas = @@ROWCOUNT -- GUARDAR O NUMERO DE LINHAS AFETADAS

		-- ACABA CONTAGEM DE @@ROWCOUNT
		SET NOCOUNT ON

		-- RETORNAR O NUMERO DE LINHAS AFETADAS
		-- Quando usado o ExecuteNonQuery é o @@ROWCOUNT que é lido (SET NOCOUNT OFF/ON), e não esta variável
		RETURN @NumeroLinhasAfetadas

	END TRY


	-- SE EXISTIRAM ERROS
	BEGIN CATCH
		
		-- DISPARAR UM ERRO
		SET @Erro = '[WhereToBuy-D10] ' + ERROR_MESSAGE();
		RAISERROR (@Erro, 15, 1)
		RETURN 0

	END CATCH
GO
PRINT N'Creating [dbo].[WarningTypeInsert]...';


GO
CREATE PROCEDURE [dbo].[WarningTypeInsert]
	@Codigo nvarchar(5),
	@Descricao nvarchar(128),
	@Gravidade smallint,
	@Notas nvarchar(256),
	@Icon nvarchar(20),
	@Inativo bit
AS
	
	DECLARE @Criacao smalldatetime, @Versao datetime, @NumeroLinhasAfetadas int, @Erro nvarchar(255)

	SET @Criacao = GETDATE()
	SET @Versao = GETDATE()


	-- INSERÇÃO DO REGISTO
	BEGIN TRY
		 
		-- INICIA CONTAGEM DE @@ROWCOUNT (para quando usado o ExecuteNonQuery())
		SET NOCOUNT OFF

		-- INSERIR REGISTO
		INSERT INTO [dbo].[AvisosTipo] ([Codigo], [Descricao], [Gravidade], [Notas], [Icon], [Inativo], [Criacao], [Versao]) 
					VALUES (@Codigo, @Descricao, @Gravidade, @Notas, @Icon, @Inativo, @Criacao, @Versao);
		
		SET @NumeroLinhasAfetadas = @@ROWCOUNT -- GUARDAR O NUMERO DE LINHAS AFETADAS

		-- ACABA CONTAGEM DE @@ROWCOUNT
		SET NOCOUNT ON

		-- RETORNAR O NUMERO DE LINHAS AFETADAS
		-- Quando usado o ExecuteNonQuery é o @@ROWCOUNT que é lido (SET NOCOUNT OFF/ON),  e não esta variável
		RETURN @NumeroLinhasAfetadas

	END TRY


	-- SE EXISTIRAM ERROS, DESFAZER TRANSACÇÃO
	BEGIN CATCH

		-- DISPARAR UM ERRO
		SET @Erro = 'WhereToBuy-I10] ' + ERROR_MESSAGE();
		RAISERROR (@Erro, 15, 1)
		RETURN 0

	END CATCH
GO
PRINT N'Creating [dbo].[WarningTypeSelect]...';


GO
CREATE PROCEDURE [dbo].[WarningTypeSelect]
	@WhereClause nvarchar(1024) = '',			-- ex1: Codigo IN ('001', '002'); ex2: Descricao LIKE '_este'; ex3: Descricao LIKE '%est%'
	@OrderByClause nvarchar(256) = ''			-- ex: Codigo desc
AS
	
	DECLARE @select nvarchar(2048), @where nvarchar(1024), @orderBy nvarchar(256), @sqlQuery nvarchar(4000)
	

	SET @select = 'SELECT avisosTipo.[Codigo], avisosTipo.[Descricao], avisosTipo.[Gravidade], avisosTipo.[Notas], avisosTipo.[Icon], avisosTipo.[Inativo], avisosTipo.[Criacao], avisosTipo.[Versao]				
						FROM [dbo].[AvisosTipo] avisosTipo' 
	

	SET @where = LTRIM(RTRIM(@WhereClause))
	IF Len(@where) > 0
	BEGIN
		SET @where = ' WHERE ' + @where
	END


	SET @orderBy = LTRIM(RTRIM(@OrderByClause))
	IF LEN(@orderBy) > 0
	BEGIN
		SET @orderBy = ' ORDER BY ' + @orderBy
	END


	SET @sqlQuery = @select + @where + @orderBy  


	EXEC(@sqlQuery)


RETURN @@ROWCOUNT
GO
PRINT N'Creating [dbo].[WarningTypeUpdate]...';


GO
CREATE PROCEDURE [dbo].[WarningTypeUpdate]
	@Codigo nvarchar(5),
	@Descricao nvarchar(128),
	@Gravidade smallint,
	@Notas nvarchar(256),
	@Icon nvarchar(20),
	@Inativo bit,
	@Versao datetime
AS

	DECLARE @Erro nvarchar(255)


	-- VALIDAR SE O REGISTO EXISTE
	IF NOT EXISTS(SELECT [Codigo] FROM [dbo].[AvisosTipo] WHERE [Codigo] = @Codigo)
	BEGIN
		-- DISPARAR UM ERRO
		SET @Erro = '[WhereToBuy-U01] ' + 'O registo que pretende alterar não existe!';
		RAISERROR (@Erro, 15, 1)
		RETURN 0
	END

	-- VALIDAR SE A VERSÃO AINDA É A MESMA
	IF NOT EXISTS(SELECT [Codigo] FROM [dbo].[AvisosTipo] WHERE [Codigo] = @Codigo AND [Versao] = @Versao)
	BEGIN
		-- DISPARAR UM ERRO
		SET @Erro = '[WhereToBuy-U02] ' + 'O registo que pretende alterar, já foi alterado desde que o abriu!';
		RAISERROR (@Erro, 15, 1)
		RETURN 0
	END


	-- TUDO OK PARA SEGUIR EM FRENTE
	DECLARE @NovaVersao datetime, @NumeroLinhasAfetadas int

	SET @NovaVersao = GETDATE()


	-- ALTERAÇÃO DO REGISTO
	BEGIN TRY

		-- INICIA CONTAGEM DE @@ROWCOUNT (para quando usado o ExecuteNonQuery())
		SET NOCOUNT OFF

		-- ALTERAR REGISTO
		UPDATE [dbo].[AvisosTipo] SET [Descricao] = @Descricao,
										[Gravidade]=@Gravidade,
										[Notas]=@Notas,
										[Icon]=@Icon,
										[Versao] = @NovaVersao
									WHERE [Codigo] = @Codigo

		SET @NumeroLinhasAfetadas = @@ROWCOUNT -- GUARDAR O NUMERO DE LINHAS AFETADAS

		-- ACABA CONTAGEM DE @@ROWCOUNT
		SET NOCOUNT ON

		-- RETORNAR O NUMERO DE LINHAS AFETADAS
		-- Quando usado o ExecuteNonQuery é o @@ROWCOUNT que é lido (SET NOCOUNT OFF/ON), e não esta variável
		RETURN @NumeroLinhasAfetadas

	END TRY


	-- SE EXISTIRAM ERROS
	BEGIN CATCH

		-- DISPARAR UM ERRO
		SET @Erro = '[WhereToBuy-U10] ' + ERROR_MESSAGE();
		RAISERROR (@Erro, 15, 1)
		RETURN 0

	END CATCH
GO
PRINT N'Creating [dbo].[WorryingTermCount]...';


GO
CREATE PROCEDURE [dbo].[WorryingTermCount]
	@param1 int = 0,
	@param2 int
AS
	SELECT @param1, @param2
RETURN 0
GO
PRINT N'Creating [dbo].[WorryingTermDelete]...';


GO
CREATE PROCEDURE [dbo].[WorryingTermDelete]
	@param1 int = 0,
	@param2 int
AS
	SELECT @param1, @param2
RETURN 0
GO
PRINT N'Creating [dbo].[WorryingTermInsert]...';


GO
CREATE PROCEDURE [dbo].[WorryingTermInsert]
	@param1 int = 0,
	@param2 int
AS
	SELECT @param1, @param2
RETURN 0
GO
PRINT N'Creating [dbo].[WorryingTermSelect]...';


GO
CREATE PROCEDURE [dbo].[WorryingTermSelect]
	@param1 int = 0,
	@param2 int
AS
	SELECT @param1, @param2
RETURN 0
GO
PRINT N'Creating [dbo].[WorryingTermUpdate]...';


GO
CREATE PROCEDURE [dbo].[WorryingTermUpdate]
	@param1 int = 0,
	@param2 int
AS
	SELECT @param1, @param2
RETURN 0
GO
/*
Post-Deployment Script Template							
--------------------------------------------------------------------------------------
 This file contains SQL statements that will be appended to the build script.		
 Use SQLCMD syntax to include a file in the post-deployment script.			
 Example:      :r .\myfile.sql								
 Use SQLCMD syntax to reference a variable in the post-deployment script.		
 Example:      :setvar TableName MyTable							
               SELECT * FROM [$(TableName)]					
--------------------------------------------------------------------------------------
*/


/* IMPOSTOS */
IF NOT EXISTS(SELECT [Codigo] FROM [dbo].[Impostos])
BEGIN	
	INSERT INTO [dbo].[Impostos] ([Codigo], [Descricao], [DesignacaoFiscal], [Taxa], [Inativo], [Criacao], [Versao])
		VALUES ('PT.23', 'IVA PT Continental - Taxa Normal de 23%', 'IVA PT.Continental 23%', 23.00, CAST('false' AS bit), GETDATE(), GETDATE())
END


/* COMPLEMENTOS */
IF NOT EXISTS(SELECT [Codigo] FROM [dbo].[Complementos])
BEGIN	
	INSERT INTO [dbo].[Complementos] ([Codigo], [Descricao], [TermoAcrescentar], [TermosRemover], [Inativo], [Criacao], [Versao])
		VALUES ('N/A', 'Não aplicável', NULL, NULL, CAST('false' AS bit), GETDATE(), GETDATE())
END


/* AVISOSTIPO */
IF NOT EXISTS(SELECT [Codigo] FROM [dbo].[AvisosTipo])
BEGIN	
	INSERT INTO [dbo].[AvisosTipo] ([Codigo], [Descricao], [Gravidade], [Notas], [Icon], [Inativo], [Criacao], [Versao])
		 VALUES ('PFS', 'Prevenção Falso Stock', 3, NULL, NULL, CAST('false' AS bit), GETDATE(), GETDATE()),
				('IAPD1', 'Inativação Administrativa (Prevenção Preço Desfazado - Preco fora do intervalo)', 7, NULL, NULL, CAST('false' AS bit), GETDATE(), GETDATE()),
				('IAPD2', 'Inativação Administrativa (Prevenção Preço Desfazado - Amplitude do preço excedida)', 7, NULL, NULL, CAST('false' AS bit), GETDATE(), GETDATE()),
				
				('CICM0', 'Cotação Incompleta [Complemento] (mapeamento incompleto, preenchimento manual necessário)', 6, NULL, NULL, CAST('false' AS bit), GETDATE(), GETDATE()),
				('CICM1', 'Cotação Incompleta [Complemento] (mapeamento inativo)', 2, NULL, NULL, CAST('false' AS bit), GETDATE(), GETDATE()),
				('CIMM0', 'Cotação Incompleta [Marca] (mapeamento incompleto, preenchimento manual necessário)', 6, NULL, NULL, CAST('false' AS bit), GETDATE(), GETDATE()),
				('CIMM1', 'Cotação Incompleta [Marca] (mapeamento inativo)', 2, NULL, NULL, CAST('false' AS bit), GETDATE(), GETDATE()),
				('CITM0', 'Cotação Incompleta [Categoria] (mapeamento incompleto, preenchimento manual necessário)', 6, NULL, NULL, CAST('false' AS bit), GETDATE(), GETDATE()),
				('CITM1', 'Cotação Incompleta [Categoria] (mapeamento inativo)', 2, NULL, NULL, CAST('false' AS bit), GETDATE(), GETDATE()),
				('CISM0', 'Cotação Incompleta [Stock] (mapeamento incompleto, preenchimento manual necessário)', 6, NULL, NULL, CAST('false' AS bit), GETDATE(), GETDATE()),
				('CISM1', 'Cotação Incompleta [Stock] (mapeamento inativo)', 6, NULL, NULL, CAST('false' AS bit), GETDATE(), GETDATE()),
				('CIIM0', 'Cotação Incompleta [Imposto] (mapeamento incompleto, preenchimento manual necessário)', 6, NULL, NULL, CAST('false' AS bit), GETDATE(), GETDATE()),
				('CIIM1', 'Cotação Incompleta [Imposto] (mapeamento inativo)', 2, NULL, NULL, CAST('false' AS bit), GETDATE(), GETDATE()),
				('CIDM0', 'Cotação Incompleta [Estado] (mapeamento incompleto, preenchimento manual necessário)', 6, NULL, NULL, CAST('false' AS bit), GETDATE(), GETDATE()),
				('CIDM1', 'Cotação Incompleta [Estado] (mapeamento inativo)', 2, NULL, NULL, CAST('false' AS bit), GETDATE(), GETDATE()),
				('CIPM0', 'Cotação Incompleta [Produto] (mapeamento incompleto, preenchimento manual necessário)', 6, NULL, NULL, CAST('false' AS bit), GETDATE(), GETDATE()),
				('CIPM1', 'Cotação Incompleta [Produto] (mapeamento inativo)', 2, NULL, NULL, CAST('false' AS bit), GETDATE(), GETDATE()),
				('CIPM2', 'Cotação Incompleta [Produto] (fornecedor configurado para não criar automaticamente fichas de produtos)', 6, NULL, NULL, CAST('false' AS bit), GETDATE(), GETDATE()),
				('CIPM3', 'Cotação Incompleta [Produto] (fornecedor configurado para não mapear automaticamente produtos)', 6, NULL, NULL, CAST('false' AS bit), GETDATE(), GETDATE()),
				('CIPM4', 'Cotação Incompleta [Produto] (produto inativo)', 2, NULL, NULL, CAST('false' AS bit), GETDATE(), GETDATE()),
				('CIPM9', 'Cotação Incompleta [Produto] (ambiguidade detetada com outro partnumber de outra marca)', 8, NULL, NULL, CAST('false' AS bit), GETDATE(), GETDATE()),

				('CAC01', 'Cotação Atuais, atualização de Preço de Custo (CotacoesRegras, ProdutosMatching)', 4, NULL, NULL, CAST('false' AS bit), GETDATE(), GETDATE()),
				('CAC02', 'Cotação Atuais, atualização da formula do Preço de Custo', 2, NULL, NULL, CAST('false' AS bit), GETDATE(), GETDATE()),
				('CAC03', 'Cotação Atuais, atualização de Validade (CotacoesRegras, ProdutosMatching)', 4, NULL, NULL, CAST('false' AS bit), GETDATE(), GETDATE()),
				('CAC04', 'Cotação Atuais, atualização da formula de calculo da Validade', 2, NULL, NULL, CAST('false' AS bit), GETDATE(), GETDATE()),
				('CAC05', 'Cotação Atuais, atualização da descrição do produto', 4, NULL, NULL, CAST('false' AS bit), GETDATE(), GETDATE()),
				('CAC06', 'Cotação Atuais, atualização das caracteristicas do produto', 4, NULL, NULL, CAST('false' AS bit), GETDATE(), GETDATE()),
				('CAC07', 'Cotação Atuais, atualização do link do produto', 4, NULL, NULL, CAST('false' AS bit), GETDATE(), GETDATE()),
				('CAC08', 'Cotação Atuais, atualização da imagem do produto', 4, NULL, NULL, CAST('false' AS bit), GETDATE(), GETDATE()),
				('CAC09', 'Cotação Atuais, atualização do código substituto de stock (CotacoesRegras, ProdutosMatching)', 4, NULL, NULL, CAST('false' AS bit), GETDATE(), GETDATE()),
				('CAC10', 'Cotação Atuais, atualização da justificação de alteração do código substituto', 2, NULL, NULL, CAST('false' AS bit), GETDATE(), GETDATE())

END



/* STOCKS */
IF NOT EXISTS(SELECT [Codigo] FROM [dbo].[Stocks])
BEGIN	
	INSERT INTO [dbo].[Stocks] ([Codigo], [Descricao], [DisponibilidadeNivel], [Notas], [Inativo], [Criacao], [Versao])
		 VALUES ('D-5','Indisponivel permanentemente', -5, NULL, CAST('false' AS bit), GETDATE(), GETDATE()),
				('D-4','Indisponivel sob encomenda (dias entrega: +40)', -4, NULL, CAST('false' AS bit), GETDATE(), GETDATE()),
				('D-3','Indisponivel sob encomenda (dias entrega: +25)', -3, NULL, CAST('false' AS bit), GETDATE(), GETDATE()),
				('D-2','Indisponivel sob encomenda (dias entrega: +10)', -2, NULL, CAST('false' AS bit), GETDATE(), GETDATE()),
				('D-1','Indisponivel sob encomenda (dias entrega: +6)', -1, NULL, CAST('false' AS bit), GETDATE(), GETDATE()),
				('D+0','Indisponivel momentaneamente (dias entrega: +2)', 0, NULL, CAST('false' AS bit), GETDATE(), GETDATE()),
				('D+1','Disponivel, stock reduzido', 1, NULL, CAST('false' AS bit), GETDATE(), GETDATE()),
				('D+2','Disponivel, stock limitado', 2, NULL, CAST('false' AS bit), GETDATE(), GETDATE()),
				('D+3','Disponivel, stock normal', 3, NULL, CAST('false' AS bit), GETDATE(), GETDATE()),
				('D+4','Disponivel, stock abundante', 4, NULL, CAST('false' AS bit), GETDATE(), GETDATE()),
				('D+5','Disponivel permanentemente', 5, NULL, CAST('false' AS bit), GETDATE(), GETDATE())
END




/* FORNECEDORES */
IF NOT EXISTS(SELECT [Codigo] FROM [dbo].[Fornecedores])
BEGIN	
	INSERT INTO [dbo].[Fornecedores]
			   ([Codigo], [Nome], [Morada], [CodigoPostal], [LocalidadePostal], [Contribuinte], 
				[Vendedor], [Telefone], [Telemovel], [SMS], [Email], [AcessoOnlineAtivo], [Username], [Password],
				[HorasValidadeSugestao], [ProdutosMatchingAutomatico], [ProdutosCriacaoAutomatica], [DisponibilizaInfoProdutoDetalhe],
				[DescricaoPontuacaoInicial], [CaracteristicasPontuacaoInicial], [LinkPontuacaoInicial], [ImagemPontuacaoInicial],
				[DescricaoSugereInativo], [CaracteristicasSugereInativo], [LinkSugereInativo], [ImagemSugereInativo],
				[AtualizacaoAutomaticaInativaSugestao], [ProdutosConfiancaPreco], [ProdutosConfiancaDisponibilidade],
				[Inativo], [Criacao], [Versao])
		 VALUES
			   ('00024', 'CPC - Companhia Portuguesa de Computadores...', 'Rua Monte dos Pipos, 649', '4460-059', 'Guifões', '999999990',
				'Susana', '222333444', '939949959', '969979989', 'susana@cpcdi.pt', CAST('false' AS bit), 'cpc001', 'cpcpass',
				24, CAST('true' AS bit), CAST('true' AS bit), CAST('true' AS bit),
				5, 5, 5, 5,
				CAST('false' AS bit), CAST('false' AS bit), CAST('false' AS bit), CAST('false' AS bit),
				CAST('false' AS bit), 90, 90,
				CAST('false' AS bit), GETDATE(), GETDATE())
END



/* ESTADOS */
IF NOT EXISTS(SELECT [Codigo] FROM [dbo].[Estados])
BEGIN	
	INSERT INTO [dbo].[Estados] ([Codigo], [Descricao], [Inativo], [Criacao], [Versao])
		VALUES ('NOVO', 'Produto novo (nunca usado)', CAST('false' AS bit), GETDATE(), GETDATE()),
			   ('PROMO', 'Produto em promoção', CAST('false' AS bit), GETDATE(), GETDATE()),
			   ('USADO', 'Produto usado', CAST('false' AS bit), GETDATE(), GETDATE()),
			   ('OPORT', 'Oportunidade', CAST('false' AS bit), GETDATE(), GETDATE()),
			   ('GOPOR', 'Grande oportunidade', CAST('false' AS bit), GETDATE(), GETDATE())
END




/* TERMOSPREOCUPANTES */
IF NOT EXISTS(SELECT [Termo] FROM [dbo].[TermosPreocupantes])
BEGIN	
	INSERT INTO [dbo].[TermosPreocupantes] ([Termo], [Indice] ,[Notas], [Inativo], [Criacao], [Versao])
		VALUES ('%[ ]saldo[ ]%', 6, '', CAST('false' AS bit), GETDATE(), GETDATE()),
			   ('%[ ]promo%', 6, '', CAST('false' AS bit), GETDATE(), GETDATE()),
			   ('%<a[ ]%', 7, '', CAST('false' AS bit), GETDATE(), GETDATE()),
			   ('%[< |<| ]script[ ]%', 9, '', CAST('false' AS bit), GETDATE(), GETDATE()),
			   ('%[ ]href[ =]%', 7, '', CAST('false' AS bit), GETDATE(), GETDATE()),
			   ('%<br%', 7, '', CAST('false' AS bit), GETDATE(), GETDATE())
			  
END
GO

GO
DECLARE @VarDecimalSupported AS BIT;

SELECT @VarDecimalSupported = 0;

IF ((ServerProperty(N'EngineEdition') = 3)
    AND (((@@microsoftversion / power(2, 24) = 9)
          AND (@@microsoftversion & 0xffff >= 3024))
         OR ((@@microsoftversion / power(2, 24) = 10)
             AND (@@microsoftversion & 0xffff >= 1600))))
    SELECT @VarDecimalSupported = 1;

IF (@VarDecimalSupported > 0)
    BEGIN
        EXECUTE sp_db_vardecimal_storage_format N'$(DatabaseName)', 'ON';
    END


GO
PRINT N'Update complete.';


GO
